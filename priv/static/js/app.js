/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Phoenix = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n        get: () => from[key],\n        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n      });\n    }\n\n    return to;\n  };\n\n  var __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod); // js/phoenix/index.js\n\n\n  var phoenix_exports = {};\n\n  __export(phoenix_exports, {\n    Channel: () => Channel,\n    LongPoll: () => LongPoll,\n    Presence: () => Presence,\n    Serializer: () => serializer_default,\n    Socket: () => Socket\n  }); // js/phoenix/utils.js\n\n\n  var closure = value => {\n    if (typeof value === \"function\") {\n      return value;\n    } else {\n      let closure2 = function () {\n        return value;\n      };\n\n      return closure2;\n    }\n  }; // js/phoenix/constants.js\n\n\n  var globalSelf = typeof self !== \"undefined\" ? self : null;\n  var phxWindow = typeof window !== \"undefined\" ? window : null;\n  var global = globalSelf || phxWindow || global;\n  var DEFAULT_VSN = \"2.0.0\";\n  var SOCKET_STATES = {\n    connecting: 0,\n    open: 1,\n    closing: 2,\n    closed: 3\n  };\n  var DEFAULT_TIMEOUT = 1e4;\n  var WS_CLOSE_NORMAL = 1e3;\n  var CHANNEL_STATES = {\n    closed: \"closed\",\n    errored: \"errored\",\n    joined: \"joined\",\n    joining: \"joining\",\n    leaving: \"leaving\"\n  };\n  var CHANNEL_EVENTS = {\n    close: \"phx_close\",\n    error: \"phx_error\",\n    join: \"phx_join\",\n    reply: \"phx_reply\",\n    leave: \"phx_leave\"\n  };\n  var TRANSPORTS = {\n    longpoll: \"longpoll\",\n    websocket: \"websocket\"\n  };\n  var XHR_STATES = {\n    complete: 4\n  }; // js/phoenix/push.js\n\n  var Push = class {\n    constructor(channel, event, payload, timeout) {\n      this.channel = channel;\n      this.event = event;\n\n      this.payload = payload || function () {\n        return {};\n      };\n\n      this.receivedResp = null;\n      this.timeout = timeout;\n      this.timeoutTimer = null;\n      this.recHooks = [];\n      this.sent = false;\n    }\n\n    resend(timeout) {\n      this.timeout = timeout;\n      this.reset();\n      this.send();\n    }\n\n    send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload(),\n        ref: this.ref,\n        join_ref: this.channel.joinRef()\n      });\n    }\n\n    receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({\n        status,\n        callback\n      });\n      return this;\n    }\n\n    reset() {\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n    }\n\n    matchReceive({\n      status,\n      response,\n      _ref\n    }) {\n      this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n    }\n\n    cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n\n      this.channel.off(this.refEvent);\n    }\n\n    cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n\n    startTimeout() {\n      if (this.timeoutTimer) {\n        this.cancelTimeout();\n      }\n\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n      this.channel.on(this.refEvent, payload => {\n        this.cancelRefEvent();\n        this.cancelTimeout();\n        this.receivedResp = payload;\n        this.matchReceive(payload);\n      });\n      this.timeoutTimer = setTimeout(() => {\n        this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n\n    hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n\n    trigger(status, response) {\n      this.channel.trigger(this.refEvent, {\n        status,\n        response\n      });\n    }\n\n  }; // js/phoenix/timer.js\n\n  var Timer = class {\n    constructor(callback, timerCalc) {\n      this.callback = callback;\n      this.timerCalc = timerCalc;\n      this.timer = null;\n      this.tries = 0;\n    }\n\n    reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    scheduleTimeout() {\n      clearTimeout(this.timer);\n      this.timer = setTimeout(() => {\n        this.tries = this.tries + 1;\n        this.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n\n  }; // js/phoenix/channel.js\n\n  var Channel = class {\n    constructor(topic, params, socket) {\n      this.state = CHANNEL_STATES.closed;\n      this.topic = topic;\n      this.params = closure(params || {});\n      this.socket = socket;\n      this.bindings = [];\n      this.bindingRef = 0;\n      this.timeout = this.socket.timeout;\n      this.joinedOnce = false;\n      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n      this.pushBuffer = [];\n      this.stateChangeRefs = [];\n      this.rejoinTimer = new Timer(() => {\n        if (this.socket.isConnected()) {\n          this.rejoin();\n        }\n      }, this.socket.rejoinAfterMs);\n      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n      this.stateChangeRefs.push(this.socket.onOpen(() => {\n        this.rejoinTimer.reset();\n\n        if (this.isErrored()) {\n          this.rejoin();\n        }\n      }));\n      this.joinPush.receive(\"ok\", () => {\n        this.state = CHANNEL_STATES.joined;\n        this.rejoinTimer.reset();\n        this.pushBuffer.forEach(pushEvent => pushEvent.send());\n        this.pushBuffer = [];\n      });\n      this.joinPush.receive(\"error\", () => {\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.onClose(() => {\n        this.rejoinTimer.reset();\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n        this.state = CHANNEL_STATES.closed;\n        this.socket.remove(this);\n      });\n      this.onError(reason => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason);\n\n        if (this.isJoining()) {\n          this.joinPush.reset();\n        }\n\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.joinPush.receive(\"timeout\", () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n        leavePush.send();\n        this.state = CHANNEL_STATES.errored;\n        this.joinPush.reset();\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n        this.trigger(this.replyEventName(ref), payload);\n      });\n    }\n\n    join(timeout = this.timeout) {\n      if (this.joinedOnce) {\n        throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n      } else {\n        this.timeout = timeout;\n        this.joinedOnce = true;\n        this.rejoin();\n        return this.joinPush;\n      }\n    }\n\n    onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n\n    onError(callback) {\n      return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n    }\n\n    on(event, callback) {\n      let ref = this.bindingRef++;\n      this.bindings.push({\n        event,\n        ref,\n        callback\n      });\n      return ref;\n    }\n\n    off(event, ref) {\n      this.bindings = this.bindings.filter(bind => {\n        return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n      });\n    }\n\n    canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n\n    push(event, payload, timeout = this.timeout) {\n      payload = payload || {};\n\n      if (!this.joinedOnce) {\n        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n      }\n\n      let pushEvent = new Push(this, event, function () {\n        return payload;\n      }, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    leave(timeout = this.timeout) {\n      this.rejoinTimer.reset();\n      this.joinPush.cancelTimeout();\n      this.state = CHANNEL_STATES.leaving;\n\n      let onClose = () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`);\n        this.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n      leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    onMessage(_event, payload, _ref) {\n      return payload;\n    }\n\n    isMember(topic, event, payload, joinRef) {\n      if (this.topic !== topic) {\n        return false;\n      }\n\n      if (joinRef && joinRef !== this.joinRef()) {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n          topic,\n          event,\n          payload,\n          joinRef\n        });\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    joinRef() {\n      return this.joinPush.ref;\n    }\n\n    rejoin(timeout = this.timeout) {\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n\n    trigger(event, payload, ref, joinRef) {\n      let handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n      if (payload && !handledPayload) {\n        throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n      }\n\n      let eventBindings = this.bindings.filter(bind => bind.event === event);\n\n      for (let i = 0; i < eventBindings.length; i++) {\n        let bind = eventBindings[i];\n        bind.callback(handledPayload, ref, joinRef || this.joinRef());\n      }\n    }\n\n    replyEventName(ref) {\n      return `chan_reply_${ref}`;\n    }\n\n    isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n\n    isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n\n    isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n\n    isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n\n    isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n\n  }; // js/phoenix/ajax.js\n\n  var Ajax = class {\n    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (global.XDomainRequest) {\n        let req = new global.XDomainRequest();\n        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        let req = new global.XMLHttpRequest();\n        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n\n    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      req.timeout = timeout;\n      req.open(method, endPoint);\n\n      req.onload = () => {\n        let response = this.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.onprogress = () => {};\n\n      req.send(body);\n      return req;\n    }\n\n    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader(\"Content-Type\", accept);\n\n      req.onerror = () => callback && callback(null);\n\n      req.onreadystatechange = () => {\n        if (req.readyState === XHR_STATES.complete && callback) {\n          let response = this.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n      return req;\n    }\n\n    static parseJSON(resp) {\n      if (!resp || resp === \"\") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log(\"failed to parse JSON response\", resp);\n        return null;\n      }\n    }\n\n    static serialize(obj, parentKey) {\n      let queryStr = [];\n\n      for (var key in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue;\n        }\n\n        let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n        let paramVal = obj[key];\n\n        if (typeof paramVal === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n\n      return queryStr.join(\"&\");\n    }\n\n    static appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return `${url}${prefix}${this.serialize(params)}`;\n    }\n\n  }; // js/phoenix/longpoll.js\n\n  var LongPoll = class {\n    constructor(endPoint) {\n      this.endPoint = null;\n      this.token = null;\n      this.skipHeartbeat = true;\n      this.reqs = /* @__PURE__ */new Set();\n\n      this.onopen = function () {};\n\n      this.onerror = function () {};\n\n      this.onmessage = function () {};\n\n      this.onclose = function () {};\n\n      this.pollEndpoint = this.normalizeEndpoint(endPoint);\n      this.readyState = SOCKET_STATES.connecting;\n      this.poll();\n    }\n\n    normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n\n    endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, {\n        token: this.token\n      });\n    }\n\n    closeAndRetry(code, reason, wasClean) {\n      this.close(code, reason, wasClean);\n      this.readyState = SOCKET_STATES.connecting;\n    }\n\n    ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry(1005, \"timeout\", false);\n    }\n\n    isActive() {\n      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;\n    }\n\n    poll() {\n      this.ajax(\"GET\", null, () => this.ontimeout(), resp => {\n        if (resp) {\n          var {\n            status,\n            token,\n            messages\n          } = resp;\n          this.token = token;\n        } else {\n          status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(msg => {\n              setTimeout(() => this.onmessage({\n                data: msg\n              }), 0);\n            });\n            this.poll();\n            break;\n\n          case 204:\n            this.poll();\n            break;\n\n          case 410:\n            this.readyState = SOCKET_STATES.open;\n            this.onopen({});\n            this.poll();\n            break;\n\n          case 403:\n            this.onerror(403);\n            this.close(1008, \"forbidden\", false);\n            break;\n\n          case 0:\n          case 500:\n            this.onerror(500);\n            this.closeAndRetry(1011, \"internal server error\", 500);\n            break;\n\n          default:\n            throw new Error(`unhandled poll status ${status}`);\n        }\n      });\n    }\n\n    send(body) {\n      this.ajax(\"POST\", body, () => this.onerror(\"timeout\"), resp => {\n        if (!resp || resp.status !== 200) {\n          this.onerror(resp && resp.status);\n          this.closeAndRetry(1011, \"internal server error\", false);\n        }\n      });\n    }\n\n    close(code, reason, wasClean) {\n      for (let req of this.reqs) {\n        req.abort();\n      }\n\n      this.readyState = SOCKET_STATES.closed;\n      let opts = Object.assign({\n        code: 1e3,\n        reason: void 0,\n        wasClean: true\n      }, {\n        code,\n        reason,\n        wasClean\n      });\n\n      if (typeof CloseEvent !== \"undefined\") {\n        this.onclose(new CloseEvent(\"close\", opts));\n      } else {\n        this.onclose(opts);\n      }\n    }\n\n    ajax(method, body, onCallerTimeout, callback) {\n      let req;\n\n      let ontimeout = () => {\n        this.reqs.delete(req);\n        onCallerTimeout();\n      };\n\n      req = Ajax.request(method, this.endpointURL(), \"application/json\", body, this.timeout, ontimeout, resp => {\n        this.reqs.delete(req);\n\n        if (this.isActive()) {\n          callback(resp);\n        }\n      });\n      this.reqs.add(req);\n    }\n\n  }; // js/phoenix/presence.js\n\n  var Presence = class {\n    constructor(channel, opts = {}) {\n      let events = opts.events || {\n        state: \"presence_state\",\n        diff: \"presence_diff\"\n      };\n      this.state = {};\n      this.pendingDiffs = [];\n      this.channel = channel;\n      this.joinRef = null;\n      this.caller = {\n        onJoin: function () {},\n        onLeave: function () {},\n        onSync: function () {}\n      };\n      this.channel.on(events.state, newState => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n        this.joinRef = this.channel.joinRef();\n        this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n        this.pendingDiffs.forEach(diff => {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        });\n        this.pendingDiffs = [];\n        onSync();\n      });\n      this.channel.on(events.diff, diff => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n\n        if (this.inPendingSyncState()) {\n          this.pendingDiffs.push(diff);\n        } else {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n          onSync();\n        }\n      });\n    }\n\n    onJoin(callback) {\n      this.caller.onJoin = callback;\n    }\n\n    onLeave(callback) {\n      this.caller.onLeave = callback;\n    }\n\n    onSync(callback) {\n      this.caller.onSync = callback;\n    }\n\n    list(by) {\n      return Presence.list(this.state, by);\n    }\n\n    inPendingSyncState() {\n      return !this.joinRef || this.joinRef !== this.channel.joinRef();\n    }\n\n    static syncState(currentState, newState, onJoin, onLeave) {\n      let state = this.clone(currentState);\n      let joins = {};\n      let leaves = {};\n      this.map(state, (key, presence) => {\n        if (!newState[key]) {\n          leaves[key] = presence;\n        }\n      });\n      this.map(newState, (key, newPresence) => {\n        let currentPresence = state[key];\n\n        if (currentPresence) {\n          let newRefs = newPresence.metas.map(m => m.phx_ref);\n          let curRefs = currentPresence.metas.map(m => m.phx_ref);\n          let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n          let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n\n          if (leftMetas.length > 0) {\n            leaves[key] = this.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        } else {\n          joins[key] = newPresence;\n        }\n      });\n      return this.syncDiff(state, {\n        joins,\n        leaves\n      }, onJoin, onLeave);\n    }\n\n    static syncDiff(state, diff, onJoin, onLeave) {\n      let {\n        joins,\n        leaves\n      } = this.clone(diff);\n\n      if (!onJoin) {\n        onJoin = function () {};\n      }\n\n      if (!onLeave) {\n        onLeave = function () {};\n      }\n\n      this.map(joins, (key, newPresence) => {\n        let currentPresence = state[key];\n        state[key] = this.clone(newPresence);\n\n        if (currentPresence) {\n          let joinedRefs = state[key].metas.map(m => m.phx_ref);\n          let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n          state[key].metas.unshift(...curMetas);\n        }\n\n        onJoin(key, currentPresence, newPresence);\n      });\n      this.map(leaves, (key, leftPresence) => {\n        let currentPresence = state[key];\n\n        if (!currentPresence) {\n          return;\n        }\n\n        let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n        currentPresence.metas = currentPresence.metas.filter(p => {\n          return refsToRemove.indexOf(p.phx_ref) < 0;\n        });\n        onLeave(key, currentPresence, leftPresence);\n\n        if (currentPresence.metas.length === 0) {\n          delete state[key];\n        }\n      });\n      return state;\n    }\n\n    static list(presences, chooser) {\n      if (!chooser) {\n        chooser = function (key, pres) {\n          return pres;\n        };\n      }\n\n      return this.map(presences, (key, presence) => {\n        return chooser(key, presence);\n      });\n    }\n\n    static map(obj, func) {\n      return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n    }\n\n    static clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n\n  }; // js/phoenix/serializer.js\n\n  var serializer_default = {\n    HEADER_LENGTH: 1,\n    META_LENGTH: 4,\n    KINDS: {\n      push: 0,\n      reply: 1,\n      broadcast: 2\n    },\n\n    encode(msg, callback) {\n      if (msg.payload.constructor === ArrayBuffer) {\n        return callback(this.binaryEncode(msg));\n      } else {\n        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n        return callback(JSON.stringify(payload));\n      }\n    },\n\n    decode(rawPayload, callback) {\n      if (rawPayload.constructor === ArrayBuffer) {\n        return callback(this.binaryDecode(rawPayload));\n      } else {\n        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n        return callback({\n          join_ref,\n          ref,\n          topic,\n          event,\n          payload\n        });\n      }\n    },\n\n    binaryEncode(message) {\n      let {\n        join_ref,\n        ref,\n        event,\n        topic,\n        payload\n      } = message;\n      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n      let view = new DataView(header);\n      let offset = 0;\n      view.setUint8(offset++, this.KINDS.push);\n      view.setUint8(offset++, join_ref.length);\n      view.setUint8(offset++, ref.length);\n      view.setUint8(offset++, topic.length);\n      view.setUint8(offset++, event.length);\n      Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)));\n      var combined = new Uint8Array(header.byteLength + payload.byteLength);\n      combined.set(new Uint8Array(header), 0);\n      combined.set(new Uint8Array(payload), header.byteLength);\n      return combined.buffer;\n    },\n\n    binaryDecode(buffer) {\n      let view = new DataView(buffer);\n      let kind = view.getUint8(0);\n      let decoder = new TextDecoder();\n\n      switch (kind) {\n        case this.KINDS.push:\n          return this.decodePush(buffer, view, decoder);\n\n        case this.KINDS.reply:\n          return this.decodeReply(buffer, view, decoder);\n\n        case this.KINDS.broadcast:\n          return this.decodeBroadcast(buffer, view, decoder);\n      }\n    },\n\n    decodePush(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let topicSize = view.getUint8(2);\n      let eventSize = view.getUint8(3);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: joinRef,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    },\n\n    decodeReply(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let refSize = view.getUint8(2);\n      let topicSize = view.getUint8(3);\n      let eventSize = view.getUint8(4);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n      offset = offset + refSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      let payload = {\n        status: event,\n        response: data\n      };\n      return {\n        join_ref: joinRef,\n        ref,\n        topic,\n        event: CHANNEL_EVENTS.reply,\n        payload\n      };\n    },\n\n    decodeBroadcast(buffer, view, decoder) {\n      let topicSize = view.getUint8(1);\n      let eventSize = view.getUint8(2);\n      let offset = this.HEADER_LENGTH + 2;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: null,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    }\n\n  }; // js/phoenix/socket.js\n\n  var Socket = class {\n    constructor(endPoint, opts = {}) {\n      this.stateChangeCallbacks = {\n        open: [],\n        close: [],\n        error: [],\n        message: []\n      };\n      this.channels = [];\n      this.sendBuffer = [];\n      this.ref = 0;\n      this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n      this.transport = opts.transport || global.WebSocket || LongPoll;\n      this.establishedConnections = 0;\n      this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n      this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n      this.closeWasClean = false;\n      this.binaryType = opts.binaryType || \"arraybuffer\";\n      this.connectClock = 1;\n\n      if (this.transport !== LongPoll) {\n        this.encode = opts.encode || this.defaultEncoder;\n        this.decode = opts.decode || this.defaultDecoder;\n      } else {\n        this.encode = this.defaultEncoder;\n        this.decode = this.defaultDecoder;\n      }\n\n      let awaitingConnectionOnPageShow = null;\n\n      if (phxWindow && phxWindow.addEventListener) {\n        phxWindow.addEventListener(\"pagehide\", _e => {\n          if (this.conn) {\n            this.disconnect();\n            awaitingConnectionOnPageShow = this.connectClock;\n          }\n        });\n        phxWindow.addEventListener(\"pageshow\", _e => {\n          if (awaitingConnectionOnPageShow === this.connectClock) {\n            awaitingConnectionOnPageShow = null;\n            this.connect();\n          }\n        });\n      }\n\n      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n\n      this.rejoinAfterMs = tries => {\n        if (opts.rejoinAfterMs) {\n          return opts.rejoinAfterMs(tries);\n        } else {\n          return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n        }\n      };\n\n      this.reconnectAfterMs = tries => {\n        if (opts.reconnectAfterMs) {\n          return opts.reconnectAfterMs(tries);\n        } else {\n          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n        }\n      };\n\n      this.logger = opts.logger || null;\n      this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n      this.params = closure(opts.params || {});\n      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n      this.vsn = opts.vsn || DEFAULT_VSN;\n      this.heartbeatTimer = null;\n      this.pendingHeartbeatRef = null;\n      this.reconnectTimer = new Timer(() => {\n        this.teardown(() => this.connect());\n      }, this.reconnectAfterMs);\n    }\n\n    getLongPollTransport() {\n      return LongPoll;\n    }\n\n    replaceTransport(newTransport) {\n      this.connectClock++;\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.sendBuffer = [];\n\n      if (this.conn) {\n        this.conn.close();\n        this.conn = null;\n      }\n\n      this.transport = newTransport;\n    }\n\n    protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n\n    endPointURL() {\n      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n        vsn: this.vsn\n      });\n\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n\n      if (uri.charAt(1) === \"/\") {\n        return `${this.protocol()}:${uri}`;\n      }\n\n      return `${this.protocol()}://${location.host}${uri}`;\n    }\n\n    disconnect(callback, code, reason) {\n      this.connectClock++;\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.teardown(callback, code, reason);\n    }\n\n    connect(params) {\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = closure(params);\n      }\n\n      if (this.conn) {\n        return;\n      }\n\n      this.connectClock++;\n      this.closeWasClean = false;\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.binaryType = this.binaryType;\n      this.conn.timeout = this.longpollerTimeout;\n\n      this.conn.onopen = () => this.onConnOpen();\n\n      this.conn.onerror = error => this.onConnError(error);\n\n      this.conn.onmessage = event => this.onConnMessage(event);\n\n      this.conn.onclose = event => this.onConnClose(event);\n    }\n\n    log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    hasLogger() {\n      return this.logger !== null;\n    }\n\n    onOpen(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.open.push([ref, callback]);\n      return ref;\n    }\n\n    onClose(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.close.push([ref, callback]);\n      return ref;\n    }\n\n    onError(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.error.push([ref, callback]);\n      return ref;\n    }\n\n    onMessage(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.message.push([ref, callback]);\n      return ref;\n    }\n\n    ping(callback) {\n      if (!this.isConnected()) {\n        return false;\n      }\n\n      let ref = this.makeRef();\n      let startTime = Date.now();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref\n      });\n      let onMsgRef = this.onMessage(msg => {\n        if (msg.ref === ref) {\n          this.off([onMsgRef]);\n          callback(Date.now() - startTime);\n        }\n      });\n      return true;\n    }\n\n    onConnOpen() {\n      if (this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`);\n      this.closeWasClean = false;\n      this.establishedConnections++;\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.resetHeartbeat();\n      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n    }\n\n    heartbeatTimeout() {\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n\n        if (this.hasLogger()) {\n          this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        }\n\n        this.abnormalClose(\"heartbeat timeout\");\n      }\n    }\n\n    resetHeartbeat() {\n      if (this.conn && this.conn.skipHeartbeat) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = null;\n      clearTimeout(this.heartbeatTimer);\n      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n\n    teardown(callback, code, reason) {\n      if (!this.conn) {\n        return callback && callback();\n      }\n\n      this.waitForBufferDone(() => {\n        if (this.conn) {\n          if (code) {\n            this.conn.close(code, reason || \"\");\n          } else {\n            this.conn.close();\n          }\n        }\n\n        this.waitForSocketClosed(() => {\n          if (this.conn) {\n            this.conn.onclose = function () {};\n\n            this.conn = null;\n          }\n\n          callback && callback();\n        });\n      });\n    }\n\n    waitForBufferDone(callback, tries = 1) {\n      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForBufferDone(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    waitForSocketClosed(callback, tries = 1) {\n      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForSocketClosed(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    onConnClose(event) {\n      let closeCode = event && event.code;\n      if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearTimeout(this.heartbeatTimer);\n\n      if (!this.closeWasClean && closeCode !== 1e3) {\n        this.reconnectTimer.scheduleTimeout();\n      }\n\n      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n    }\n\n    onConnError(error) {\n      if (this.hasLogger()) this.log(\"transport\", error);\n      let transportBefore = this.transport;\n      let establishedBefore = this.establishedConnections;\n      this.stateChangeCallbacks.error.forEach(([, callback]) => {\n        callback(error, transportBefore, establishedBefore);\n      });\n\n      if (transportBefore === this.transport || establishedBefore > 0) {\n        this.triggerChanError();\n      }\n    }\n\n    triggerChanError() {\n      this.channels.forEach(channel => {\n        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n          channel.trigger(CHANNEL_EVENTS.error);\n        }\n      });\n    }\n\n    connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n\n        case SOCKET_STATES.open:\n          return \"open\";\n\n        case SOCKET_STATES.closing:\n          return \"closing\";\n\n        default:\n          return \"closed\";\n      }\n    }\n\n    isConnected() {\n      return this.connectionState() === \"open\";\n    }\n\n    remove(channel) {\n      this.off(channel.stateChangeRefs);\n      this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n    }\n\n    off(refs) {\n      for (let key in this.stateChangeCallbacks) {\n        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n          return refs.indexOf(ref) === -1;\n        });\n      }\n    }\n\n    channel(topic, chanParams = {}) {\n      let chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n\n    push(data) {\n      if (this.hasLogger()) {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = data;\n        this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n      }\n\n      if (this.isConnected()) {\n        this.encode(data, result => this.conn.send(result));\n      } else {\n        this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)));\n      }\n    }\n\n    makeRef() {\n      let newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n\n    sendHeartbeat() {\n      if (this.pendingHeartbeatRef && !this.isConnected()) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n    }\n\n    abnormalClose(reason) {\n      this.closeWasClean = false;\n\n      if (this.isConnected()) {\n        this.conn.close(WS_CLOSE_NORMAL, reason);\n      }\n    }\n\n    flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(callback => callback());\n        this.sendBuffer = [];\n      }\n    }\n\n    onConnMessage(rawMessage) {\n      this.decode(rawMessage.data, msg => {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = msg;\n\n        if (ref && ref === this.pendingHeartbeatRef) {\n          clearTimeout(this.heartbeatTimer);\n          this.pendingHeartbeatRef = null;\n          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n\n        if (this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n\n        for (let i = 0; i < this.channels.length; i++) {\n          const channel = this.channels[i];\n\n          if (!channel.isMember(topic, event, payload, join_ref)) {\n            continue;\n          }\n\n          channel.trigger(event, payload, ref, join_ref);\n        }\n\n        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n          let [, callback] = this.stateChangeCallbacks.message[i];\n          callback(msg);\n        }\n      });\n    }\n\n    leaveOpenTopic(topic) {\n      let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n\n      if (dupChannel) {\n        if (this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n        dupChannel.leave();\n      }\n    }\n\n  };\n  return __toCommonJS(phoenix_exports);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanM/MzFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGhvZW5peCA9ICgoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gIH07XG4gIHZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gICAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9O1xuICB2YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuICAvLyBqcy9waG9lbml4L2luZGV4LmpzXG4gIHZhciBwaG9lbml4X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9leHBvcnRzLCB7XG4gICAgQ2hhbm5lbDogKCkgPT4gQ2hhbm5lbCxcbiAgICBMb25nUG9sbDogKCkgPT4gTG9uZ1BvbGwsXG4gICAgUHJlc2VuY2U6ICgpID0+IFByZXNlbmNlLFxuICAgIFNlcmlhbGl6ZXI6ICgpID0+IHNlcmlhbGl6ZXJfZGVmYXVsdCxcbiAgICBTb2NrZXQ6ICgpID0+IFNvY2tldFxuICB9KTtcblxuICAvLyBqcy9waG9lbml4L3V0aWxzLmpzXG4gIHZhciBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9zdXJlMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNsb3N1cmUyO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NvbnN0YW50cy5qc1xuICB2YXIgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGw7XG4gIHZhciBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbDtcbiAgdmFyIGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IGdsb2JhbDtcbiAgdmFyIERFRkFVTFRfVlNOID0gXCIyLjAuMFwiO1xuICB2YXIgU09DS0VUX1NUQVRFUyA9IHsgY29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzIH07XG4gIHZhciBERUZBVUxUX1RJTUVPVVQgPSAxZTQ7XG4gIHZhciBXU19DTE9TRV9OT1JNQUwgPSAxZTM7XG4gIHZhciBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gICAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gICAgam9pbmVkOiBcImpvaW5lZFwiLFxuICAgIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICAgIGxlYXZpbmc6IFwibGVhdmluZ1wiXG4gIH07XG4gIHZhciBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgICBqb2luOiBcInBoeF9qb2luXCIsXG4gICAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gICAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbiAgfTtcbiAgdmFyIFRSQU5TUE9SVFMgPSB7XG4gICAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbiAgfTtcbiAgdmFyIFhIUl9TVEFURVMgPSB7XG4gICAgY29tcGxldGU6IDRcbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3B1c2guanNcbiAgdmFyIFB1c2ggPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMucmVjSG9va3MgPSBbXTtcbiAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICB0aGlzLnNlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGw7XG4gICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgX3JlZiB9KSB7XG4gICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBjYW5jZWxSZWZFdmVudCgpIHtcbiAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpO1xuICAgIH1cbiAgICBjYW5jZWxUaW1lb3V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKTtcbiAgICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pO1xuICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3RpbWVyLmpzXG4gIHZhciBUaW1lciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NoYW5uZWwuanNcbiAgdmFyIENoYW5uZWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSk7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuYmluZGluZ1JlZiA9IDA7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW107XG4gICAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pbigpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5pc0Vycm9yZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkVycm9yKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pO1xuICAgICAgICBpZiAodGhpcy5pc0pvaW5pbmcoKSkge1xuICAgICAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGlmICh0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWpvaW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2g7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrKztcbiAgICAgIHRoaXMuYmluZGluZ3MucHVzaCh7IGV2ZW50LCByZWYsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCByZWYpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FuUHVzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKTtcbiAgICB9XG4gICAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKTtcbiAgICAgIH1cbiAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoKCkpIHtcbiAgICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpO1xuICAgICAgfTtcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpO1xuICAgICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSk7XG4gICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhblB1c2goKSkge1xuICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWF2ZVB1c2g7XG4gICAgfVxuICAgIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpIHtcbiAgICAgIGlmICh0aGlzLnRvcGljICE9PSB0b3BpYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBqb2luUmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmO1xuICAgIH1cbiAgICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgaWYgKHRoaXMuaXNMZWF2aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYyk7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpIHtcbiAgICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpO1xuICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV07XG4gICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWA7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICB9XG4gICAgaXNFcnJvcmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgfVxuICAgIGlzSm9pbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgaXNKb2luaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgfVxuICAgIGlzTGVhdmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2FqYXguanNcbiAgdmFyIEFqYXggPSBjbGFzcyB7XG4gICAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaykge1xuICAgICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCk7XG4gICAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgfTtcbiAgICAgIGlmIChvbnRpbWVvdXQpIHtcbiAgICAgICAgcmVxLm9udGltZW91dCA9IG9udGltZW91dDtcbiAgICAgIH1cbiAgICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4ge1xuICAgICAgfTtcbiAgICAgIHJlcS5zZW5kKGJvZHkpO1xuICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQsIHRydWUpO1xuICAgICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KTtcbiAgICAgIHJlcS5vbmVycm9yID0gKCkgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCk7XG4gICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob250aW1lb3V0KSB7XG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXEuc2VuZChib2R5KTtcbiAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUpTT04ocmVzcCkge1xuICAgICAgaWYgKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsIHJlc3ApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSkge1xuICAgICAgbGV0IHF1ZXJ5U3RyID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXk7XG4gICAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIik7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgbGV0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiO1xuICAgICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3RoaXMuc2VyaWFsaXplKHBhcmFtcyl9YDtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peC9sb25ncG9sbC5qc1xuICB2YXIgTG9uZ1BvbGwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZW5kUG9pbnQpIHtcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBudWxsO1xuICAgICAgdGhpcy50b2tlbiA9IG51bGw7XG4gICAgICB0aGlzLnNraXBIZWFydGJlYXQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXFzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KSB7XG4gICAgICByZXR1cm4gZW5kUG9pbnQucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKS5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIikucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKS9cIiArIFRSQU5TUE9SVFMud2Vic29ja2V0KSwgXCIkMS9cIiArIFRSQU5TUE9SVFMubG9uZ3BvbGwpO1xuICAgIH1cbiAgICBlbmRwb2ludFVSTCgpIHtcbiAgICAgIHJldHVybiBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLnBvbGxFbmRwb2ludCwgeyB0b2tlbjogdGhpcy50b2tlbiB9KTtcbiAgICB9XG4gICAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgIH1cbiAgICBvbnRpbWVvdXQoKSB7XG4gICAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpO1xuICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSk7XG4gICAgfVxuICAgIGlzQWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgdGhpcy5hamF4KFwiR0VUXCIsIG51bGwsICgpID0+IHRoaXMub250aW1lb3V0KCksIChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwKSB7XG4gICAgICAgICAgdmFyIHsgc3RhdHVzLCB0b2tlbiwgbWVzc2FnZXMgfSA9IHJlc3A7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG1zZykgPT4ge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25tZXNzYWdlKHsgZGF0YTogbXNnIH0pLCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLm9wZW47XG4gICAgICAgICAgICB0aGlzLm9ub3Blbih7fSk7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgdGhpcy5vbmVycm9yKDQwMyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKDEwMDgsIFwiZm9yYmlkZGVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgIHRoaXMub25lcnJvcig1MDApO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIDUwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKGJvZHkpIHtcbiAgICAgIHRoaXMuYWpheChcIlBPU1RcIiwgYm9keSwgKCkgPT4gdGhpcy5vbmVycm9yKFwidGltZW91dFwiKSwgKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKCFyZXNwIHx8IHJlc3Auc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cyk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgICAgIGZvciAobGV0IHJlcSBvZiB0aGlzLnJlcXMpIHtcbiAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZDtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IGNvZGU6IDFlMywgcmVhc29uOiB2b2lkIDAsIHdhc0NsZWFuOiB0cnVlIH0sIHsgY29kZSwgcmVhc29uLCB3YXNDbGVhbiB9KTtcbiAgICAgIGlmICh0eXBlb2YgQ2xvc2VFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLm9uY2xvc2UobmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCBvcHRzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uY2xvc2Uob3B0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGFqYXgobWV0aG9kLCBib2R5LCBvbkNhbGxlclRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgcmVxO1xuICAgICAgbGV0IG9udGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpO1xuICAgICAgICBvbkNhbGxlclRpbWVvdXQoKTtcbiAgICAgIH07XG4gICAgICByZXEgPSBBamF4LnJlcXVlc3QobWV0aG9kLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBib2R5LCB0aGlzLnRpbWVvdXQsIG9udGltZW91dCwgKHJlc3ApID0+IHtcbiAgICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXFzLmFkZChyZXEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIHZhciBQcmVzZW5jZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7IHN0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwiIH07XG4gICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgICAgb25Kb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCAobmV3U3RhdGUpID0+IHtcbiAgICAgICAgbGV0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKChkaWZmKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICBvblN5bmMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCAoZGlmZikgPT4ge1xuICAgICAgICBsZXQgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgbGlzdChieSkge1xuICAgICAgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpO1xuICAgIH1cbiAgICBpblBlbmRpbmdTeW5jU3RhdGUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCk7XG4gICAgfVxuICAgIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSk7XG4gICAgICBsZXQgam9pbnMgPSB7fTtcbiAgICAgIGxldCBsZWF2ZXMgPSB7fTtcbiAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICBpZiAoIW5ld1N0YXRlW2tleV0pIHtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKChtKSA9PiBtLnBoeF9yZWYpO1xuICAgICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgaWYgKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZTtcbiAgICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlZnRNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKTtcbiAgICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgbGV0IHsgam9pbnMsIGxlYXZlcyB9ID0gdGhpcy5jbG9uZShkaWZmKTtcbiAgICAgIGlmICghb25Kb2luKSB7XG4gICAgICAgIG9uSm9pbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICAgIG9uTGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpO1xuICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlKSB7XG4gICAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKChtKSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApO1xuICAgICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcyk7XG4gICAgICAgIH1cbiAgICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSk7XG4gICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpIHtcbiAgICAgIGlmICghY2hvb3Nlcikge1xuICAgICAgICBjaG9vc2VyID0gZnVuY3Rpb24oa2V5LCBwcmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXM7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peC9zZXJpYWxpemVyLmpzXG4gIHZhciBzZXJpYWxpemVyX2RlZmF1bHQgPSB7XG4gICAgSEVBREVSX0xFTkdUSDogMSxcbiAgICBNRVRBX0xFTkdUSDogNCxcbiAgICBLSU5EUzogeyBwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyIH0sXG4gICAgZW5jb2RlKG1zZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh7IGpvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmFyeUVuY29kZShtZXNzYWdlKSB7XG4gICAgICBsZXQgeyBqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoO1xuICAgICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKTtcbiAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcik7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKTtcbiAgICAgIEFycmF5LmZyb20oam9pbl9yZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgIEFycmF5LmZyb20ocmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKHRvcGljLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKGV2ZW50LCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiBjb21iaW5lZC5idWZmZXI7XG4gICAgfSxcbiAgICBiaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSk7XG4gICAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxO1xuICAgICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4geyBqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYywgZXZlbnQsIHBheWxvYWQ6IGRhdGEgfTtcbiAgICB9LFxuICAgIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSDtcbiAgICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplO1xuICAgICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBsZXQgcGF5bG9hZCA9IHsgc3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGEgfTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBqb2luUmVmLCByZWYsIHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQgfTtcbiAgICB9LFxuICAgIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMik7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljLCBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3NvY2tldC5qc1xuICB2YXIgU29ja2V0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pIHtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7IG9wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW10gfTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVDtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbDtcbiAgICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDA7XG4gICAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmVuY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmRlY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZSB8fCBcImFycmF5YnVmZmVyXCI7XG4gICAgICB0aGlzLmNvbm5lY3RDbG9jayA9IDE7XG4gICAgICBpZiAodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlcjtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyO1xuICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXI7XG4gICAgICB9XG4gICAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGw7XG4gICAgICBpZiAocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCAoX2UpID0+IHtcbiAgICAgICAgICBpZiAoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spIHtcbiAgICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzZTQ7XG4gICAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVqb2luQWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMWUzLCAyZTMsIDVlM11bdHJpZXMgLSAxXSB8fCAxZTQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVjb25uZWN0QWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMWUzLCAyZTNdW3RyaWVzIC0gMV0gfHwgNWUzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsO1xuICAgICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMmU0O1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KTtcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgdGhpcy52c24gPSBvcHRzLnZzbiB8fCBERUZBVUxUX1ZTTjtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKTtcbiAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgfVxuICAgIGdldExvbmdQb2xsVHJhbnNwb3J0KCkge1xuICAgICAgcmV0dXJuIExvbmdQb2xsO1xuICAgIH1cbiAgICByZXBsYWNlVHJhbnNwb3J0KG5ld1RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWU7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ld1RyYW5zcG9ydDtcbiAgICB9XG4gICAgcHJvdG9jb2woKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIjtcbiAgICB9XG4gICAgZW5kUG9pbnRVUkwoKSB7XG4gICAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoQWpheC5hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgdGhpcy5wYXJhbXMoKSksIHsgdnNuOiB0aGlzLnZzbiB9KTtcbiAgICAgIGlmICh1cmkuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgfVxuICAgICAgaWYgKHVyaS5jaGFyQXQoMSkgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfTovLyR7bG9jYXRpb24uaG9zdH0ke3VyaX1gO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KGNhbGxiYWNrLCBjb2RlLCByZWFzb24pIHtcbiAgICAgIHRoaXMuY29ubmVjdENsb2NrKys7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpO1xuICAgICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKTtcbiAgICB9XG4gICAgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdENsb2NrKys7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCkpO1xuICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGU7XG4gICAgICB0aGlzLmNvbm4udGltZW91dCA9IHRoaXMubG9uZ3BvbGxlclRpbWVvdXQ7XG4gICAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5vbkNvbm5PcGVuKCk7XG4gICAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcikgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLm9uQ29ubk1lc3NhZ2UoZXZlbnQpO1xuICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSAoZXZlbnQpID0+IHRoaXMub25Db25uQ2xvc2UoZXZlbnQpO1xuICAgIH1cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpO1xuICAgIH1cbiAgICBoYXNMb2dnZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGw7XG4gICAgfVxuICAgIG9uT3BlbihjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBwaW5nKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMucHVzaCh7IHRvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWYgfSk7XG4gICAgICBsZXQgb25Nc2dSZWYgPSB0aGlzLm9uTWVzc2FnZSgobXNnKSA9PiB7XG4gICAgICAgIGlmIChtc2cucmVmID09PSByZWYpIHtcbiAgICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKTtcbiAgICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb25Db25uT3BlbigpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRQb2ludFVSTCgpfWApO1xuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2U7XG4gICAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMrKztcbiAgICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLnJlc2V0SGVhcnRiZWF0KCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9XG4gICAgaGVhcnRiZWF0VGltZW91dCgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImhlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJub3JtYWxDbG9zZShcImhlYXJ0YmVhdCB0aW1lb3V0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNldEhlYXJ0YmVhdCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgfVxuICAgIHRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pIHtcbiAgICAgIGlmICghdGhpcy5jb25uKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiB8fCBcIlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB3YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgPSAxKSB7XG4gICAgICBpZiAodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyArIDEpO1xuICAgICAgfSwgMTUwICogdHJpZXMpO1xuICAgIH1cbiAgICB3YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyA9IDEpIHtcbiAgICAgIGlmICh0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyArIDEpO1xuICAgICAgfSwgMTUwICogdHJpZXMpO1xuICAgIH1cbiAgICBvbkNvbm5DbG9zZShldmVudCkge1xuICAgICAgbGV0IGNsb3NlQ29kZSA9IGV2ZW50ICYmIGV2ZW50LmNvZGU7XG4gICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSlcbiAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudCk7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgIGlmICghdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMWUzKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgICB9XG4gICAgb25Db25uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcik7XG4gICAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnQ7XG4gICAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnM7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdHJhbnNwb3J0QmVmb3JlLCBlc3RhYmxpc2hlZEJlZm9yZSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlckNoYW5FcnJvcigpIHtcbiAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICBpZiAoIShjaGFubmVsLmlzRXJyb3JlZCgpIHx8IGNoYW5uZWwuaXNMZWF2aW5nKCkgfHwgY2hhbm5lbC5pc0Nsb3NlZCgpKSkge1xuICAgICAgICAgIGNoYW5uZWwudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICByZXR1cm4gXCJjb25uZWN0aW5nXCI7XG4gICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICAgIHJldHVybiBcIm9wZW5cIjtcbiAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6XG4gICAgICAgICAgcmV0dXJuIFwiY2xvc2luZ1wiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIjtcbiAgICB9XG4gICAgcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMub2ZmKGNoYW5uZWwuc3RhdGVDaGFuZ2VSZWZzKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcigoYykgPT4gYy5qb2luUmVmKCkgIT09IGNoYW5uZWwuam9pblJlZigpKTtcbiAgICB9XG4gICAgb2ZmKHJlZnMpIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSkge1xuICAgICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcyk7XG4gICAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbik7XG4gICAgICByZXR1cm4gY2hhbjtcbiAgICB9XG4gICAgcHVzaChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSkge1xuICAgICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYgfSA9IGRhdGE7XG4gICAgICAgIHRoaXMubG9nKFwicHVzaFwiLCBgJHt0b3BpY30gJHtldmVudH0gKCR7am9pbl9yZWZ9LCAke3JlZn0pYCwgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQpID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYWtlUmVmKCkge1xuICAgICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMTtcbiAgICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVmID0gbmV3UmVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICB0aGlzLnB1c2goeyB0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgfSk7XG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhlYXJ0YmVhdFRpbWVvdXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgICB9XG4gICAgYWJub3JtYWxDbG9zZShyZWFzb24pIHtcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCByZWFzb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaFNlbmRCdWZmZXIoKSB7XG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2UpIHtcbiAgICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZykgPT4ge1xuICAgICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYgfSA9IG1zZztcbiAgICAgICAgaWYgKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5sb2coXCJyZWNlaXZlXCIsIGAke3BheWxvYWQuc3RhdHVzIHx8IFwiXCJ9ICR7dG9waWN9ICR7ZXZlbnR9ICR7cmVmICYmIFwiKFwiICsgcmVmICsgXCIpXCIgfHwgXCJcIn1gLCBwYXlsb2FkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgICAgICAgaWYgKCFjaGFubmVsLmlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pbl9yZWYpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbm5lbC50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBbLCBjYWxsYmFja10gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2VbaV07XG4gICAgICAgICAgY2FsbGJhY2sobXNnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlT3BlblRvcGljKHRvcGljKSB7XG4gICAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZCgoYykgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuaXNKb2luZWQoKSB8fCBjLmlzSm9pbmluZygpKSk7XG4gICAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYCk7XG4gICAgICAgIGR1cENoYW5uZWwubGVhdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBfX3RvQ29tbW9uSlMocGhvZW5peF9leHBvcnRzKTtcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQWpGQTtBQUNBO0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUEzTEE7QUFDQTtBQTZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBNUVBO0FBQ0E7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBekJBO0FBMkJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExR0E7QUFDQTtBQTRHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBTEE7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFwSUE7QUFDQTtBQXNJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFoR0E7QUFDQTtBQWtHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWpXQTtBQWtXQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../deps/phoenix/priv/static/phoenix.js\n");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;else if (targetModifierKey) form.target = \"_blank\";\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n    if (e.defaultPrevented) return;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcz80N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50LCB0YXJnZXRNb2RpZmllcktleSkge1xuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcbiAgICAgICAgbWV0aG9kID0gYnVpbGRIaWRkZW5JbnB1dChcIl9tZXRob2RcIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSksXG4gICAgICAgIGNzcmYgPSBidWlsZEhpZGRlbklucHV0KFwiX2NzcmZfdG9rZW5cIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzcmZcIikpLFxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuXG4gICAgaWYgKHRhcmdldCkgZm9ybS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWxzZSBpZiAodGFyZ2V0TW9kaWZpZXJLZXkpIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcbiAgICAgICAgXCJidWJibGVzXCI6IHRydWUsIFwiY2FuY2VsYWJsZVwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQocGhvZW5peExpbmtFdmVudCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSB7XG4gICAgICAgIGhhbmRsZUNsaWNrKGVsZW1lbnQsIGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaG9lbml4LmxpbmsuY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xuICAgIGlmKG1lc3NhZ2UgJiYgIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../deps/phoenix_html/priv/static/phoenix_html.js\n");

/***/ }),

/***/ "../deps/phoenix_live_view/priv/static/phoenix_live_view.js":
/*!******************************************************************!*\
  !*** ../deps/phoenix_live_view/priv/static/phoenix_live_view.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var LiveView = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }; // js/phoenix_live_view/index.js\n\n\n  var phoenix_live_view_exports = {};\n\n  __export(phoenix_live_view_exports, {\n    LiveSocket: () => LiveSocket\n  }); // js/phoenix_live_view/constants.js\n\n\n  var CONSECUTIVE_RELOADS = \"consecutive-reloads\";\n  var MAX_RELOADS = 10;\n  var RELOAD_JITTER_MIN = 5e3;\n  var RELOAD_JITTER_MAX = 1e4;\n  var FAILSAFE_JITTER = 3e4;\n  var PHX_EVENT_CLASSES = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"];\n  var PHX_COMPONENT = \"data-phx-component\";\n  var PHX_LIVE_LINK = \"data-phx-link\";\n  var PHX_TRACK_STATIC = \"track-static\";\n  var PHX_LINK_STATE = \"data-phx-link-state\";\n  var PHX_REF = \"data-phx-ref\";\n  var PHX_REF_SRC = \"data-phx-ref-src\";\n  var PHX_TRACK_UPLOADS = \"track-uploads\";\n  var PHX_UPLOAD_REF = \"data-phx-upload-ref\";\n  var PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\n  var PHX_DONE_REFS = \"data-phx-done-refs\";\n  var PHX_DROP_TARGET = \"drop-target\";\n  var PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\n  var PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\n  var PHX_SKIP = \"data-phx-skip\";\n  var PHX_PRUNE = \"data-phx-prune\";\n  var PHX_PAGE_LOADING = \"page-loading\";\n  var PHX_CONNECTED_CLASS = \"phx-connected\";\n  var PHX_DISCONNECTED_CLASS = \"phx-loading\";\n  var PHX_NO_FEEDBACK_CLASS = \"phx-no-feedback\";\n  var PHX_ERROR_CLASS = \"phx-error\";\n  var PHX_PARENT_ID = \"data-phx-parent-id\";\n  var PHX_MAIN = \"data-phx-main\";\n  var PHX_ROOT_ID = \"data-phx-root-id\";\n  var PHX_TRIGGER_ACTION = \"trigger-action\";\n  var PHX_FEEDBACK_FOR = \"feedback-for\";\n  var PHX_HAS_FOCUSED = \"phx-has-focused\";\n  var FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\", \"datetime-local\", \"color\", \"range\"];\n  var CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\n  var PHX_HAS_SUBMITTED = \"phx-has-submitted\";\n  var PHX_SESSION = \"data-phx-session\";\n  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\n  var PHX_STICKY = \"data-phx-sticky\";\n  var PHX_STATIC = \"data-phx-static\";\n  var PHX_READONLY = \"data-phx-readonly\";\n  var PHX_DISABLED = \"data-phx-disabled\";\n  var PHX_DISABLE_WITH = \"disable-with\";\n  var PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\n  var PHX_HOOK = \"hook\";\n  var PHX_DEBOUNCE = \"debounce\";\n  var PHX_THROTTLE = \"throttle\";\n  var PHX_UPDATE = \"update\";\n  var PHX_KEY = \"key\";\n  var PHX_PRIVATE = \"phxPrivate\";\n  var PHX_AUTO_RECOVER = \"auto-recover\";\n  var PHX_LV_DEBUG = \"phx:live-socket:debug\";\n  var PHX_LV_PROFILE = \"phx:live-socket:profiling\";\n  var PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\n  var PHX_PROGRESS = \"progress\";\n  var LOADER_TIMEOUT = 1;\n  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\n  var BINDING_PREFIX = \"phx-\";\n  var PUSH_TIMEOUT = 3e4;\n  var DEBOUNCE_TRIGGER = \"debounce-trigger\";\n  var THROTTLED = \"throttled\";\n  var DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\n  var DEFAULTS = {\n    debounce: 300,\n    throttle: 300\n  };\n  var DYNAMICS = \"d\";\n  var STATIC = \"s\";\n  var COMPONENTS = \"c\";\n  var EVENTS = \"e\";\n  var REPLY = \"r\";\n  var TITLE = \"t\";\n  var TEMPLATES = \"p\"; // js/phoenix_live_view/entry_uploader.js\n\n  var EntryUploader = class {\n    constructor(entry, chunkSize, liveSocket) {\n      this.liveSocket = liveSocket;\n      this.entry = entry;\n      this.offset = 0;\n      this.chunkSize = chunkSize;\n      this.chunkTimer = null;\n      this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, {\n        token: entry.metadata()\n      });\n    }\n\n    error(reason) {\n      clearTimeout(this.chunkTimer);\n      this.uploadChannel.leave();\n      this.entry.error(reason);\n    }\n\n    upload() {\n      this.uploadChannel.onError(reason => this.error(reason));\n      this.uploadChannel.join().receive(\"ok\", _data => this.readNextChunk()).receive(\"error\", reason => this.error(reason));\n    }\n\n    isDone() {\n      return this.offset >= this.entry.file.size;\n    }\n\n    readNextChunk() {\n      let reader = new window.FileReader();\n      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\n\n      reader.onload = e => {\n        if (e.target.error === null) {\n          this.offset += e.target.result.byteLength;\n          this.pushChunk(e.target.result);\n        } else {\n          return logError(\"Read error: \" + e.target.error);\n        }\n      };\n\n      reader.readAsArrayBuffer(blob);\n    }\n\n    pushChunk(chunk) {\n      if (!this.uploadChannel.isJoined()) {\n        return;\n      }\n\n      this.uploadChannel.push(\"chunk\", chunk).receive(\"ok\", () => {\n        this.entry.progress(this.offset / this.entry.file.size * 100);\n\n        if (!this.isDone()) {\n          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);\n        }\n      });\n    }\n\n  }; // js/phoenix_live_view/utils.js\n\n  var logError = (msg, obj) => console.error && console.error(msg, obj);\n\n  var isCid = cid => {\n    let type = typeof cid;\n    return type === \"number\" || type === \"string\" && /^(0|[1-9]\\d*)$/.test(cid);\n  };\n\n  function detectDuplicateIds() {\n    let ids = new Set();\n    let elems = document.querySelectorAll(\"*[id]\");\n\n    for (let i = 0, len = elems.length; i < len; i++) {\n      if (ids.has(elems[i].id)) {\n        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);\n      } else {\n        ids.add(elems[i].id);\n      }\n    }\n  }\n\n  var debug = (view, kind, msg, obj) => {\n    if (view.liveSocket.isDebugEnabled()) {\n      console.log(`${view.id} ${kind}: ${msg} - `, obj);\n    }\n  };\n\n  var closure = val => typeof val === \"function\" ? val : function () {\n    return val;\n  };\n\n  var clone = obj => {\n    return JSON.parse(JSON.stringify(obj));\n  };\n\n  var closestPhxBinding = (el, binding, borderEl) => {\n    do {\n      if (el.matches(`[${binding}]`)) {\n        return el;\n      }\n\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\n\n    return null;\n  };\n\n  var isObject = obj => {\n    return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\n  };\n\n  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);\n\n  var isEmpty = obj => {\n    for (let x in obj) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var maybe = (el, callback) => el && callback(el);\n\n  var channelUploader = function (entries, onError, resp, liveSocket) {\n    entries.forEach(entry => {\n      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket);\n      entryUploader.upload();\n    });\n  }; // js/phoenix_live_view/browser.js\n\n\n  var Browser = {\n    canPushState() {\n      return typeof history.pushState !== \"undefined\";\n    },\n\n    dropLocal(localStorage, namespace, subkey) {\n      return localStorage.removeItem(this.localKey(namespace, subkey));\n    },\n\n    updateLocal(localStorage, namespace, subkey, initial, func) {\n      let current = this.getLocal(localStorage, namespace, subkey);\n      let key = this.localKey(namespace, subkey);\n      let newVal = current === null ? initial : func(current);\n      localStorage.setItem(key, JSON.stringify(newVal));\n      return newVal;\n    },\n\n    getLocal(localStorage, namespace, subkey) {\n      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\n    },\n\n    updateCurrentState(callback) {\n      if (!this.canPushState()) {\n        return;\n      }\n\n      history.replaceState(callback(history.state || {}), \"\", window.location.href);\n    },\n\n    pushState(kind, meta, to) {\n      if (this.canPushState()) {\n        if (to !== window.location.href) {\n          if (meta.type == \"redirect\" && meta.scroll) {\n            let currentState = history.state || {};\n            currentState.scroll = meta.scroll;\n            history.replaceState(currentState, \"\", window.location.href);\n          }\n\n          delete meta.scroll;\n          history[kind + \"State\"](meta, \"\", to || null);\n          let hashEl = this.getHashTargetEl(window.location.hash);\n\n          if (hashEl) {\n            hashEl.scrollIntoView();\n          } else if (meta.type === \"redirect\") {\n            window.scroll(0, 0);\n          }\n        }\n      } else {\n        this.redirect(to);\n      }\n    },\n\n    setCookie(name, value) {\n      document.cookie = `${name}=${value}`;\n    },\n\n    getCookie(name) {\n      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), \"$1\");\n    },\n\n    redirect(toURL, flash) {\n      if (flash) {\n        Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n      }\n\n      window.location = toURL;\n    },\n\n    localKey(namespace, subkey) {\n      return `${namespace}-${subkey}`;\n    },\n\n    getHashTargetEl(maybeHash) {\n      let hash = maybeHash.toString().substring(1);\n\n      if (hash === \"\") {\n        return;\n      }\n\n      return document.getElementById(hash) || document.querySelector(`a[name=\"${hash}\"]`);\n    }\n\n  };\n  var browser_default = Browser; // js/phoenix_live_view/dom.js\n\n  var DOM = {\n    byId(id) {\n      return document.getElementById(id) || logError(`no id found for ${id}`);\n    },\n\n    removeClass(el, className) {\n      el.classList.remove(className);\n\n      if (el.classList.length === 0) {\n        el.removeAttribute(\"class\");\n      }\n    },\n\n    all(node, query, callback) {\n      if (!node) {\n        return [];\n      }\n\n      let array = Array.from(node.querySelectorAll(query));\n      return callback ? array.forEach(callback) : array;\n    },\n\n    childNodeLength(html) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return template.content.childElementCount;\n    },\n\n    isUploadInput(el) {\n      return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\n    },\n\n    findUploadInputs(node) {\n      return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`);\n    },\n\n    findComponentNodeList(node, cid) {\n      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}=\"${cid}\"]`), node);\n    },\n\n    isPhxDestroyed(node) {\n      return node.id && DOM.private(node, \"destroyed\") ? true : false;\n    },\n\n    markPhxChildDestroyed(el) {\n      if (this.isPhxChild(el)) {\n        el.setAttribute(PHX_SESSION, \"\");\n      }\n\n      this.putPrivate(el, \"destroyed\", true);\n    },\n\n    findPhxChildrenInFragment(html, parentId) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return this.findPhxChildren(template.content, parentId);\n    },\n\n    isIgnored(el, phxUpdate) {\n      return (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) === \"ignore\";\n    },\n\n    isPhxUpdate(el, phxUpdate, updateTypes) {\n      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\n    },\n\n    findPhxSticky(el) {\n      return this.all(el, `[${PHX_STICKY}]`);\n    },\n\n    findPhxChildren(el, parentId) {\n      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\n    },\n\n    findParentCIDs(node, cids) {\n      let initial = new Set(cids);\n      return cids.reduce((acc, cid) => {\n        let selector = `[${PHX_COMPONENT}=\"${cid}\"] [${PHX_COMPONENT}]`;\n        this.filterWithinSameLiveView(this.all(node, selector), node).map(el => parseInt(el.getAttribute(PHX_COMPONENT))).forEach(childCID => acc.delete(childCID));\n        return acc;\n      }, initial);\n    },\n\n    filterWithinSameLiveView(nodes, parent) {\n      if (parent.querySelector(PHX_VIEW_SELECTOR)) {\n        return nodes.filter(el => this.withinSameLiveView(el, parent));\n      } else {\n        return nodes;\n      }\n    },\n\n    withinSameLiveView(node, parent) {\n      while (node = node.parentNode) {\n        if (node.isSameNode(parent)) {\n          return true;\n        }\n\n        if (node.getAttribute(PHX_SESSION) !== null) {\n          return false;\n        }\n      }\n    },\n\n    private(el, key) {\n      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n    },\n\n    deletePrivate(el, key) {\n      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n    },\n\n    putPrivate(el, key, value) {\n      if (!el[PHX_PRIVATE]) {\n        el[PHX_PRIVATE] = {};\n      }\n\n      el[PHX_PRIVATE][key] = value;\n    },\n\n    updatePrivate(el, key, defaultVal, updateFunc) {\n      let existing = this.private(el, key);\n\n      if (existing === void 0) {\n        this.putPrivate(el, key, updateFunc(defaultVal));\n      } else {\n        this.putPrivate(el, key, updateFunc(existing));\n      }\n    },\n\n    copyPrivates(target, source) {\n      if (source[PHX_PRIVATE]) {\n        target[PHX_PRIVATE] = source[PHX_PRIVATE];\n      }\n    },\n\n    putTitle(str) {\n      let titleEl = document.querySelector(\"title\");\n      let {\n        prefix,\n        suffix\n      } = titleEl.dataset;\n      document.title = `${prefix || \"\"}${str}${suffix || \"\"}`;\n    },\n\n    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {\n      let debounce = el.getAttribute(phxDebounce);\n      let throttle = el.getAttribute(phxThrottle);\n\n      if (debounce === \"\") {\n        debounce = defaultDebounce;\n      }\n\n      if (throttle === \"\") {\n        throttle = defaultThrottle;\n      }\n\n      let value = debounce || throttle;\n\n      switch (value) {\n        case null:\n          return callback();\n\n        case \"blur\":\n          if (this.once(el, \"debounce-blur\")) {\n            el.addEventListener(\"blur\", () => callback());\n          }\n\n          return;\n\n        default:\n          let timeout = parseInt(value);\n\n          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();\n\n          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n\n          if (isNaN(timeout)) {\n            return logError(`invalid throttle/debounce value: ${value}`);\n          }\n\n          if (throttle) {\n            let newKeyDown = false;\n\n            if (event.type === \"keydown\") {\n              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);\n              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n              newKeyDown = prevKey !== event.key;\n            }\n\n            if (!newKeyDown && this.private(el, THROTTLED)) {\n              return false;\n            } else {\n              callback();\n              this.putPrivate(el, THROTTLED, true);\n              setTimeout(() => {\n                if (asyncFilter()) {\n                  this.triggerCycle(el, DEBOUNCE_TRIGGER);\n                }\n              }, timeout);\n            }\n          } else {\n            setTimeout(() => {\n              if (asyncFilter()) {\n                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);\n              }\n            }, timeout);\n          }\n\n          let form = el.form;\n\n          if (form && this.once(form, \"bind-debounce\")) {\n            form.addEventListener(\"submit\", () => {\n              Array.from(new FormData(form).entries(), ([name]) => {\n                let input = form.querySelector(`[name=\"${name}\"]`);\n                this.incCycle(input, DEBOUNCE_TRIGGER);\n                this.deletePrivate(input, THROTTLED);\n              });\n            });\n          }\n\n          if (this.once(el, \"bind-debounce\")) {\n            el.addEventListener(\"blur\", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));\n          }\n\n      }\n    },\n\n    triggerCycle(el, key, currentCycle) {\n      let [cycle, trigger] = this.private(el, key);\n\n      if (!currentCycle) {\n        currentCycle = cycle;\n      }\n\n      if (currentCycle === cycle) {\n        this.incCycle(el, key);\n        trigger();\n      }\n    },\n\n    once(el, key) {\n      if (this.private(el, key) === true) {\n        return false;\n      }\n\n      this.putPrivate(el, key, true);\n      return true;\n    },\n\n    incCycle(el, key, trigger = function () {}) {\n      let [currentCycle] = this.private(el, key) || [0, trigger];\n      currentCycle++;\n      this.putPrivate(el, key, [currentCycle, trigger]);\n      return currentCycle;\n    },\n\n    discardError(container, el, phxFeedbackFor) {\n      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);\n      let input = field && container.querySelector(`[id=\"${field}\"], [name=\"${field}\"]`);\n\n      if (!input) {\n        return;\n      }\n\n      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {\n        el.classList.add(PHX_NO_FEEDBACK_CLASS);\n      }\n    },\n\n    showError(inputEl, phxFeedbackFor) {\n      if (inputEl.id || inputEl.name) {\n        this.all(inputEl.form, `[${phxFeedbackFor}=\"${inputEl.id}\"], [${phxFeedbackFor}=\"${inputEl.name}\"]`, el => {\n          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);\n        });\n      }\n    },\n\n    isPhxChild(node) {\n      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n    },\n\n    isPhxSticky(node) {\n      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;\n    },\n\n    firstPhxChild(el) {\n      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];\n    },\n\n    dispatchEvent(target, name, opts = {}) {\n      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;\n      let eventOpts = {\n        bubbles,\n        cancelable: true,\n        detail: opts.detail || {}\n      };\n      let event = name === \"click\" ? new MouseEvent(\"click\", eventOpts) : new CustomEvent(name, eventOpts);\n      target.dispatchEvent(event);\n    },\n\n    cloneNode(node, html) {\n      if (typeof html === \"undefined\") {\n        return node.cloneNode(true);\n      } else {\n        let cloned = node.cloneNode(false);\n        cloned.innerHTML = html;\n        return cloned;\n      }\n    },\n\n    mergeAttrs(target, source, opts = {}) {\n      let exclude = opts.exclude || [];\n      let isIgnored = opts.isIgnored;\n      let sourceAttrs = source.attributes;\n\n      for (let i = sourceAttrs.length - 1; i >= 0; i--) {\n        let name = sourceAttrs[i].name;\n\n        if (exclude.indexOf(name) < 0) {\n          target.setAttribute(name, source.getAttribute(name));\n        }\n      }\n\n      let targetAttrs = target.attributes;\n\n      for (let i = targetAttrs.length - 1; i >= 0; i--) {\n        let name = targetAttrs[i].name;\n\n        if (isIgnored) {\n          if (name.startsWith(\"data-\") && !source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        } else {\n          if (!source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        }\n      }\n    },\n\n    mergeFocusedInput(target, source) {\n      if (!(target instanceof HTMLSelectElement)) {\n        DOM.mergeAttrs(target, source, {\n          exclude: [\"value\"]\n        });\n      }\n\n      if (source.readOnly) {\n        target.setAttribute(\"readonly\", true);\n      } else {\n        target.removeAttribute(\"readonly\");\n      }\n    },\n\n    hasSelectionRange(el) {\n      return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\n    },\n\n    restoreFocus(focused, selectionStart, selectionEnd) {\n      if (!DOM.isTextualInput(focused)) {\n        return;\n      }\n\n      let wasFocused = focused.matches(\":focus\");\n\n      if (focused.readOnly) {\n        focused.blur();\n      }\n\n      if (!wasFocused) {\n        focused.focus();\n      }\n\n      if (this.hasSelectionRange(focused)) {\n        focused.setSelectionRange(selectionStart, selectionEnd);\n      }\n    },\n\n    isFormInput(el) {\n      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\n    },\n\n    syncAttrsToProps(el) {\n      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\n        el.checked = el.getAttribute(\"checked\") !== null;\n      }\n    },\n\n    isTextualInput(el) {\n      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n    },\n\n    isNowTriggerFormExternal(el, phxTriggerExternal) {\n      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;\n    },\n\n    syncPendingRef(fromEl, toEl, disableWith) {\n      let ref = fromEl.getAttribute(PHX_REF);\n\n      if (ref === null) {\n        return true;\n      }\n\n      let refSrc = fromEl.getAttribute(PHX_REF_SRC);\n\n      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {\n        if (DOM.isUploadInput(fromEl)) {\n          DOM.mergeAttrs(fromEl, toEl, {\n            isIgnored: true\n          });\n        }\n\n        DOM.putPrivate(fromEl, PHX_REF, toEl);\n        return false;\n      } else {\n        PHX_EVENT_CLASSES.forEach(className => {\n          fromEl.classList.contains(className) && toEl.classList.add(className);\n        });\n        toEl.setAttribute(PHX_REF, ref);\n        toEl.setAttribute(PHX_REF_SRC, refSrc);\n        return true;\n      }\n    },\n\n    cleanChildNodes(container, phxUpdate) {\n      if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\"])) {\n        let toRemove = [];\n        container.childNodes.forEach(childNode => {\n          if (!childNode.id) {\n            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\n\n            if (!isEmptyTextNode) {\n              logError(`only HTML element tags with an id are allowed inside containers with phx-update.\n\nremoving illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\n\n`);\n            }\n\n            toRemove.push(childNode);\n          }\n        });\n        toRemove.forEach(childNode => childNode.remove());\n      }\n    },\n\n    replaceRootContainer(container, tagName, attrs) {\n      let retainedAttrs = new Set([\"id\", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);\n\n      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\n        Array.from(container.attributes).filter(attr => !retainedAttrs.has(attr.name.toLowerCase())).forEach(attr => container.removeAttribute(attr.name));\n        Object.keys(attrs).filter(name => !retainedAttrs.has(name.toLowerCase())).forEach(attr => container.setAttribute(attr, attrs[attr]));\n        return container;\n      } else {\n        let newContainer = document.createElement(tagName);\n        Object.keys(attrs).forEach(attr => newContainer.setAttribute(attr, attrs[attr]));\n        retainedAttrs.forEach(attr => newContainer.setAttribute(attr, container.getAttribute(attr)));\n        newContainer.innerHTML = container.innerHTML;\n        container.replaceWith(newContainer);\n        return newContainer;\n      }\n    },\n\n    getSticky(el, name, defaultVal) {\n      let op = (DOM.private(el, \"sticky\") || []).find(([existingName]) => name === existingName);\n\n      if (op) {\n        let [_name, _op, stashedResult] = op;\n        return stashedResult;\n      } else {\n        return typeof defaultVal === \"function\" ? defaultVal() : defaultVal;\n      }\n    },\n\n    deleteSticky(el, name) {\n      this.updatePrivate(el, \"sticky\", [], ops => {\n        return ops.filter(([existingName, _]) => existingName !== name);\n      });\n    },\n\n    putSticky(el, name, op) {\n      let stashedResult = op(el);\n      this.updatePrivate(el, \"sticky\", [], ops => {\n        let existingIndex = ops.findIndex(([existingName]) => name === existingName);\n\n        if (existingIndex >= 0) {\n          ops[existingIndex] = [name, op, stashedResult];\n        } else {\n          ops.push([name, op, stashedResult]);\n        }\n\n        return ops;\n      });\n    },\n\n    applyStickyOperations(el) {\n      let ops = DOM.private(el, \"sticky\");\n\n      if (!ops) {\n        return;\n      }\n\n      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));\n    }\n\n  };\n  var dom_default = DOM; // js/phoenix_live_view/upload_entry.js\n\n  var UploadEntry = class {\n    static isActive(fileEl, file) {\n      let isNew = file._phxRef === void 0;\n      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return file.size > 0 && (isNew || isActive);\n    }\n\n    static isPreflighted(fileEl, file) {\n      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(\",\");\n      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return isPreflighted && this.isActive(fileEl, file);\n    }\n\n    constructor(fileEl, file, view) {\n      this.ref = LiveUploader.genFileRef(file);\n      this.fileEl = fileEl;\n      this.file = file;\n      this.view = view;\n      this.meta = null;\n      this._isCancelled = false;\n      this._isDone = false;\n      this._progress = 0;\n      this._lastProgressSent = -1;\n\n      this._onDone = function () {};\n\n      this._onElUpdated = this.onElUpdated.bind(this);\n      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    }\n\n    metadata() {\n      return this.meta;\n    }\n\n    progress(progress) {\n      this._progress = Math.floor(progress);\n\n      if (this._progress > this._lastProgressSent) {\n        if (this._progress >= 100) {\n          this._progress = 100;\n          this._lastProgressSent = 100;\n          this._isDone = true;\n          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\n            LiveUploader.untrackFile(this.fileEl, this.file);\n\n            this._onDone();\n          });\n        } else {\n          this._lastProgressSent = this._progress;\n          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n        }\n      }\n    }\n\n    cancel() {\n      this._isCancelled = true;\n      this._isDone = true;\n\n      this._onDone();\n    }\n\n    isDone() {\n      return this._isDone;\n    }\n\n    error(reason = \"failed\") {\n      this.view.pushFileProgress(this.fileEl, this.ref, {\n        error: reason\n      });\n      LiveUploader.clearFiles(this.fileEl);\n    }\n\n    onDone(callback) {\n      this._onDone = () => {\n        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n        callback();\n      };\n    }\n\n    onElUpdated() {\n      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n\n      if (activeRefs.indexOf(this.ref) === -1) {\n        this.cancel();\n      }\n    }\n\n    toPreflightPayload() {\n      return {\n        last_modified: this.file.lastModified,\n        name: this.file.name,\n        size: this.file.size,\n        type: this.file.type,\n        ref: this.ref\n      };\n    }\n\n    uploader(uploaders) {\n      if (this.meta.uploader) {\n        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);\n        return {\n          name: this.meta.uploader,\n          callback\n        };\n      } else {\n        return {\n          name: \"channel\",\n          callback: channelUploader\n        };\n      }\n    }\n\n    zipPostFlight(resp) {\n      this.meta = resp.entries[this.ref];\n\n      if (!this.meta) {\n        logError(`no preflight upload response returned with ref ${this.ref}`, {\n          input: this.fileEl,\n          response: resp\n        });\n      }\n    }\n\n  }; // js/phoenix_live_view/live_uploader.js\n\n  var liveUploaderFileRef = 0;\n  var LiveUploader = class {\n    static genFileRef(file) {\n      let ref = file._phxRef;\n\n      if (ref !== void 0) {\n        return ref;\n      } else {\n        file._phxRef = (liveUploaderFileRef++).toString();\n        return file._phxRef;\n      }\n    }\n\n    static getEntryDataURL(inputEl, ref, callback) {\n      let file = this.activeFiles(inputEl).find(file2 => this.genFileRef(file2) === ref);\n      callback(URL.createObjectURL(file));\n    }\n\n    static hasUploadsInProgress(formEl) {\n      let active = 0;\n      dom_default.findUploadInputs(formEl).forEach(input => {\n        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {\n          active++;\n        }\n      });\n      return active > 0;\n    }\n\n    static serializeUploads(inputEl) {\n      let files = this.activeFiles(inputEl);\n      let fileData = {};\n      files.forEach(file => {\n        let entry = {\n          path: inputEl.name\n        };\n        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\n        fileData[uploadRef] = fileData[uploadRef] || [];\n        entry.ref = this.genFileRef(file);\n        entry.name = file.name || entry.ref;\n        entry.type = file.type;\n        entry.size = file.size;\n        fileData[uploadRef].push(entry);\n      });\n      return fileData;\n    }\n\n    static clearFiles(inputEl) {\n      inputEl.value = null;\n      inputEl.removeAttribute(PHX_UPLOAD_REF);\n      dom_default.putPrivate(inputEl, \"files\", []);\n    }\n\n    static untrackFile(inputEl, file) {\n      dom_default.putPrivate(inputEl, \"files\", dom_default.private(inputEl, \"files\").filter(f => !Object.is(f, file)));\n    }\n\n    static trackFiles(inputEl, files) {\n      if (inputEl.getAttribute(\"multiple\") !== null) {\n        let newFiles = files.filter(file => !this.activeFiles(inputEl).find(f => Object.is(f, file)));\n        dom_default.putPrivate(inputEl, \"files\", this.activeFiles(inputEl).concat(newFiles));\n        inputEl.value = null;\n      } else {\n        dom_default.putPrivate(inputEl, \"files\", files);\n      }\n    }\n\n    static activeFileInputs(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(el => el.files && this.activeFiles(el).length > 0);\n    }\n\n    static activeFiles(input) {\n      return (dom_default.private(input, \"files\") || []).filter(f => UploadEntry.isActive(input, f));\n    }\n\n    static inputsAwaitingPreflight(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(input => this.filesAwaitingPreflight(input).length > 0);\n    }\n\n    static filesAwaitingPreflight(input) {\n      return this.activeFiles(input).filter(f => !UploadEntry.isPreflighted(input, f));\n    }\n\n    constructor(inputEl, view, onComplete) {\n      this.view = view;\n      this.onComplete = onComplete;\n      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map(file => new UploadEntry(inputEl, file, view));\n      this.numEntriesInProgress = this._entries.length;\n    }\n\n    entries() {\n      return this._entries;\n    }\n\n    initAdapterUpload(resp, onError, liveSocket) {\n      this._entries = this._entries.map(entry => {\n        entry.zipPostFlight(resp);\n        entry.onDone(() => {\n          this.numEntriesInProgress--;\n\n          if (this.numEntriesInProgress === 0) {\n            this.onComplete();\n          }\n        });\n        return entry;\n      });\n\n      let groupedEntries = this._entries.reduce((acc, entry) => {\n        let {\n          name,\n          callback\n        } = entry.uploader(liveSocket.uploaders);\n        acc[name] = acc[name] || {\n          callback,\n          entries: []\n        };\n        acc[name].entries.push(entry);\n        return acc;\n      }, {});\n\n      for (let name in groupedEntries) {\n        let {\n          callback,\n          entries\n        } = groupedEntries[name];\n        callback(entries, onError, resp, liveSocket);\n      }\n    }\n\n  }; // js/phoenix_live_view/hooks.js\n\n  var Hooks = {\n    LiveFileUpload: {\n      activeRefs() {\n        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\n      },\n\n      preflightedRefs() {\n        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\n      },\n\n      mounted() {\n        this.preflightedWas = this.preflightedRefs();\n      },\n\n      updated() {\n        let newPreflights = this.preflightedRefs();\n\n        if (this.preflightedWas !== newPreflights) {\n          this.preflightedWas = newPreflights;\n\n          if (newPreflights === \"\") {\n            this.__view.cancelSubmit(this.el.form);\n          }\n        }\n\n        if (this.activeRefs() === \"\") {\n          this.el.value = null;\n        }\n\n        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\n      }\n\n    },\n    LiveImgPreview: {\n      mounted() {\n        this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\n        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));\n        LiveUploader.getEntryDataURL(this.inputEl, this.ref, url => {\n          this.url = url;\n          this.el.src = url;\n        });\n      },\n\n      destroyed() {\n        URL.revokeObjectURL(this.url);\n      }\n\n    }\n  };\n  var hooks_default = Hooks; // js/phoenix_live_view/dom_post_morph_restorer.js\n\n  var DOMPostMorphRestorer = class {\n    constructor(containerBefore, containerAfter, updateType) {\n      let idsBefore = new Set();\n      let idsAfter = new Set([...containerAfter.children].map(child => child.id));\n      let elementsToModify = [];\n      Array.from(containerBefore.children).forEach(child => {\n        if (child.id) {\n          idsBefore.add(child.id);\n\n          if (idsAfter.has(child.id)) {\n            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;\n            elementsToModify.push({\n              elementId: child.id,\n              previousElementId\n            });\n          }\n        }\n      });\n      this.containerId = containerAfter.id;\n      this.updateType = updateType;\n      this.elementsToModify = elementsToModify;\n      this.elementIdsToAdd = [...idsAfter].filter(id => !idsBefore.has(id));\n    }\n\n    perform() {\n      let container = dom_default.byId(this.containerId);\n      this.elementsToModify.forEach(elementToModify => {\n        if (elementToModify.previousElementId) {\n          maybe(document.getElementById(elementToModify.previousElementId), previousElem => {\n            maybe(document.getElementById(elementToModify.elementId), elem => {\n              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\n\n              if (!isInRightPlace) {\n                previousElem.insertAdjacentElement(\"afterend\", elem);\n              }\n            });\n          });\n        } else {\n          maybe(document.getElementById(elementToModify.elementId), elem => {\n            let isInRightPlace = elem.previousElementSibling == null;\n\n            if (!isInRightPlace) {\n              container.insertAdjacentElement(\"afterbegin\", elem);\n            }\n          });\n        }\n      });\n\n      if (this.updateType == \"prepend\") {\n        this.elementIdsToAdd.reverse().forEach(elemId => {\n          maybe(document.getElementById(elemId), elem => container.insertAdjacentElement(\"afterbegin\", elem));\n        });\n      }\n    }\n\n  }; // node_modules/morphdom/dist/morphdom-esm.js\n\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  function morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n      attr = toNodeAttrs[i];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n      attrValue = attr.value;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n        if (fromValue !== attrValue) {\n          if (attr.prefix === \"xmlns\") {\n            attrName = attr.name;\n          }\n\n          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n        }\n      } else {\n        fromValue = fromNode.getAttribute(attrName);\n\n        if (fromValue !== attrValue) {\n          fromNode.setAttribute(attrName, attrValue);\n        }\n      }\n    }\n\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n      attr = fromNodeAttrs[d];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n\n        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n          fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n        }\n      } else {\n        if (!toNode.hasAttribute(attrName)) {\n          fromNode.removeAttribute(attrName);\n        }\n      }\n    }\n  }\n\n  var range;\n  var NS_XHTML = \"http://www.w3.org/1999/xhtml\";\n  var doc = typeof document === \"undefined\" ? void 0 : document;\n  var HAS_TEMPLATE_SUPPORT = !!doc && \"content\" in doc.createElement(\"template\");\n  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && \"createContextualFragment\" in doc.createRange();\n\n  function createFragmentFromTemplate(str) {\n    var template = doc.createElement(\"template\");\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n  }\n\n  function createFragmentFromRange(str) {\n    if (!range) {\n      range = doc.createRange();\n      range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n  }\n\n  function createFragmentFromWrap(str) {\n    var fragment = doc.createElement(\"body\");\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n  }\n\n  function toElement(str) {\n    str = str.trim();\n\n    if (HAS_TEMPLATE_SUPPORT) {\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n  }\n\n  function compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n      return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    if (fromCodeStart <= 90 && toCodeStart >= 97) {\n      return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\n      return toNodeName === fromNodeName.toUpperCase();\n    } else {\n      return false;\n    }\n  }\n\n  function createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\n  }\n\n  function moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n\n    while (curChild) {\n      var nextChild = curChild.nextSibling;\n      toEl.appendChild(curChild);\n      curChild = nextChild;\n    }\n\n    return toEl;\n  }\n\n  function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n      fromEl[name] = toEl[name];\n\n      if (fromEl[name]) {\n        fromEl.setAttribute(name, \"\");\n      } else {\n        fromEl.removeAttribute(name);\n      }\n    }\n  }\n\n  var specialElHandlers = {\n    OPTION: function (fromEl, toEl) {\n      var parentNode = fromEl.parentNode;\n\n      if (parentNode) {\n        var parentName = parentNode.nodeName.toUpperCase();\n\n        if (parentName === \"OPTGROUP\") {\n          parentNode = parentNode.parentNode;\n          parentName = parentNode && parentNode.nodeName.toUpperCase();\n        }\n\n        if (parentName === \"SELECT\" && !parentNode.hasAttribute(\"multiple\")) {\n          if (fromEl.hasAttribute(\"selected\") && !toEl.selected) {\n            fromEl.setAttribute(\"selected\", \"selected\");\n            fromEl.removeAttribute(\"selected\");\n          }\n\n          parentNode.selectedIndex = -1;\n        }\n      }\n\n      syncBooleanAttrProp(fromEl, toEl, \"selected\");\n    },\n    INPUT: function (fromEl, toEl) {\n      syncBooleanAttrProp(fromEl, toEl, \"checked\");\n      syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n      if (fromEl.value !== toEl.value) {\n        fromEl.value = toEl.value;\n      }\n\n      if (!toEl.hasAttribute(\"value\")) {\n        fromEl.removeAttribute(\"value\");\n      }\n    },\n    TEXTAREA: function (fromEl, toEl) {\n      var newValue = toEl.value;\n\n      if (fromEl.value !== newValue) {\n        fromEl.value = newValue;\n      }\n\n      var firstChild = fromEl.firstChild;\n\n      if (firstChild) {\n        var oldValue = firstChild.nodeValue;\n\n        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\n          return;\n        }\n\n        firstChild.nodeValue = newValue;\n      }\n    },\n    SELECT: function (fromEl, toEl) {\n      if (!toEl.hasAttribute(\"multiple\")) {\n        var selectedIndex = -1;\n        var i = 0;\n        var curChild = fromEl.firstChild;\n        var optgroup;\n        var nodeName;\n\n        while (curChild) {\n          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n\n          if (nodeName === \"OPTGROUP\") {\n            optgroup = curChild;\n            curChild = optgroup.firstChild;\n          } else {\n            if (nodeName === \"OPTION\") {\n              if (curChild.hasAttribute(\"selected\")) {\n                selectedIndex = i;\n                break;\n              }\n\n              i++;\n            }\n\n            curChild = curChild.nextSibling;\n\n            if (!curChild && optgroup) {\n              curChild = optgroup.nextSibling;\n              optgroup = null;\n            }\n          }\n        }\n\n        fromEl.selectedIndex = selectedIndex;\n      }\n    }\n  };\n  var ELEMENT_NODE = 1;\n  var DOCUMENT_FRAGMENT_NODE$1 = 11;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n\n  function noop() {}\n\n  function defaultGetNodeKey(node) {\n    if (node) {\n      return node.getAttribute && node.getAttribute(\"id\") || node.id;\n    }\n  }\n\n  function morphdomFactory(morphAttrs2) {\n    return function morphdom2(fromNode, toNode, options) {\n      if (!options) {\n        options = {};\n      }\n\n      if (typeof toNode === \"string\") {\n        if (fromNode.nodeName === \"#document\" || fromNode.nodeName === \"HTML\" || fromNode.nodeName === \"BODY\") {\n          var toNodeHtml = toNode;\n          toNode = doc.createElement(\"html\");\n          toNode.innerHTML = toNodeHtml;\n        } else {\n          toNode = toElement(toNode);\n        }\n      }\n\n      var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n      var onNodeAdded = options.onNodeAdded || noop;\n      var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n      var onElUpdated = options.onElUpdated || noop;\n      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n      var onNodeDiscarded = options.onNodeDiscarded || noop;\n      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n      var childrenOnly = options.childrenOnly === true;\n      var fromNodesLookup = Object.create(null);\n      var keyedRemovalList = [];\n\n      function addKeyedRemoval(key) {\n        keyedRemovalList.push(key);\n      }\n\n      function walkDiscardedChildNodes(node, skipKeyedNodes) {\n        if (node.nodeType === ELEMENT_NODE) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = void 0;\n\n            if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n              addKeyedRemoval(key);\n            } else {\n              onNodeDiscarded(curChild);\n\n              if (curChild.firstChild) {\n                walkDiscardedChildNodes(curChild, skipKeyedNodes);\n              }\n            }\n\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      function removeNode(node, parentNode, skipKeyedNodes) {\n        if (onBeforeNodeDiscarded(node) === false) {\n          return;\n        }\n\n        if (parentNode) {\n          parentNode.removeChild(node);\n        }\n\n        onNodeDiscarded(node);\n        walkDiscardedChildNodes(node, skipKeyedNodes);\n      }\n\n      function indexTree(node) {\n        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = getNodeKey(curChild);\n\n            if (key) {\n              fromNodesLookup[key] = curChild;\n            }\n\n            indexTree(curChild);\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      indexTree(fromNode);\n\n      function handleNodeAdded(el) {\n        onNodeAdded(el);\n        var curChild = el.firstChild;\n\n        while (curChild) {\n          var nextSibling = curChild.nextSibling;\n          var key = getNodeKey(curChild);\n\n          if (key) {\n            var unmatchedFromEl = fromNodesLookup[key];\n\n            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n              morphEl(unmatchedFromEl, curChild);\n            } else {\n              handleNodeAdded(curChild);\n            }\n          } else {\n            handleNodeAdded(curChild);\n          }\n\n          curChild = nextSibling;\n        }\n      }\n\n      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n        while (curFromNodeChild) {\n          var fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            removeNode(curFromNodeChild, fromEl, true);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        }\n      }\n\n      function morphEl(fromEl, toEl, childrenOnly2) {\n        var toElKey = getNodeKey(toEl);\n\n        if (toElKey) {\n          delete fromNodesLookup[toElKey];\n        }\n\n        if (!childrenOnly2) {\n          if (onBeforeElUpdated(fromEl, toEl) === false) {\n            return;\n          }\n\n          morphAttrs2(fromEl, toEl);\n          onElUpdated(fromEl);\n\n          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n            return;\n          }\n        }\n\n        if (fromEl.nodeName !== \"TEXTAREA\") {\n          morphChildren(fromEl, toEl);\n        } else {\n          specialElHandlers.TEXTAREA(fromEl, toEl);\n        }\n      }\n\n      function morphChildren(fromEl, toEl) {\n        var curToNodeChild = toEl.firstChild;\n        var curFromNodeChild = fromEl.firstChild;\n        var curToNodeKey;\n        var curFromNodeKey;\n        var fromNextSibling;\n        var toNextSibling;\n        var matchingFromEl;\n\n        outer: while (curToNodeChild) {\n          toNextSibling = curToNodeChild.nextSibling;\n          curToNodeKey = getNodeKey(curToNodeChild);\n\n          while (curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n\n            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            curFromNodeKey = getNodeKey(curFromNodeChild);\n            var curFromNodeType = curFromNodeChild.nodeType;\n            var isCompatible = void 0;\n\n            if (curFromNodeType === curToNodeChild.nodeType) {\n              if (curFromNodeType === ELEMENT_NODE) {\n                if (curToNodeKey) {\n                  if (curToNodeKey !== curFromNodeKey) {\n                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\n                      if (fromNextSibling === matchingFromEl) {\n                        isCompatible = false;\n                      } else {\n                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                        if (curFromNodeKey) {\n                          addKeyedRemoval(curFromNodeKey);\n                        } else {\n                          removeNode(curFromNodeChild, fromEl, true);\n                        }\n\n                        curFromNodeChild = matchingFromEl;\n                      }\n                    } else {\n                      isCompatible = false;\n                    }\n                  }\n                } else if (curFromNodeKey) {\n                  isCompatible = false;\n                }\n\n                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n\n                if (isCompatible) {\n                  morphEl(curFromNodeChild, curToNodeChild);\n                }\n              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                isCompatible = true;\n\n                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                }\n              }\n            }\n\n            if (isCompatible) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            if (curFromNodeKey) {\n              addKeyedRemoval(curFromNodeKey);\n            } else {\n              removeNode(curFromNodeChild, fromEl, true);\n            }\n\n            curFromNodeChild = fromNextSibling;\n          }\n\n          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n            fromEl.appendChild(matchingFromEl);\n            morphEl(matchingFromEl, curToNodeChild);\n          } else {\n            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n\n            if (onBeforeNodeAddedResult !== false) {\n              if (onBeforeNodeAddedResult) {\n                curToNodeChild = onBeforeNodeAddedResult;\n              }\n\n              if (curToNodeChild.actualize) {\n                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n              }\n\n              fromEl.appendChild(curToNodeChild);\n              handleNodeAdded(curToNodeChild);\n            }\n          }\n\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n        }\n\n        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n        var specialElHandler = specialElHandlers[fromEl.nodeName];\n\n        if (specialElHandler) {\n          specialElHandler(fromEl, toEl);\n        }\n      }\n\n      var morphedNode = fromNode;\n      var morphedNodeType = morphedNode.nodeType;\n      var toNodeType = toNode.nodeType;\n\n      if (!childrenOnly) {\n        if (morphedNodeType === ELEMENT_NODE) {\n          if (toNodeType === ELEMENT_NODE) {\n            if (!compareNodeNames(fromNode, toNode)) {\n              onNodeDiscarded(fromNode);\n              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n            }\n          } else {\n            morphedNode = toNode;\n          }\n        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\n          if (toNodeType === morphedNodeType) {\n            if (morphedNode.nodeValue !== toNode.nodeValue) {\n              morphedNode.nodeValue = toNode.nodeValue;\n            }\n\n            return morphedNode;\n          } else {\n            morphedNode = toNode;\n          }\n        }\n      }\n\n      if (morphedNode === toNode) {\n        onNodeDiscarded(fromNode);\n      } else {\n        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n          return;\n        }\n\n        morphEl(morphedNode, toNode, childrenOnly);\n\n        if (keyedRemovalList) {\n          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\n            var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n\n            if (elToRemove) {\n              removeNode(elToRemove, elToRemove.parentNode, false);\n            }\n          }\n        }\n      }\n\n      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n        if (morphedNode.actualize) {\n          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n        }\n\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n      }\n\n      return morphedNode;\n    };\n  }\n\n  var morphdom = morphdomFactory(morphAttrs);\n  var morphdom_esm_default = morphdom; // js/phoenix_live_view/dom_patch.js\n\n  var DOMPatch = class {\n    static patchEl(fromEl, toEl, activeElement) {\n      morphdom_esm_default(fromEl, toEl, {\n        childrenOnly: false,\n        onBeforeElUpdated: (fromEl2, toEl2) => {\n          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {\n            dom_default.mergeFocusedInput(fromEl2, toEl2);\n            return false;\n          }\n        }\n      });\n    }\n\n    constructor(view, container, id, html, targetCID) {\n      this.view = view;\n      this.liveSocket = view.liveSocket;\n      this.container = container;\n      this.id = id;\n      this.rootID = view.root.id;\n      this.html = html;\n      this.targetCID = targetCID;\n      this.cidPatch = isCid(this.targetCID);\n      this.callbacks = {\n        beforeadded: [],\n        beforeupdated: [],\n        beforephxChildAdded: [],\n        afteradded: [],\n        afterupdated: [],\n        afterdiscarded: [],\n        afterphxChildAdded: [],\n        aftertransitionsDiscarded: []\n      };\n    }\n\n    before(kind, callback) {\n      this.callbacks[`before${kind}`].push(callback);\n    }\n\n    after(kind, callback) {\n      this.callbacks[`after${kind}`].push(callback);\n    }\n\n    trackBefore(kind, ...args) {\n      this.callbacks[`before${kind}`].forEach(callback => callback(...args));\n    }\n\n    trackAfter(kind, ...args) {\n      this.callbacks[`after${kind}`].forEach(callback => callback(...args));\n    }\n\n    markPrunableContentForRemoval() {\n      dom_default.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", el => {\n        el.setAttribute(PHX_PRUNE, \"\");\n      });\n    }\n\n    perform() {\n      let {\n        view,\n        liveSocket,\n        container,\n        html\n      } = this;\n      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;\n\n      if (this.isCIDPatch() && !targetContainer) {\n        return;\n      }\n\n      let focused = liveSocket.getActiveElement();\n      let {\n        selectionStart,\n        selectionEnd\n      } = focused && dom_default.hasSelectionRange(focused) ? focused : {};\n      let phxUpdate = liveSocket.binding(PHX_UPDATE);\n      let phxFeedbackFor = liveSocket.binding(PHX_FEEDBACK_FOR);\n      let disableWith = liveSocket.binding(PHX_DISABLE_WITH);\n      let phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n      let phxRemove = liveSocket.binding(\"remove\");\n      let added = [];\n      let updates = [];\n      let appendPrependUpdates = [];\n      let pendingRemoves = [];\n      let externalFormTriggered = null;\n      let diffHTML = liveSocket.time(\"premorph container prep\", () => {\n        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);\n      });\n      this.trackBefore(\"added\", container);\n      this.trackBefore(\"updated\", container, container);\n      liveSocket.time(\"morphdom\", () => {\n        morphdom_esm_default(targetContainer, diffHTML, {\n          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,\n          getNodeKey: node => {\n            return dom_default.isPhxDestroyed(node) ? null : node.id;\n          },\n          onBeforeNodeAdded: el => {\n            this.trackBefore(\"added\", el);\n            return el;\n          },\n          onNodeAdded: el => {\n            if (el instanceof HTMLImageElement && el.srcset) {\n              el.srcset = el.srcset;\n            } else if (el instanceof HTMLVideoElement && el.autoplay) {\n              el.play();\n            }\n\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            dom_default.discardError(targetContainer, el, phxFeedbackFor);\n\n            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {\n              this.trackAfter(\"phxChildAdded\", el);\n            }\n\n            added.push(el);\n          },\n          onNodeDiscarded: el => {\n            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {\n              liveSocket.destroyViewByEl(el);\n            }\n\n            this.trackAfter(\"discarded\", el);\n          },\n          onBeforeNodeDiscarded: el => {\n            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {\n              return true;\n            }\n\n            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, [\"append\", \"prepend\"]) && el.id) {\n              return false;\n            }\n\n            if (el.getAttribute && el.getAttribute(phxRemove)) {\n              pendingRemoves.push(el);\n              return false;\n            }\n\n            if (this.skipCIDSibling(el)) {\n              return false;\n            }\n\n            return true;\n          },\n          onElUpdated: el => {\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            updates.push(el);\n          },\n          onBeforeElUpdated: (fromEl, toEl) => {\n            dom_default.cleanChildNodes(toEl, phxUpdate);\n\n            if (this.skipCIDSibling(toEl)) {\n              return false;\n            }\n\n            if (dom_default.isPhxSticky(fromEl)) {\n              return false;\n            }\n\n            if (dom_default.isIgnored(fromEl, phxUpdate)) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                isIgnored: true\n              });\n              updates.push(fromEl);\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            }\n\n            if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n              return false;\n            }\n\n            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {\n              if (dom_default.isUploadInput(fromEl)) {\n                this.trackBefore(\"updated\", fromEl, toEl);\n                updates.push(fromEl);\n              }\n\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            }\n\n            if (dom_default.isPhxChild(toEl)) {\n              let prevSession = fromEl.getAttribute(PHX_SESSION);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                exclude: [PHX_STATIC]\n              });\n\n              if (prevSession !== \"\") {\n                fromEl.setAttribute(PHX_SESSION, prevSession);\n              }\n\n              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            }\n\n            dom_default.copyPrivates(toEl, fromEl);\n            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);\n            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);\n\n            if (isFocusedFormEl) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeFocusedInput(fromEl, toEl);\n              dom_default.syncAttrsToProps(fromEl);\n              updates.push(fromEl);\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            } else {\n              if (dom_default.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));\n              }\n\n              dom_default.syncAttrsToProps(toEl);\n              dom_default.applyStickyOperations(toEl);\n              this.trackBefore(\"updated\", fromEl, toEl);\n              return true;\n            }\n          }\n        });\n      });\n\n      if (liveSocket.isDebugEnabled()) {\n        detectDuplicateIds();\n      }\n\n      if (appendPrependUpdates.length > 0) {\n        liveSocket.time(\"post-morph append/prepend restoration\", () => {\n          appendPrependUpdates.forEach(update => update.perform());\n        });\n      }\n\n      liveSocket.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));\n      dom_default.dispatchEvent(document, \"phx:update\");\n      added.forEach(el => this.trackAfter(\"added\", el));\n      updates.forEach(el => this.trackAfter(\"updated\", el));\n\n      if (pendingRemoves.length > 0) {\n        liveSocket.transitionRemoves(pendingRemoves);\n        liveSocket.requestDOMUpdate(() => {\n          pendingRemoves.forEach(el => {\n            let child = dom_default.firstPhxChild(el);\n\n            if (child) {\n              liveSocket.destroyViewByEl(child);\n            }\n\n            el.remove();\n          });\n          this.trackAfter(\"transitionsDiscarded\", pendingRemoves);\n        });\n      }\n\n      if (externalFormTriggered) {\n        liveSocket.disconnect();\n        externalFormTriggered.submit();\n      }\n\n      return true;\n    }\n\n    isCIDPatch() {\n      return this.cidPatch;\n    }\n\n    skipCIDSibling(el) {\n      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;\n    }\n\n    targetCIDContainer(html) {\n      if (!this.isCIDPatch()) {\n        return;\n      }\n\n      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);\n\n      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {\n        return first;\n      } else {\n        return first && first.parentNode;\n      }\n    }\n\n    buildDiffHTML(container, html, phxUpdate, targetContainer) {\n      let isCIDPatch = this.isCIDPatch();\n      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();\n\n      if (!isCIDPatch || isCIDWithSingleRoot) {\n        return html;\n      } else {\n        let diffContainer = null;\n        let template = document.createElement(\"template\");\n        diffContainer = dom_default.cloneNode(targetContainer);\n        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);\n        template.innerHTML = html;\n        rest.forEach(el => el.remove());\n        Array.from(diffContainer.childNodes).forEach(child => {\n          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n        });\n        Array.from(template.content.childNodes).forEach(el => diffContainer.insertBefore(el, firstComponent));\n        firstComponent.remove();\n        return diffContainer.outerHTML;\n      }\n    }\n\n  }; // js/phoenix_live_view/rendered.js\n\n  var Rendered = class {\n    static extract(diff) {\n      let {\n        [REPLY]: reply,\n        [EVENTS]: events,\n        [TITLE]: title\n      } = diff;\n      delete diff[REPLY];\n      delete diff[EVENTS];\n      delete diff[TITLE];\n      return {\n        diff,\n        title,\n        reply: reply || null,\n        events: events || []\n      };\n    }\n\n    constructor(viewId, rendered) {\n      this.viewId = viewId;\n      this.rendered = {};\n      this.mergeDiff(rendered);\n    }\n\n    parentViewId() {\n      return this.viewId;\n    }\n\n    toString(onlyCids) {\n      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);\n    }\n\n    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {\n      onlyCids = onlyCids ? new Set(onlyCids) : null;\n      let output = {\n        buffer: \"\",\n        components,\n        onlyCids\n      };\n      this.toOutputBuffer(rendered, null, output);\n      return output.buffer;\n    }\n\n    componentCIDs(diff) {\n      return Object.keys(diff[COMPONENTS] || {}).map(i => parseInt(i));\n    }\n\n    isComponentOnlyDiff(diff) {\n      if (!diff[COMPONENTS]) {\n        return false;\n      }\n\n      return Object.keys(diff).length === 1;\n    }\n\n    getComponent(diff, cid) {\n      return diff[COMPONENTS][cid];\n    }\n\n    mergeDiff(diff) {\n      let newc = diff[COMPONENTS];\n      let cache = {};\n      delete diff[COMPONENTS];\n      this.rendered = this.mutableMerge(this.rendered, diff);\n      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n\n      if (newc) {\n        let oldc = this.rendered[COMPONENTS];\n\n        for (let cid in newc) {\n          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\n        }\n\n        for (let cid in newc) {\n          oldc[cid] = newc[cid];\n        }\n\n        diff[COMPONENTS] = newc;\n      }\n    }\n\n    cachedFindComponent(cid, cdiff, oldc, newc, cache) {\n      if (cache[cid]) {\n        return cache[cid];\n      } else {\n        let ndiff,\n            stat,\n            scid = cdiff[STATIC];\n\n        if (isCid(scid)) {\n          let tdiff;\n\n          if (scid > 0) {\n            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\n          } else {\n            tdiff = oldc[-scid];\n          }\n\n          stat = tdiff[STATIC];\n          ndiff = this.cloneMerge(tdiff, cdiff);\n          ndiff[STATIC] = stat;\n        } else {\n          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);\n        }\n\n        cache[cid] = ndiff;\n        return ndiff;\n      }\n    }\n\n    mutableMerge(target, source) {\n      if (source[STATIC] !== void 0) {\n        return source;\n      } else {\n        this.doMutableMerge(target, source);\n        return target;\n      }\n    }\n\n    doMutableMerge(target, source) {\n      for (let key in source) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          this.doMutableMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    cloneMerge(target, source) {\n      let merged = __spreadValues(__spreadValues({}, target), source);\n\n      for (let key in merged) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          merged[key] = this.cloneMerge(targetVal, val);\n        }\n      }\n\n      return merged;\n    }\n\n    componentToString(cid) {\n      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);\n    }\n\n    pruneCIDs(cids) {\n      cids.forEach(cid => delete this.rendered[COMPONENTS][cid]);\n    }\n\n    get() {\n      return this.rendered;\n    }\n\n    isNewFingerprint(diff = {}) {\n      return !!diff[STATIC];\n    }\n\n    templateStatic(part, templates) {\n      if (typeof part === \"number\") {\n        return templates[part];\n      } else {\n        return part;\n      }\n    }\n\n    toOutputBuffer(rendered, templates, output) {\n      if (rendered[DYNAMICS]) {\n        return this.comprehensionToBuffer(rendered, templates, output);\n      }\n\n      let {\n        [STATIC]: statics\n      } = rendered;\n      statics = this.templateStatic(statics, templates);\n      output.buffer += statics[0];\n\n      for (let i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(rendered[i - 1], templates, output);\n        output.buffer += statics[i];\n      }\n    }\n\n    comprehensionToBuffer(rendered, templates, output) {\n      let {\n        [DYNAMICS]: dynamics,\n        [STATIC]: statics\n      } = rendered;\n      statics = this.templateStatic(statics, templates);\n      let compTemplates = templates || rendered[TEMPLATES];\n\n      for (let d = 0; d < dynamics.length; d++) {\n        let dynamic = dynamics[d];\n        output.buffer += statics[0];\n\n        for (let i = 1; i < statics.length; i++) {\n          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);\n          output.buffer += statics[i];\n        }\n      }\n    }\n\n    dynamicToBuffer(rendered, templates, output) {\n      if (typeof rendered === \"number\") {\n        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);\n      } else if (isObject(rendered)) {\n        this.toOutputBuffer(rendered, templates, output);\n      } else {\n        output.buffer += rendered;\n      }\n    }\n\n    recursiveCIDToString(components, cid, onlyCids) {\n      let component = components[cid] || logError(`no component for CID ${cid}`, components);\n      let template = document.createElement(\"template\");\n      template.innerHTML = this.recursiveToString(component, components, onlyCids);\n      let container = template.content;\n      let skip = onlyCids && !onlyCids.has(cid);\n      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          if (child.getAttribute(PHX_COMPONENT)) {\n            return [hasNodes, true];\n          }\n\n          child.setAttribute(PHX_COMPONENT, cid);\n\n          if (!child.id) {\n            child.id = `${this.parentViewId()}-${cid}-${i}`;\n          }\n\n          if (skip) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n\n          return [true, hasComponents];\n        } else {\n          if (child.nodeValue.trim() !== \"\") {\n            logError(`only HTML element tags are allowed at the root of components.\n\ngot: \"${child.nodeValue.trim()}\"\n\nwithin:\n`, template.innerHTML.trim());\n            child.replaceWith(this.createSpan(child.nodeValue, cid));\n            return [true, hasComponents];\n          } else {\n            child.remove();\n            return [hasNodes, hasComponents];\n          }\n        }\n      }, [false, false]);\n\n      if (!hasChildNodes && !hasChildComponents) {\n        logError(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", template.innerHTML.trim());\n        return this.createSpan(\"\", cid).outerHTML;\n      } else if (!hasChildNodes && hasChildComponents) {\n        logError(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", template.innerHTML.trim());\n        return template.innerHTML;\n      } else {\n        return template.innerHTML;\n      }\n    }\n\n    createSpan(text, cid) {\n      let span = document.createElement(\"span\");\n      span.innerText = text;\n      span.setAttribute(PHX_COMPONENT, cid);\n      return span;\n    }\n\n  }; // js/phoenix_live_view/view_hook.js\n\n  var viewHookID = 1;\n  var ViewHook = class {\n    static makeID() {\n      return viewHookID++;\n    }\n\n    static elementID(el) {\n      return el.phxHookId;\n    }\n\n    constructor(view, el, callbacks) {\n      this.__view = view;\n      this.liveSocket = view.liveSocket;\n      this.__callbacks = callbacks;\n      this.__listeners = new Set();\n      this.__isDisconnected = false;\n      this.el = el;\n      this.el.phxHookId = this.constructor.makeID();\n\n      for (let key in this.__callbacks) {\n        this[key] = this.__callbacks[key];\n      }\n    }\n\n    __mounted() {\n      this.mounted && this.mounted();\n    }\n\n    __updated() {\n      this.updated && this.updated();\n    }\n\n    __beforeUpdate() {\n      this.beforeUpdate && this.beforeUpdate();\n    }\n\n    __destroyed() {\n      this.destroyed && this.destroyed();\n    }\n\n    __reconnected() {\n      if (this.__isDisconnected) {\n        this.__isDisconnected = false;\n        this.reconnected && this.reconnected();\n      }\n    }\n\n    __disconnected() {\n      this.__isDisconnected = true;\n      this.disconnected && this.disconnected();\n    }\n\n    pushEvent(event, payload = {}, onReply = function () {}) {\n      return this.__view.pushHookEvent(null, event, payload, onReply);\n    }\n\n    pushEventTo(phxTarget, event, payload = {}, onReply = function () {}) {\n      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {\n        return view.pushHookEvent(targetCtx, event, payload, onReply);\n      });\n    }\n\n    handleEvent(event, callback) {\n      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);\n\n      window.addEventListener(`phx:${event}`, callbackRef);\n\n      this.__listeners.add(callbackRef);\n\n      return callbackRef;\n    }\n\n    removeHandleEvent(callbackRef) {\n      let event = callbackRef(null, true);\n      window.removeEventListener(`phx:${event}`, callbackRef);\n\n      this.__listeners.delete(callbackRef);\n    }\n\n    upload(name, files) {\n      return this.__view.dispatchUploads(name, files);\n    }\n\n    uploadTo(phxTarget, name, files) {\n      return this.__view.withinTargets(phxTarget, view => view.dispatchUploads(name, files));\n    }\n\n    __cleanup__() {\n      this.__listeners.forEach(callbackRef => this.removeHandleEvent(callbackRef));\n    }\n\n  }; // js/phoenix_live_view/js.js\n\n  var JS = {\n    exec(eventType, phxEvent, view, sourceEl, defaults) {\n      let [defaultKind, defaultArgs] = defaults || [null, {}];\n      let commands = phxEvent.charAt(0) === \"[\" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];\n      commands.forEach(([kind, args]) => {\n        if (kind === defaultKind && defaultArgs.data) {\n          args.data = Object.assign(args.data || {}, defaultArgs.data);\n        }\n\n        this.filterToEls(sourceEl, args).forEach(el => {\n          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);\n        });\n      });\n    },\n\n    isVisible(el) {\n      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);\n    },\n\n    exec_dispatch(eventType, phxEvent, view, sourceEl, el, {\n      to,\n      event,\n      detail,\n      bubbles\n    }) {\n      detail = detail || {};\n      detail.dispatcher = sourceEl;\n      dom_default.dispatchEvent(el, event, {\n        detail,\n        bubbles\n      });\n    },\n\n    exec_push(eventType, phxEvent, view, sourceEl, el, args) {\n      if (!view.isConnected()) {\n        return;\n      }\n\n      let {\n        event,\n        data,\n        target,\n        page_loading,\n        loading,\n        value,\n        dispatcher\n      } = args;\n      let pushOpts = {\n        loading,\n        value,\n        target,\n        page_loading: !!page_loading\n      };\n      let targetSrc = eventType === \"change\" && dispatcher ? dispatcher : sourceEl;\n      let phxTarget = target || targetSrc.getAttribute(view.binding(\"target\")) || targetSrc;\n      view.withinTargets(phxTarget, (targetView, targetCtx) => {\n        if (eventType === \"change\") {\n          let {\n            newCid,\n            _target,\n            callback\n          } = args;\n          _target = _target || (sourceEl instanceof HTMLInputElement ? sourceEl.name : void 0);\n\n          if (_target) {\n            pushOpts._target = _target;\n          }\n\n          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);\n        } else if (eventType === \"submit\") {\n          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);\n        } else {\n          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);\n        }\n      });\n    },\n\n    exec_add_class(eventType, phxEvent, view, sourceEl, el, {\n      names,\n      transition,\n      time\n    }) {\n      this.addOrRemoveClasses(el, names, [], transition, time, view);\n    },\n\n    exec_remove_class(eventType, phxEvent, view, sourceEl, el, {\n      names,\n      transition,\n      time\n    }) {\n      this.addOrRemoveClasses(el, [], names, transition, time, view);\n    },\n\n    exec_transition(eventType, phxEvent, view, sourceEl, el, {\n      time,\n      transition\n    }) {\n      let [transition_start, running, transition_end] = transition;\n\n      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);\n\n      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));\n\n      view.transition(time, onStart, onDone);\n    },\n\n    exec_toggle(eventType, phxEvent, view, sourceEl, el, {\n      display,\n      ins,\n      outs,\n      time\n    }) {\n      this.toggle(eventType, view, el, display, ins, outs, time);\n    },\n\n    exec_show(eventType, phxEvent, view, sourceEl, el, {\n      display,\n      transition,\n      time\n    }) {\n      this.show(eventType, view, el, display, transition, time);\n    },\n\n    exec_hide(eventType, phxEvent, view, sourceEl, el, {\n      display,\n      transition,\n      time\n    }) {\n      this.hide(eventType, view, el, display, transition, time);\n    },\n\n    exec_set_attr(eventType, phxEvent, view, sourceEl, el, {\n      attr: [attr, val]\n    }) {\n      this.setOrRemoveAttrs(el, [[attr, val]], []);\n    },\n\n    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, {\n      attr\n    }) {\n      this.setOrRemoveAttrs(el, [], [attr]);\n    },\n\n    show(eventType, view, el, display, transition, time) {\n      if (!this.isVisible(el)) {\n        this.toggle(eventType, view, el, display, transition, null, time);\n      }\n    },\n\n    hide(eventType, view, el, display, transition, time) {\n      if (this.isVisible(el)) {\n        this.toggle(eventType, view, el, display, null, transition, time);\n      }\n    },\n\n    toggle(eventType, view, el, display, ins, outs, time) {\n      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];\n      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];\n\n      if (inClasses.length > 0 || outClasses.length > 0) {\n        if (this.isVisible(el)) {\n          let onStart = () => {\n            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));\n            window.requestAnimationFrame(() => {\n              this.addOrRemoveClasses(el, outClasses, []);\n              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));\n            });\n          };\n\n          el.dispatchEvent(new Event(\"phx:hide-start\"));\n          view.transition(time, onStart, () => {\n            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));\n            dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = \"none\");\n            el.dispatchEvent(new Event(\"phx:hide-end\"));\n          });\n        } else {\n          if (eventType === \"remove\") {\n            return;\n          }\n\n          let onStart = () => {\n            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));\n            dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = display || \"block\");\n            window.requestAnimationFrame(() => {\n              this.addOrRemoveClasses(el, inClasses, []);\n              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));\n            });\n          };\n\n          el.dispatchEvent(new Event(\"phx:show-start\"));\n          view.transition(time, onStart, () => {\n            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));\n            el.dispatchEvent(new Event(\"phx:show-end\"));\n          });\n        }\n      } else {\n        if (this.isVisible(el)) {\n          window.requestAnimationFrame(() => {\n            el.dispatchEvent(new Event(\"phx:hide-start\"));\n            dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = \"none\");\n            el.dispatchEvent(new Event(\"phx:hide-end\"));\n          });\n        } else {\n          window.requestAnimationFrame(() => {\n            el.dispatchEvent(new Event(\"phx:show-start\"));\n            dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = display || \"block\");\n            el.dispatchEvent(new Event(\"phx:show-end\"));\n          });\n        }\n      }\n    },\n\n    addOrRemoveClasses(el, adds, removes, transition, time, view) {\n      let [transition_run, transition_start, transition_end] = transition || [[], [], []];\n\n      if (transition_run.length > 0) {\n        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);\n\n        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));\n\n        return view.transition(time, onStart, onDone);\n      }\n\n      window.requestAnimationFrame(() => {\n        let [prevAdds, prevRemoves] = dom_default.getSticky(el, \"classes\", [[], []]);\n        let keepAdds = adds.filter(name => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));\n        let keepRemoves = removes.filter(name => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));\n        let newAdds = prevAdds.filter(name => removes.indexOf(name) < 0).concat(keepAdds);\n        let newRemoves = prevRemoves.filter(name => adds.indexOf(name) < 0).concat(keepRemoves);\n        dom_default.putSticky(el, \"classes\", currentEl => {\n          currentEl.classList.remove(...newRemoves);\n          currentEl.classList.add(...newAdds);\n          return [newAdds, newRemoves];\n        });\n      });\n    },\n\n    setOrRemoveAttrs(el, sets, removes) {\n      let [prevSets, prevRemoves] = dom_default.getSticky(el, \"attrs\", [[], []]);\n      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);\n      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);\n      let newRemoves = prevRemoves.filter(attr => !alteredAttrs.includes(attr)).concat(removes);\n      dom_default.putSticky(el, \"attrs\", currentEl => {\n        newRemoves.forEach(attr => currentEl.removeAttribute(attr));\n        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));\n        return [newSets, newRemoves];\n      });\n    },\n\n    hasAllClasses(el, classes) {\n      return classes.every(name => el.classList.contains(name));\n    },\n\n    isToggledOut(el, outClasses) {\n      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);\n    },\n\n    filterToEls(sourceEl, {\n      to\n    }) {\n      return to ? dom_default.all(document, to) : [sourceEl];\n    }\n\n  };\n  var js_default = JS; // js/phoenix_live_view/view.js\n\n  var serializeForm = (form, meta, onlyNames = []) => {\n    let formData = new FormData(form);\n    let toRemove = [];\n    formData.forEach((val, key, _index) => {\n      if (val instanceof File) {\n        toRemove.push(key);\n      }\n    });\n    toRemove.forEach(key => formData.delete(key));\n    let params = new URLSearchParams();\n\n    for (let [key, val] of formData.entries()) {\n      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {\n        params.append(key, val);\n      }\n    }\n\n    for (let metaKey in meta) {\n      params.append(metaKey, meta[metaKey]);\n    }\n\n    return params.toString();\n  };\n\n  var View = class {\n    constructor(el, liveSocket, parentView, flash) {\n      this.liveSocket = liveSocket;\n      this.flash = flash;\n      this.parent = parentView;\n      this.root = parentView ? parentView.root : this;\n      this.el = el;\n      this.id = this.el.id;\n      this.ref = 0;\n      this.childJoins = 0;\n      this.loaderTimer = null;\n      this.pendingDiffs = [];\n      this.pruningCIDs = [];\n      this.redirect = false;\n      this.href = null;\n      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n      this.joinPending = true;\n      this.destroyed = false;\n\n      this.joinCallback = function (onDone) {\n        onDone && onDone();\n      };\n\n      this.stopCallback = function () {};\n\n      this.pendingJoinOps = this.parent ? null : [];\n      this.viewHooks = {};\n      this.uploaders = {};\n      this.formSubmits = [];\n      this.children = this.parent ? null : {};\n      this.root.children[this.id] = {};\n      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n        return {\n          redirect: this.redirect ? this.href : void 0,\n          url: this.redirect ? void 0 : this.href || void 0,\n          params: this.connectParams(),\n          session: this.getSession(),\n          static: this.getStatic(),\n          flash: this.flash\n        };\n      });\n      this.showLoader(this.liveSocket.loaderTimeout);\n      this.bindChannel();\n    }\n\n    setHref(href) {\n      this.href = href;\n    }\n\n    setRedirect(href) {\n      this.redirect = true;\n      this.href = href;\n    }\n\n    isMain() {\n      return this.el.getAttribute(PHX_MAIN) !== null;\n    }\n\n    connectParams() {\n      let params = this.liveSocket.params(this.el);\n      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map(node => node.src || node.href).filter(url => typeof url === \"string\");\n\n      if (manifest.length > 0) {\n        params[\"_track_static\"] = manifest;\n      }\n\n      params[\"_mounts\"] = this.joinCount;\n      return params;\n    }\n\n    isConnected() {\n      return this.channel.canPush();\n    }\n\n    getSession() {\n      return this.el.getAttribute(PHX_SESSION);\n    }\n\n    getStatic() {\n      let val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n\n    destroy(callback = function () {}) {\n      this.destroyAllChildren();\n      this.destroyed = true;\n      delete this.root.children[this.id];\n\n      if (this.parent) {\n        delete this.root.children[this.parent.id][this.id];\n      }\n\n      clearTimeout(this.loaderTimer);\n\n      let onFinished = () => {\n        callback();\n\n        for (let id in this.viewHooks) {\n          this.destroyHook(this.viewHooks[id]);\n        }\n      };\n\n      dom_default.markPhxChildDestroyed(this.el);\n      this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\n      this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n    }\n\n    setContainerClasses(...classes) {\n      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n      this.el.classList.add(...classes);\n    }\n\n    showLoader(timeout) {\n      clearTimeout(this.loaderTimer);\n\n      if (timeout) {\n        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\n      } else {\n        for (let id in this.viewHooks) {\n          this.viewHooks[id].__disconnected();\n        }\n\n        this.setContainerClasses(PHX_DISCONNECTED_CLASS);\n      }\n    }\n\n    hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.setContainerClasses(PHX_CONNECTED_CLASS);\n    }\n\n    triggerReconnected() {\n      for (let id in this.viewHooks) {\n        this.viewHooks[id].__reconnected();\n      }\n    }\n\n    log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n\n    transition(time, onStart, onDone = function () {}) {\n      this.liveSocket.transition(time, onStart, onDone);\n    }\n\n    withinTargets(phxTarget, callback) {\n      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {\n        return this.liveSocket.owner(phxTarget, view => callback(view, phxTarget));\n      }\n\n      if (isCid(phxTarget)) {\n        let targets = dom_default.findComponentNodeList(this.el, phxTarget);\n\n        if (targets.length === 0) {\n          logError(`no component found matching phx-target of ${phxTarget}`);\n        } else {\n          callback(this, parseInt(phxTarget));\n        }\n      } else {\n        let targets = Array.from(document.querySelectorAll(phxTarget));\n\n        if (targets.length === 0) {\n          logError(`nothing found matching the phx-target selector \"${phxTarget}\"`);\n        }\n\n        targets.forEach(target => this.liveSocket.owner(target, view => callback(view, target)));\n      }\n    }\n\n    applyDiff(type, rawDiff, callback) {\n      this.log(type, () => [\"\", clone(rawDiff)]);\n      let {\n        diff,\n        reply,\n        events,\n        title\n      } = Rendered.extract(rawDiff);\n\n      if (title) {\n        dom_default.putTitle(title);\n      }\n\n      callback({\n        diff,\n        reply,\n        events\n      });\n      return reply;\n    }\n\n    onJoin(resp) {\n      let {\n        rendered,\n        container\n      } = resp;\n\n      if (container) {\n        let [tag, attrs] = container;\n        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);\n      }\n\n      this.childJoins = 0;\n      this.joinPending = true;\n      this.flash = null;\n      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);\n      this.applyDiff(\"mount\", rendered, ({\n        diff,\n        events\n      }) => {\n        this.rendered = new Rendered(this.id, diff);\n        let html = this.renderContainer(null, \"join\");\n        this.dropPendingRefs();\n        let forms = this.formsForRecovery(html);\n        this.joinCount++;\n\n        if (forms.length > 0) {\n          forms.forEach(([form, newForm, newCid], i) => {\n            this.pushFormRecovery(form, newCid, resp2 => {\n              if (i === forms.length - 1) {\n                this.onJoinComplete(resp2, html, events);\n              }\n            });\n          });\n        } else {\n          this.onJoinComplete(resp, html, events);\n        }\n      });\n    }\n\n    dropPendingRefs() {\n      dom_default.all(document, `[${PHX_REF_SRC}=\"${this.id}\"][${PHX_REF}]`, el => {\n        el.removeAttribute(PHX_REF);\n        el.removeAttribute(PHX_REF_SRC);\n      });\n    }\n\n    onJoinComplete({\n      live_patch\n    }, html, events) {\n      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\n        return this.applyJoinPatch(live_patch, html, events);\n      }\n\n      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter(toEl => {\n        let fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\n        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n\n        return this.joinChild(toEl);\n      });\n\n      if (newChildren.length === 0) {\n        if (this.parent) {\n          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n          this.applyJoinPatch(live_patch, html, events);\n        }\n      } else {\n        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n      }\n    }\n\n    attachTrueDocEl() {\n      this.el = dom_default.byId(this.id);\n      this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n    }\n\n    applyJoinPatch(live_patch, html, events) {\n      this.attachTrueDocEl();\n      let patch = new DOMPatch(this, this.el, this.id, html, null);\n      patch.markPrunableContentForRemoval();\n      this.performPatch(patch, false);\n      this.joinNewChildren();\n      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, hookEl => {\n        let hook = this.addHook(hookEl);\n\n        if (hook) {\n          hook.__mounted();\n        }\n      });\n      this.joinPending = false;\n      this.liveSocket.dispatchEvents(events);\n      this.applyPendingUpdates();\n\n      if (live_patch) {\n        let {\n          kind,\n          to\n        } = live_patch;\n        this.liveSocket.historyPatch(to, kind);\n      }\n\n      this.hideLoader();\n\n      if (this.joinCount > 1) {\n        this.triggerReconnected();\n      }\n\n      this.stopCallback();\n    }\n\n    triggerBeforeUpdateHook(fromEl, toEl) {\n      this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n      let hook = this.getHook(fromEl);\n      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));\n\n      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\n        hook.__beforeUpdate();\n\n        return hook;\n      }\n    }\n\n    performPatch(patch, pruneCids) {\n      let removedEls = [];\n      let phxChildrenAdded = false;\n      let updatedHookIds = new Set();\n      patch.after(\"added\", el => {\n        this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\n        let newHook = this.addHook(el);\n\n        if (newHook) {\n          newHook.__mounted();\n        }\n      });\n      patch.after(\"phxChildAdded\", el => {\n        if (dom_default.isPhxSticky(el)) {\n          this.liveSocket.joinRootViews();\n        } else {\n          phxChildrenAdded = true;\n        }\n      });\n      patch.before(\"updated\", (fromEl, toEl) => {\n        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);\n\n        if (hook) {\n          updatedHookIds.add(fromEl.id);\n        }\n      });\n      patch.after(\"updated\", el => {\n        if (updatedHookIds.has(el.id)) {\n          this.getHook(el).__updated();\n        }\n      });\n      patch.after(\"discarded\", el => {\n        if (el.nodeType === Node.ELEMENT_NODE) {\n          removedEls.push(el);\n        }\n      });\n      patch.after(\"transitionsDiscarded\", els => this.afterElementsRemoved(els, pruneCids));\n      patch.perform();\n      this.afterElementsRemoved(removedEls, pruneCids);\n      return phxChildrenAdded;\n    }\n\n    afterElementsRemoved(elements, pruneCids) {\n      let destroyedCIDs = [];\n      elements.forEach(parent => {\n        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);\n        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);\n        components.concat(parent).forEach(el => {\n          let cid = this.componentID(el);\n\n          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {\n            destroyedCIDs.push(cid);\n          }\n        });\n        hooks.concat(parent).forEach(hookEl => {\n          let hook = this.getHook(hookEl);\n          hook && this.destroyHook(hook);\n        });\n      });\n\n      if (pruneCids) {\n        this.maybePushComponentsDestroyed(destroyedCIDs);\n      }\n    }\n\n    joinNewChildren() {\n      dom_default.findPhxChildren(this.el, this.id).forEach(el => this.joinChild(el));\n    }\n\n    getChildById(id) {\n      return this.root.children[this.id][id];\n    }\n\n    getDescendentByEl(el) {\n      if (el.id === this.id) {\n        return this;\n      } else {\n        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];\n      }\n    }\n\n    destroyDescendent(id) {\n      for (let parentId in this.root.children) {\n        for (let childId in this.root.children[parentId]) {\n          if (childId === id) {\n            return this.root.children[parentId][childId].destroy();\n          }\n        }\n      }\n    }\n\n    joinChild(el) {\n      let child = this.getChildById(el.id);\n\n      if (!child) {\n        let view = new View(el, this.liveSocket, this);\n        this.root.children[this.id][view.id] = view;\n        view.join();\n        this.childJoins++;\n        return true;\n      }\n    }\n\n    isJoinPending() {\n      return this.joinPending;\n    }\n\n    ackJoin(_child) {\n      this.childJoins--;\n\n      if (this.childJoins === 0) {\n        if (this.parent) {\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n        }\n      }\n    }\n\n    onAllChildJoinsComplete() {\n      this.joinCallback(() => {\n        this.pendingJoinOps.forEach(([view, op]) => {\n          if (!view.isDestroyed()) {\n            op();\n          }\n        });\n        this.pendingJoinOps = [];\n      });\n    }\n\n    update(diff, events) {\n      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !dom_default.isPhxSticky(this.el)) {\n        return this.pendingDiffs.push({\n          diff,\n          events\n        });\n      }\n\n      this.rendered.mergeDiff(diff);\n      let phxChildrenAdded = false;\n\n      if (this.rendered.isComponentOnlyDiff(diff)) {\n        this.liveSocket.time(\"component patch complete\", () => {\n          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));\n          parentCids.forEach(parentCID => {\n            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {\n              phxChildrenAdded = true;\n            }\n          });\n        });\n      } else if (!isEmpty(diff)) {\n        this.liveSocket.time(\"full patch complete\", () => {\n          let html = this.renderContainer(diff, \"update\");\n          let patch = new DOMPatch(this, this.el, this.id, html, null);\n          phxChildrenAdded = this.performPatch(patch, true);\n        });\n      }\n\n      this.liveSocket.dispatchEvents(events);\n\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n\n    renderContainer(diff, kind) {\n      return this.liveSocket.time(`toString diff (${kind})`, () => {\n        let tag = this.el.tagName;\n        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;\n        let html = this.rendered.toString(cids);\n        return `<${tag}>${html}</${tag}>`;\n      });\n    }\n\n    componentPatch(diff, cid) {\n      if (isEmpty(diff)) return false;\n      let html = this.rendered.componentToString(cid);\n      let patch = new DOMPatch(this, this.el, this.id, html, cid);\n      let childrenAdded = this.performPatch(patch, true);\n      return childrenAdded;\n    }\n\n    getHook(el) {\n      return this.viewHooks[ViewHook.elementID(el)];\n    }\n\n    addHook(el) {\n      if (ViewHook.elementID(el) || !el.getAttribute) {\n        return;\n      }\n\n      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));\n\n      if (hookName && !this.ownsElement(el)) {\n        return;\n      }\n\n      let callbacks = this.liveSocket.getHookCallbacks(hookName);\n\n      if (callbacks) {\n        if (!el.id) {\n          logError(`no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`, el);\n        }\n\n        let hook = new ViewHook(this, el, callbacks);\n        this.viewHooks[ViewHook.elementID(hook.el)] = hook;\n        return hook;\n      } else if (hookName !== null) {\n        logError(`unknown hook found for \"${hookName}\"`, el);\n      }\n    }\n\n    destroyHook(hook) {\n      hook.__destroyed();\n\n      hook.__cleanup__();\n\n      delete this.viewHooks[ViewHook.elementID(hook.el)];\n    }\n\n    applyPendingUpdates() {\n      this.pendingDiffs.forEach(({\n        diff,\n        events\n      }) => this.update(diff, events));\n      this.pendingDiffs = [];\n    }\n\n    onChannel(event, cb) {\n      this.liveSocket.onChannel(this.channel, event, resp => {\n        if (this.isJoinPending()) {\n          this.root.pendingJoinOps.push([this, () => cb(resp)]);\n        } else {\n          this.liveSocket.requestDOMUpdate(() => cb(resp));\n        }\n      });\n    }\n\n    bindChannel() {\n      this.liveSocket.onChannel(this.channel, \"diff\", rawDiff => {\n        this.liveSocket.requestDOMUpdate(() => {\n          this.applyDiff(\"update\", rawDiff, ({\n            diff,\n            events\n          }) => this.update(diff, events));\n        });\n      });\n      this.onChannel(\"redirect\", ({\n        to,\n        flash\n      }) => this.onRedirect({\n        to,\n        flash\n      }));\n      this.onChannel(\"live_patch\", redir => this.onLivePatch(redir));\n      this.onChannel(\"live_redirect\", redir => this.onLiveRedirect(redir));\n      this.channel.onError(reason => this.onError(reason));\n      this.channel.onClose(reason => this.onClose(reason));\n    }\n\n    destroyAllChildren() {\n      for (let id in this.root.children[this.id]) {\n        this.getChildById(id).destroy();\n      }\n    }\n\n    onLiveRedirect(redir) {\n      let {\n        to,\n        kind,\n        flash\n      } = redir;\n      let url = this.expandURL(to);\n      this.liveSocket.historyRedirect(url, kind, flash);\n    }\n\n    onLivePatch(redir) {\n      let {\n        to,\n        kind\n      } = redir;\n      this.href = this.expandURL(to);\n      this.liveSocket.historyPatch(to, kind);\n    }\n\n    expandURL(to) {\n      return to.startsWith(\"/\") ? `${window.location.protocol}//${window.location.host}${to}` : to;\n    }\n\n    onRedirect({\n      to,\n      flash\n    }) {\n      this.liveSocket.redirect(to, flash);\n    }\n\n    isDestroyed() {\n      return this.destroyed;\n    }\n\n    join(callback) {\n      if (this.isMain()) {\n        this.stopCallback = this.liveSocket.withPageLoading({\n          to: this.href,\n          kind: \"initial\"\n        });\n      }\n\n      this.joinCallback = onDone => {\n        onDone = onDone || function () {};\n\n        callback ? callback(this.joinCount, onDone) : onDone();\n      };\n\n      this.liveSocket.wrapPush(this, {\n        timeout: false\n      }, () => {\n        return this.channel.join().receive(\"ok\", data => {\n          if (!this.isDestroyed()) {\n            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));\n          }\n        }).receive(\"error\", resp => !this.isDestroyed() && this.onJoinError(resp)).receive(\"timeout\", () => !this.isDestroyed() && this.onJoinError({\n          reason: \"timeout\"\n        }));\n      });\n    }\n\n    onJoinError(resp) {\n      if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\n        this.log(\"error\", () => [\"unauthorized live_redirect. Falling back to page request\", resp]);\n        return this.onRedirect({\n          to: this.href\n        });\n      }\n\n      if (resp.redirect || resp.live_redirect) {\n        this.joinPending = false;\n        this.channel.leave();\n      }\n\n      if (resp.redirect) {\n        return this.onRedirect(resp.redirect);\n      }\n\n      if (resp.live_redirect) {\n        return this.onLiveRedirect(resp.live_redirect);\n      }\n\n      this.log(\"error\", () => [\"unable to join\", resp]);\n\n      if (this.liveSocket.isConnected()) {\n        this.liveSocket.reloadWithJitter(this);\n      }\n    }\n\n    onClose(reason) {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      if (this.liveSocket.hasPendingLink() && reason !== \"leave\") {\n        return this.liveSocket.reloadWithJitter(this);\n      }\n\n      this.destroyAllChildren();\n      this.liveSocket.dropActiveElement(this);\n\n      if (document.activeElement) {\n        document.activeElement.blur();\n      }\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n      }\n    }\n\n    onError(reason) {\n      this.onClose(reason);\n\n      if (this.liveSocket.isConnected()) {\n        this.log(\"error\", () => [\"view crashed\", reason]);\n      }\n\n      if (!this.liveSocket.isUnloaded()) {\n        this.displayError();\n      }\n    }\n\n    displayError() {\n      if (this.isMain()) {\n        dom_default.dispatchEvent(window, \"phx:page-loading-start\", {\n          detail: {\n            to: this.href,\n            kind: \"error\"\n          }\n        });\n      }\n\n      this.showLoader();\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n    }\n\n    pushWithReply(refGenerator, event, payload, onReply = function () {}) {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];\n\n      let onLoadingDone = function () {};\n\n      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {\n        onLoadingDone = this.liveSocket.withPageLoading({\n          kind: \"element\",\n          target: el\n        });\n      }\n\n      if (typeof payload.cid !== \"number\") {\n        delete payload.cid;\n      }\n\n      return this.liveSocket.wrapPush(this, {\n        timeout: true\n      }, () => {\n        return this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", resp => {\n          if (ref !== null) {\n            this.undoRefs(ref);\n          }\n\n          let finish = hookReply => {\n            if (resp.redirect) {\n              this.onRedirect(resp.redirect);\n            }\n\n            if (resp.live_patch) {\n              this.onLivePatch(resp.live_patch);\n            }\n\n            if (resp.live_redirect) {\n              this.onLiveRedirect(resp.live_redirect);\n            }\n\n            onLoadingDone();\n            onReply(resp, hookReply);\n          };\n\n          if (resp.diff) {\n            this.liveSocket.requestDOMUpdate(() => {\n              let hookReply = this.applyDiff(\"update\", resp.diff, ({\n                diff,\n                events\n              }) => {\n                this.update(diff, events);\n              });\n              finish(hookReply);\n            });\n          } else {\n            finish(null);\n          }\n        });\n      });\n    }\n\n    undoRefs(ref) {\n      dom_default.all(document, `[${PHX_REF_SRC}=\"${this.id}\"][${PHX_REF}=\"${ref}\"]`, el => {\n        let disabledVal = el.getAttribute(PHX_DISABLED);\n        el.removeAttribute(PHX_REF);\n        el.removeAttribute(PHX_REF_SRC);\n\n        if (el.getAttribute(PHX_READONLY) !== null) {\n          el.readOnly = false;\n          el.removeAttribute(PHX_READONLY);\n        }\n\n        if (disabledVal !== null) {\n          el.disabled = disabledVal === \"true\" ? true : false;\n          el.removeAttribute(PHX_DISABLED);\n        }\n\n        PHX_EVENT_CLASSES.forEach(className => dom_default.removeClass(el, className));\n        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n\n        if (disableRestore !== null) {\n          el.innerText = disableRestore;\n          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n        }\n\n        let toEl = dom_default.private(el, PHX_REF);\n\n        if (toEl) {\n          let hook = this.triggerBeforeUpdateHook(el, toEl);\n          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());\n\n          if (hook) {\n            hook.__updated();\n          }\n\n          dom_default.deletePrivate(el, PHX_REF);\n        }\n      });\n    }\n\n    putRef(elements, event, opts = {}) {\n      let newRef = this.ref++;\n      let disableWith = this.binding(PHX_DISABLE_WITH);\n\n      if (opts.loading) {\n        elements = elements.concat(dom_default.all(document, opts.loading));\n      }\n\n      elements.forEach(el => {\n        el.classList.add(`phx-${event}-loading`);\n        el.setAttribute(PHX_REF, newRef);\n        el.setAttribute(PHX_REF_SRC, this.el.id);\n        let disableText = el.getAttribute(disableWith);\n\n        if (disableText !== null) {\n          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n          }\n\n          if (disableText !== \"\") {\n            el.innerText = disableText;\n          }\n\n          el.setAttribute(\"disabled\", \"\");\n        }\n      });\n      return [newRef, elements, opts];\n    }\n\n    componentID(el) {\n      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n      return cid ? parseInt(cid) : null;\n    }\n\n    targetComponentID(target, targetCtx, opts = {}) {\n      if (isCid(targetCtx)) {\n        return targetCtx;\n      }\n\n      let cidOrSelector = target.getAttribute(this.binding(\"target\"));\n\n      if (isCid(cidOrSelector)) {\n        return parseInt(cidOrSelector);\n      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {\n        return this.closestComponentID(targetCtx);\n      } else {\n        return null;\n      }\n    }\n\n    closestComponentID(targetCtx) {\n      if (isCid(targetCtx)) {\n        return targetCtx;\n      } else if (targetCtx) {\n        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), el => this.ownsElement(el) && this.componentID(el));\n      } else {\n        return null;\n      }\n    }\n\n    pushHookEvent(targetCtx, event, payload, onReply) {\n      if (!this.isConnected()) {\n        this.log(\"hook\", () => [\"unable to push hook event. LiveView not connected\", event, payload]);\n        return false;\n      }\n\n      let [ref, els, opts] = this.putRef([], \"hook\");\n      this.pushWithReply(() => [ref, els, opts], \"event\", {\n        type: \"hook\",\n        event,\n        value: payload,\n        cid: this.closestComponentID(targetCtx)\n      }, (resp, reply) => onReply(reply, ref));\n      return ref;\n    }\n\n    extractMeta(el, meta, value) {\n      let prefix = this.binding(\"value-\");\n\n      for (let i = 0; i < el.attributes.length; i++) {\n        if (!meta) {\n          meta = {};\n        }\n\n        let name = el.attributes[i].name;\n\n        if (name.startsWith(prefix)) {\n          meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n        }\n      }\n\n      if (el.value !== void 0) {\n        if (!meta) {\n          meta = {};\n        }\n\n        meta.value = el.value;\n\n        if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\n          delete meta.value;\n        }\n      }\n\n      if (value) {\n        if (!meta) {\n          meta = {};\n        }\n\n        for (let key in value) {\n          meta[key] = value[key];\n        }\n      }\n\n      return meta;\n    }\n\n    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {\n      this.pushWithReply(() => this.putRef([el], type, opts), \"event\", {\n        type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta, opts.value),\n        cid: this.targetComponentID(el, targetCtx, opts)\n      });\n    }\n\n    pushFileProgress(fileEl, entryRef, progress, onReply = function () {}) {\n      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\n        view.pushWithReply(null, \"progress\", {\n          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\n          ref: fileEl.getAttribute(PHX_UPLOAD_REF),\n          entry_ref: entryRef,\n          progress,\n          cid: view.targetComponentID(fileEl.form, targetCtx)\n        }, onReply);\n      });\n    }\n\n    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {\n      let uploads;\n      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);\n\n      let refGenerator = () => this.putRef([inputEl, inputEl.form], \"change\", opts);\n\n      let formData;\n\n      if (inputEl.getAttribute(this.binding(\"change\"))) {\n        formData = serializeForm(inputEl.form, {\n          _target: opts._target\n        }, [inputEl.name]);\n      } else {\n        formData = serializeForm(inputEl.form, {\n          _target: opts._target\n        });\n      }\n\n      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {\n        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\n      }\n\n      uploads = LiveUploader.serializeUploads(inputEl);\n      let event = {\n        type: \"form\",\n        event: phxEvent,\n        value: formData,\n        uploads,\n        cid\n      };\n      this.pushWithReply(refGenerator, \"event\", event, resp => {\n        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));\n\n        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute(\"data-phx-auto-upload\") !== null) {\n          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\n            let [ref, _els] = refGenerator();\n            this.uploadFiles(inputEl.form, targetCtx, ref, cid, _uploads => {\n              callback && callback(resp);\n              this.triggerAwaitingSubmit(inputEl.form);\n            });\n          }\n        } else {\n          callback && callback(resp);\n        }\n      });\n    }\n\n    triggerAwaitingSubmit(formEl) {\n      let awaitingSubmit = this.getScheduledSubmit(formEl);\n\n      if (awaitingSubmit) {\n        let [_el, _ref, _opts, callback] = awaitingSubmit;\n        this.cancelSubmit(formEl);\n        callback();\n      }\n    }\n\n    getScheduledSubmit(formEl) {\n      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));\n    }\n\n    scheduleSubmit(formEl, ref, opts, callback) {\n      if (this.getScheduledSubmit(formEl)) {\n        return true;\n      }\n\n      this.formSubmits.push([formEl, ref, opts, callback]);\n    }\n\n    cancelSubmit(formEl) {\n      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {\n        if (el.isSameNode(formEl)) {\n          this.undoRefs(ref);\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n\n    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {\n      let filterIgnored = el => {\n        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);\n        return !(userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form));\n      };\n\n      let filterDisables = el => {\n        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\n      };\n\n      let filterButton = el => el.tagName == \"BUTTON\";\n\n      let filterInput = el => [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\n\n      let refGenerator = () => {\n        let formElements = Array.from(formEl.elements);\n        let disables = formElements.filter(filterDisables);\n        let buttons = formElements.filter(filterButton).filter(filterIgnored);\n        let inputs = formElements.filter(filterInput).filter(filterIgnored);\n        buttons.forEach(button => {\n          button.setAttribute(PHX_DISABLED, button.disabled);\n          button.disabled = true;\n        });\n        inputs.forEach(input => {\n          input.setAttribute(PHX_READONLY, input.readOnly);\n          input.readOnly = true;\n\n          if (input.files) {\n            input.setAttribute(PHX_DISABLED, input.disabled);\n            input.disabled = true;\n          }\n        });\n        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), \"\");\n        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), \"submit\", opts);\n      };\n\n      let cid = this.targetComponentID(formEl, targetCtx);\n\n      if (LiveUploader.hasUploadsInProgress(formEl)) {\n        let [ref, _els] = refGenerator();\n\n        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);\n\n        return this.scheduleSubmit(formEl, ref, opts, push);\n      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n        let [ref, els] = refGenerator();\n\n        let proxyRefGen = () => [ref, els, opts];\n\n        this.uploadFiles(formEl, targetCtx, ref, cid, _uploads => {\n          let formData = serializeForm(formEl, {});\n          this.pushWithReply(proxyRefGen, \"event\", {\n            type: \"form\",\n            event: phxEvent,\n            value: formData,\n            cid\n          }, onReply);\n        });\n      } else {\n        let formData = serializeForm(formEl, {});\n        this.pushWithReply(refGenerator, \"event\", {\n          type: \"form\",\n          event: phxEvent,\n          value: formData,\n          cid\n        }, onReply);\n      }\n    }\n\n    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {\n      let joinCountAtUpload = this.joinCount;\n      let inputEls = LiveUploader.activeFileInputs(formEl);\n      let numFileInputsInProgress = inputEls.length;\n      inputEls.forEach(inputEl => {\n        let uploader = new LiveUploader(inputEl, this, () => {\n          numFileInputsInProgress--;\n\n          if (numFileInputsInProgress === 0) {\n            onComplete();\n          }\n        });\n        this.uploaders[inputEl] = uploader;\n        let entries = uploader.entries().map(entry => entry.toPreflightPayload());\n        let payload = {\n          ref: inputEl.getAttribute(PHX_UPLOAD_REF),\n          entries,\n          cid: this.targetComponentID(inputEl.form, targetCtx)\n        };\n        this.log(\"upload\", () => [\"sending preflight request\", payload]);\n        this.pushWithReply(null, \"allow_upload\", payload, resp => {\n          this.log(\"upload\", () => [\"got preflight response\", resp]);\n\n          if (resp.error) {\n            this.undoRefs(ref);\n            let [entry_ref, reason] = resp.error;\n            this.log(\"upload\", () => [`error for entry ${entry_ref}`, reason]);\n          } else {\n            let onError = callback => {\n              this.channel.onError(() => {\n                if (this.joinCount === joinCountAtUpload) {\n                  callback();\n                }\n              });\n            };\n\n            uploader.initAdapterUpload(resp, onError, this.liveSocket);\n          }\n        });\n      });\n    }\n\n    dispatchUploads(name, filesOrBlobs) {\n      let inputs = dom_default.findUploadInputs(this.el).filter(el => el.name === name);\n\n      if (inputs.length === 0) {\n        logError(`no live file inputs found matching the name \"${name}\"`);\n      } else if (inputs.length > 1) {\n        logError(`duplicate live file inputs found matching the name \"${name}\"`);\n      } else {\n        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {\n          detail: {\n            files: filesOrBlobs\n          }\n        });\n      }\n    }\n\n    pushFormRecovery(form, newCid, callback) {\n      this.liveSocket.withinOwners(form, (view, targetCtx) => {\n        let input = form.elements[0];\n        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding(\"change\"));\n        js_default.exec(\"change\", phxEvent, view, input, [\"push\", {\n          _target: input.name,\n          newCid,\n          callback\n        }]);\n      });\n    }\n\n    pushLinkPatch(href, targetEl, callback) {\n      let linkRef = this.liveSocket.setPendingLink(href);\n      let refGen = targetEl ? () => this.putRef([targetEl], \"click\") : null;\n\n      let fallback = () => this.liveSocket.redirect(window.location.href);\n\n      let push = this.pushWithReply(refGen, \"live_patch\", {\n        url: href\n      }, resp => {\n        this.liveSocket.requestDOMUpdate(() => {\n          if (resp.link_redirect) {\n            this.liveSocket.replaceMain(href, null, callback, linkRef);\n          } else {\n            if (this.liveSocket.commitPendingLink(linkRef)) {\n              this.href = href;\n            }\n\n            this.applyPendingUpdates();\n            callback && callback(linkRef);\n          }\n        });\n      });\n\n      if (push) {\n        push.receive(\"timeout\", fallback);\n      } else {\n        fallback();\n      }\n    }\n\n    formsForRecovery(html) {\n      if (this.joinCount === 0) {\n        return [];\n      }\n\n      let phxChange = this.binding(\"change\");\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return dom_default.all(this.el, `form[${phxChange}]`).filter(form => form.id && this.ownsElement(form)).filter(form => form.elements.length > 0).filter(form => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\").map(form => {\n        let newForm = template.content.querySelector(`form[id=\"${form.id}\"][${phxChange}=\"${form.getAttribute(phxChange)}\"]`);\n\n        if (newForm) {\n          return [form, newForm, this.targetComponentID(newForm)];\n        } else {\n          return [form, null, null];\n        }\n      }).filter(([form, newForm, newCid]) => newForm);\n    }\n\n    maybePushComponentsDestroyed(destroyedCIDs) {\n      let willDestroyCIDs = destroyedCIDs.filter(cid => {\n        return dom_default.findComponentNodeList(this.el, cid).length === 0;\n      });\n\n      if (willDestroyCIDs.length > 0) {\n        this.pruningCIDs.push(...willDestroyCIDs);\n        this.pushWithReply(null, \"cids_will_destroy\", {\n          cids: willDestroyCIDs\n        }, () => {\n          this.pruningCIDs = this.pruningCIDs.filter(cid => willDestroyCIDs.indexOf(cid) !== -1);\n          let completelyDestroyCIDs = willDestroyCIDs.filter(cid => {\n            return dom_default.findComponentNodeList(this.el, cid).length === 0;\n          });\n\n          if (completelyDestroyCIDs.length > 0) {\n            this.pushWithReply(null, \"cids_destroyed\", {\n              cids: completelyDestroyCIDs\n            }, resp => {\n              this.rendered.pruneCIDs(resp.cids);\n            });\n          }\n        });\n      }\n    }\n\n    ownsElement(el) {\n      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), node => node.id) === this.id;\n    }\n\n    submitForm(form, targetCtx, phxEvent, opts = {}) {\n      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);\n      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);\n      let inputs = Array.from(form.elements);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {\n        inputs.forEach(input => dom_default.showError(input, phxFeedback));\n        this.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n\n    binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n\n  }; // js/phoenix_live_view/live_socket.js\n\n  var LiveSocket = class {\n    constructor(url, phxSocket, opts = {}) {\n      this.unloaded = false;\n\n      if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n        throw new Error(`\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\n\n          import {Socket} from \"phoenix\"\n          import {LiveSocket} from \"phoenix_live_view\"\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n      `);\n      }\n\n      this.socket = new phxSocket(url, opts);\n      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n      this.opts = opts;\n      this.params = closure(opts.params || {});\n      this.viewLogger = opts.viewLogger;\n      this.metadataCallbacks = opts.metadata || {};\n      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n      this.activeElement = null;\n      this.prevActive = null;\n      this.silenced = false;\n      this.main = null;\n      this.outgoingMainEl = null;\n      this.clickStartedAtTarget = null;\n      this.linkRef = 1;\n      this.roots = {};\n      this.href = window.location.href;\n      this.pendingLink = null;\n      this.currentLocation = clone(window.location);\n      this.hooks = opts.hooks || {};\n      this.uploaders = opts.uploaders || {};\n      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n      this.reloadWithJitterTimer = null;\n      this.maxReloads = opts.maxReloads || MAX_RELOADS;\n      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;\n      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;\n      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;\n      this.localStorage = opts.localStorage || window.localStorage;\n      this.sessionStorage = opts.sessionStorage || window.sessionStorage;\n      this.boundTopLevelEvents = false;\n      this.domCallbacks = Object.assign({\n        onNodeAdded: closure(),\n        onBeforeElUpdated: closure()\n      }, opts.dom || {});\n      this.transitions = new TransitionSet();\n      window.addEventListener(\"pagehide\", _e => {\n        this.unloaded = true;\n      });\n      this.socket.onOpen(() => {\n        if (this.isUnloaded()) {\n          window.location.reload();\n        }\n      });\n    }\n\n    isProfileEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n    }\n\n    isDebugEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n    }\n\n    isDebugDisabled() {\n      return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"false\";\n    }\n\n    enableDebug() {\n      this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n    }\n\n    enableProfiling() {\n      this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n    }\n\n    disableDebug() {\n      this.sessionStorage.setItem(PHX_LV_DEBUG, \"false\");\n    }\n\n    disableProfiling() {\n      this.sessionStorage.removeItem(PHX_LV_PROFILE);\n    }\n\n    enableLatencySim(upperBoundMs) {\n      this.enableDebug();\n      console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\");\n      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n    }\n\n    disableLatencySim() {\n      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n    }\n\n    getLatencySim() {\n      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n      return str ? parseInt(str) : null;\n    }\n\n    getSocket() {\n      return this.socket;\n    }\n\n    connect() {\n      if (window.location.hostname === \"localhost\" && !this.isDebugDisabled()) {\n        this.enableDebug();\n      }\n\n      let doConnect = () => {\n        if (this.joinRootViews()) {\n          this.bindTopLevelEvents();\n          this.socket.connect();\n        } else if (this.main) {\n          this.socket.connect();\n        }\n      };\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        doConnect();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", () => doConnect());\n      }\n    }\n\n    disconnect(callback) {\n      clearTimeout(this.reloadWithJitterTimer);\n      this.socket.disconnect(callback);\n    }\n\n    replaceTransport(transport) {\n      clearTimeout(this.reloadWithJitterTimer);\n      this.socket.replaceTransport(transport);\n      this.connect();\n    }\n\n    execJS(el, encodedJS, eventType = null) {\n      this.owner(el, view => js_default.exec(eventType, encodedJS, view, el));\n    }\n\n    triggerDOM(kind, args) {\n      this.domCallbacks[kind](...args);\n    }\n\n    time(name, func) {\n      if (!this.isProfileEnabled() || !console.time) {\n        return func();\n      }\n\n      console.time(name);\n      let result = func();\n      console.timeEnd(name);\n      return result;\n    }\n\n    log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        let [msg, obj] = msgCallback();\n        this.viewLogger(view, kind, msg, obj);\n      } else if (this.isDebugEnabled()) {\n        let [msg, obj] = msgCallback();\n        debug(view, kind, msg, obj);\n      }\n    }\n\n    requestDOMUpdate(callback) {\n      this.transitions.after(callback);\n    }\n\n    transition(time, onStart, onDone = function () {}) {\n      this.transitions.addTransition(time, onStart, onDone);\n    }\n\n    onChannel(channel, event, cb) {\n      channel.on(event, data => {\n        let latency = this.getLatencySim();\n\n        if (!latency) {\n          cb(data);\n        } else {\n          console.log(`simulating ${latency}ms of latency from server to client`);\n          setTimeout(() => cb(data), latency);\n        }\n      });\n    }\n\n    wrapPush(view, opts, push) {\n      let latency = this.getLatencySim();\n      let oldJoinCount = view.joinCount;\n\n      if (!latency) {\n        if (this.isConnected() && opts.timeout) {\n          return push().receive(\"timeout\", () => {\n            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {\n              this.reloadWithJitter(view, () => {\n                this.log(view, \"timeout\", () => [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"]);\n              });\n            }\n          });\n        } else {\n          return push();\n        }\n      }\n\n      console.log(`simulating ${latency}ms of latency from client to server`);\n      let fakePush = {\n        receives: [],\n\n        receive(kind, cb) {\n          this.receives.push([kind, cb]);\n        }\n\n      };\n      setTimeout(() => {\n        if (view.isDestroyed()) {\n          return;\n        }\n\n        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());\n      }, latency);\n      return fakePush;\n    }\n\n    reloadWithJitter(view, log) {\n      clearTimeout(this.reloadWithJitterTimer);\n      this.disconnect();\n      let minMs = this.reloadJitterMin;\n      let maxMs = this.reloadJitterMax;\n      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, count => count + 1);\n\n      if (tries > this.maxReloads) {\n        afterMs = this.failsafeJitter;\n      }\n\n      this.reloadWithJitterTimer = setTimeout(() => {\n        if (view.isDestroyed() || view.isConnected()) {\n          return;\n        }\n\n        view.destroy();\n        log ? log() : this.log(view, \"join\", () => [`encountered ${tries} consecutive reloads`]);\n\n        if (tries > this.maxReloads) {\n          this.log(view, \"join\", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);\n        }\n\n        if (this.hasPendingLink()) {\n          window.location = this.pendingLink;\n        } else {\n          window.location.reload();\n        }\n      }, afterMs);\n    }\n\n    getHookCallbacks(name) {\n      return name && name.startsWith(\"Phoenix.\") ? hooks_default[name.split(\".\")[1]] : this.hooks[name];\n    }\n\n    isUnloaded() {\n      return this.unloaded;\n    }\n\n    isConnected() {\n      return this.socket.isConnected();\n    }\n\n    getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n\n    binding(kind) {\n      return `${this.getBindingPrefix()}${kind}`;\n    }\n\n    channel(topic, params) {\n      return this.socket.channel(topic, params);\n    }\n\n    joinRootViews() {\n      let rootsFound = false;\n      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, rootEl => {\n        if (!this.getRootById(rootEl.id)) {\n          let view = this.newRootView(rootEl);\n          view.setHref(this.getHref());\n          view.join();\n\n          if (rootEl.getAttribute(PHX_MAIN)) {\n            this.main = view;\n          }\n        }\n\n        rootsFound = true;\n      });\n      return rootsFound;\n    }\n\n    redirect(to, flash) {\n      this.disconnect();\n      browser_default.redirect(to, flash);\n    }\n\n    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {\n      this.outgoingMainEl = this.outgoingMainEl || this.main.el;\n      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, \"\");\n      this.main.showLoader(this.loaderTimeout);\n      this.main.destroy();\n      this.main = this.newRootView(newMainEl, flash);\n      this.main.setRedirect(href);\n      this.transitionRemoves();\n      this.main.join((joinCount, onDone) => {\n        if (joinCount === 1 && this.commitPendingLink(linkRef)) {\n          this.requestDOMUpdate(() => {\n            dom_default.findPhxSticky(document).forEach(el => newMainEl.appendChild(el));\n            this.outgoingMainEl.replaceWith(newMainEl);\n            this.outgoingMainEl = null;\n            callback && requestAnimationFrame(callback);\n            onDone();\n          });\n        }\n      });\n    }\n\n    transitionRemoves(elements) {\n      let removeAttr = this.binding(\"remove\");\n      elements = elements || dom_default.all(document, `[${removeAttr}]`);\n      elements.forEach(el => {\n        if (document.body.contains(el)) {\n          this.execJS(el, el.getAttribute(removeAttr), \"remove\");\n        }\n      });\n    }\n\n    isPhxView(el) {\n      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\n    }\n\n    newRootView(el, flash) {\n      let view = new View(el, this, null, flash);\n      this.roots[view.id] = view;\n      return view;\n    }\n\n    owner(childEl, callback) {\n      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), el => this.getViewByEl(el)) || this.main;\n\n      if (view) {\n        callback(view);\n      }\n    }\n\n    withinOwners(childEl, callback) {\n      this.owner(childEl, view => callback(view, childEl));\n    }\n\n    getViewByEl(el) {\n      let rootId = el.getAttribute(PHX_ROOT_ID);\n      return maybe(this.getRootById(rootId), root => root.getDescendentByEl(el));\n    }\n\n    getRootById(id) {\n      return this.roots[id];\n    }\n\n    destroyAllViews() {\n      for (let id in this.roots) {\n        this.roots[id].destroy();\n        delete this.roots[id];\n      }\n\n      this.main = null;\n    }\n\n    destroyViewByEl(el) {\n      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n\n      if (root && root.id === el.id) {\n        root.destroy();\n        delete this.roots[root.id];\n      } else if (root) {\n        root.destroyDescendent(el.id);\n      }\n    }\n\n    setActiveElement(target) {\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      let cancel = () => {\n        if (target === this.activeElement) {\n          this.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", this);\n        target.removeEventListener(\"touchend\", this);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n\n    getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement || document.body;\n      }\n    }\n\n    dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n\n    restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n\n    blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n\n    bindTopLevelEvents() {\n      if (this.boundTopLevelEvents) {\n        return;\n      }\n\n      this.boundTopLevelEvents = true;\n      this.socket.onClose(event => {\n        if (event && event.code === 1e3 && this.main) {\n          this.reloadWithJitter(this.main);\n        }\n      });\n      document.body.addEventListener(\"click\", function () {});\n      window.addEventListener(\"pageshow\", e => {\n        if (e.persisted) {\n          this.getSocket().disconnect();\n          this.withPageLoading({\n            to: window.location.href,\n            kind: \"redirect\"\n          });\n          window.location.reload();\n        }\n      }, true);\n      this.bindNav();\n      this.bindClicks();\n      this.bindForms();\n      this.bind({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, (e, type, view, targetEl, phxEvent, eventTarget) => {\n        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));\n        let pressedKey = e.key && e.key.toLowerCase();\n\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n\n        let data = __spreadValues({\n          key: e.key\n        }, this.eventMeta(type, e, targetEl));\n\n        js_default.exec(type, phxEvent, view, targetEl, [\"push\", {\n          data\n        }]);\n      });\n      this.bind({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, (e, type, view, targetEl, phxEvent, eventTarget) => {\n        if (!eventTarget) {\n          let data = __spreadValues({\n            key: e.key\n          }, this.eventMeta(type, e, targetEl));\n\n          js_default.exec(type, phxEvent, view, targetEl, [\"push\", {\n            data\n          }]);\n        }\n      });\n      this.bind({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\n        if (phxTarget === \"window\") {\n          let data = this.eventMeta(type, e, targetEl);\n          js_default.exec(type, phxEvent, view, targetEl, [\"push\", {\n            data\n          }]);\n        }\n      });\n      window.addEventListener(\"dragover\", e => e.preventDefault());\n      window.addEventListener(\"drop\", e => {\n        e.preventDefault();\n        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), trueTarget => {\n          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\n        });\n        let dropTarget = dropTargetId && document.getElementById(dropTargetId);\n        let files = Array.from(e.dataTransfer.files || []);\n\n        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {\n          return;\n        }\n\n        LiveUploader.trackFiles(dropTarget, files);\n        dropTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n      this.on(PHX_TRACK_UPLOADS, e => {\n        let uploadTarget = e.target;\n\n        if (!dom_default.isUploadInput(uploadTarget)) {\n          return;\n        }\n\n        let files = Array.from(e.detail.files || []).filter(f => f instanceof File || f instanceof Blob);\n        LiveUploader.trackFiles(uploadTarget, files);\n        uploadTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n    }\n\n    eventMeta(eventName, e, targetEl) {\n      let callback = this.metadataCallbacks[eventName];\n      return callback ? callback(e, targetEl) : {};\n    }\n\n    setPendingLink(href) {\n      this.linkRef++;\n      this.pendingLink = href;\n      return this.linkRef;\n    }\n\n    commitPendingLink(linkRef) {\n      if (this.linkRef !== linkRef) {\n        return false;\n      } else {\n        this.href = this.pendingLink;\n        this.pendingLink = null;\n        return true;\n      }\n    }\n\n    getHref() {\n      return this.href;\n    }\n\n    hasPendingLink() {\n      return !!this.pendingLink;\n    }\n\n    bind(events, callback) {\n      for (let event in events) {\n        let browserEventName = events[event];\n        this.on(browserEventName, e => {\n          let binding = this.binding(event);\n          let windowBinding = this.binding(`window-${event}`);\n          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent) {\n            this.debounce(e.target, e, browserEventName, () => {\n              this.withinOwners(e.target, view => {\n                callback(e, event, view, e.target, targetPhxEvent, null);\n              });\n            });\n          } else {\n            dom_default.all(document, `[${windowBinding}]`, el => {\n              let phxEvent = el.getAttribute(windowBinding);\n              this.debounce(el, e, browserEventName, () => {\n                this.withinOwners(el, view => {\n                  callback(e, event, view, el, phxEvent, \"window\");\n                });\n              });\n            });\n          }\n        });\n      }\n    }\n\n    bindClicks() {\n      window.addEventListener(\"mousedown\", e => this.clickStartedAtTarget = e.target);\n      this.bindClick(\"click\", \"click\", false);\n      this.bindClick(\"mousedown\", \"capture-click\", true);\n    }\n\n    bindClick(eventName, bindingName, capture) {\n      let click = this.binding(bindingName);\n      window.addEventListener(eventName, e => {\n        let target = null;\n\n        if (capture) {\n          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);\n        } else {\n          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;\n          target = closestPhxBinding(clickStartedAtTarget, click);\n          this.dispatchClickAway(e, clickStartedAtTarget);\n          this.clickStartedAtTarget = null;\n        }\n\n        let phxEvent = target && target.getAttribute(click);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        if (target.getAttribute(\"href\") === \"#\") {\n          e.preventDefault();\n        }\n\n        this.debounce(target, e, \"click\", () => {\n          this.withinOwners(target, view => {\n            js_default.exec(\"click\", phxEvent, view, target, [\"push\", {\n              data: this.eventMeta(\"click\", e, target)\n            }]);\n          });\n        });\n      }, capture);\n    }\n\n    dispatchClickAway(e, clickStartedAt) {\n      let phxClickAway = this.binding(\"click-away\");\n      dom_default.all(document, `[${phxClickAway}]`, el => {\n        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {\n          this.withinOwners(e.target, view => {\n            let phxEvent = el.getAttribute(phxClickAway);\n\n            if (js_default.isVisible(el)) {\n              js_default.exec(\"click\", phxEvent, view, el, [\"push\", {\n                data: this.eventMeta(\"click\", e, e.target)\n              }]);\n            }\n          });\n        }\n      });\n    }\n\n    bindNav() {\n      if (!browser_default.canPushState()) {\n        return;\n      }\n\n      if (history.scrollRestoration) {\n        history.scrollRestoration = \"manual\";\n      }\n\n      let scrollTimer = null;\n      window.addEventListener(\"scroll\", _e => {\n        clearTimeout(scrollTimer);\n        scrollTimer = setTimeout(() => {\n          browser_default.updateCurrentState(state => Object.assign(state, {\n            scroll: window.scrollY\n          }));\n        }, 100);\n      });\n      window.addEventListener(\"popstate\", event => {\n        if (!this.registerNewLocation(window.location)) {\n          return;\n        }\n\n        let {\n          type,\n          id,\n          root,\n          scroll\n        } = event.state || {};\n        let href = window.location.href;\n        this.requestDOMUpdate(() => {\n          if (this.main.isConnected() && type === \"patch\" && id === this.main.id) {\n            this.main.pushLinkPatch(href, null);\n          } else {\n            this.replaceMain(href, null, () => {\n              if (root) {\n                this.replaceRootHistory();\n              }\n\n              if (typeof scroll === \"number\") {\n                setTimeout(() => {\n                  window.scrollTo(0, scroll);\n                }, 0);\n              }\n            });\n          }\n        });\n      }, false);\n      window.addEventListener(\"click\", e => {\n        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        let type = target && target.getAttribute(PHX_LIVE_LINK);\n        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;\n\n        if (!type || !this.isConnected() || !this.main || wantsNewTab) {\n          return;\n        }\n\n        let href = target.href;\n        let linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n        e.stopImmediatePropagation();\n\n        if (this.pendingLink === href) {\n          return;\n        }\n\n        this.requestDOMUpdate(() => {\n          if (type === \"patch\") {\n            this.pushHistoryPatch(href, linkState, target);\n          } else if (type === \"redirect\") {\n            this.historyRedirect(href, linkState);\n          } else {\n            throw new Error(`expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`);\n          }\n        });\n      }, false);\n    }\n\n    dispatchEvent(event, payload = {}) {\n      dom_default.dispatchEvent(window, `phx:${event}`, {\n        detail: payload\n      });\n    }\n\n    dispatchEvents(events) {\n      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));\n    }\n\n    withPageLoading(info, callback) {\n      dom_default.dispatchEvent(window, \"phx:page-loading-start\", {\n        detail: info\n      });\n\n      let done = () => dom_default.dispatchEvent(window, \"phx:page-loading-stop\", {\n        detail: info\n      });\n\n      return callback ? callback(done) : done;\n    }\n\n    pushHistoryPatch(href, linkState, targetEl) {\n      this.withPageLoading({\n        to: href,\n        kind: \"patch\"\n      }, done => {\n        this.main.pushLinkPatch(href, targetEl, linkRef => {\n          this.historyPatch(href, linkState, linkRef);\n          done();\n        });\n      });\n    }\n\n    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\n      if (!this.commitPendingLink(linkRef)) {\n        return;\n      }\n\n      browser_default.pushState(linkState, {\n        type: \"patch\",\n        id: this.main.id\n      }, href);\n      this.registerNewLocation(window.location);\n    }\n\n    historyRedirect(href, linkState, flash) {\n      let scroll = window.scrollY;\n      this.withPageLoading({\n        to: href,\n        kind: \"redirect\"\n      }, done => {\n        this.replaceMain(href, flash, () => {\n          browser_default.pushState(linkState, {\n            type: \"redirect\",\n            id: this.main.id,\n            scroll\n          }, href);\n          this.registerNewLocation(window.location);\n          done();\n        });\n      });\n    }\n\n    replaceRootHistory() {\n      browser_default.pushState(\"replace\", {\n        root: true,\n        type: \"patch\",\n        id: this.main.id\n      });\n    }\n\n    registerNewLocation(newLocation) {\n      let {\n        pathname,\n        search\n      } = this.currentLocation;\n\n      if (pathname + search === newLocation.pathname + newLocation.search) {\n        return false;\n      } else {\n        this.currentLocation = clone(newLocation);\n        return true;\n      }\n    }\n\n    bindForms() {\n      let iterations = 0;\n      this.on(\"submit\", e => {\n        let phxEvent = e.target.getAttribute(this.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n        this.withinOwners(e.target, view => {\n          js_default.exec(\"submit\", phxEvent, view, e.target, [\"push\", {}]);\n        });\n      }, false);\n\n      for (let type of [\"change\", \"input\"]) {\n        this.on(type, e => {\n          let phxChange = this.binding(\"change\");\n          let input = e.target;\n          let inputEvent = input.getAttribute(phxChange);\n          let formEvent = input.form && input.form.getAttribute(phxChange);\n          let phxEvent = inputEvent || formEvent;\n\n          if (!phxEvent) {\n            return;\n          }\n\n          if (input.type === \"number\" && input.validity && input.validity.badInput) {\n            return;\n          }\n\n          let dispatcher = inputEvent ? input : input.form;\n          let currentIterations = iterations;\n          iterations++;\n          let {\n            at,\n            type: lastType\n          } = dom_default.private(input, \"prev-iteration\") || {};\n\n          if (at === currentIterations - 1 && type !== lastType) {\n            return;\n          }\n\n          dom_default.putPrivate(input, \"prev-iteration\", {\n            at: currentIterations,\n            type\n          });\n          this.debounce(input, e, type, () => {\n            this.withinOwners(dispatcher, view => {\n              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);\n\n              if (!dom_default.isTextualInput(input)) {\n                this.setActiveElement(input);\n              }\n\n              js_default.exec(\"change\", phxEvent, view, input, [\"push\", {\n                _target: e.target.name,\n                dispatcher\n              }]);\n            });\n          });\n        }, false);\n      }\n    }\n\n    debounce(el, event, eventType, callback) {\n      if (eventType === \"blur\" || eventType === \"focusout\") {\n        return callback();\n      }\n\n      let phxDebounce = this.binding(PHX_DEBOUNCE);\n      let phxThrottle = this.binding(PHX_THROTTLE);\n      let defaultDebounce = this.defaults.debounce.toString();\n      let defaultThrottle = this.defaults.throttle.toString();\n      this.withinOwners(el, view => {\n        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);\n\n        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {\n          callback();\n        });\n      });\n    }\n\n    silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n\n    on(event, callback) {\n      window.addEventListener(event, e => {\n        if (!this.silenced) {\n          callback(e);\n        }\n      });\n    }\n\n  };\n  var TransitionSet = class {\n    constructor() {\n      this.transitions = new Set();\n      this.pendingOps = [];\n      this.reset();\n    }\n\n    reset() {\n      this.transitions.forEach(timer => {\n        cancelTimeout(timer);\n        this.transitions.delete(timer);\n      });\n      this.flushPendingOps();\n    }\n\n    after(callback) {\n      if (this.size() === 0) {\n        callback();\n      } else {\n        this.pushPendingOp(callback);\n      }\n    }\n\n    addTransition(time, onStart, onDone) {\n      onStart();\n      let timer = setTimeout(() => {\n        this.transitions.delete(timer);\n        onDone();\n\n        if (this.size() === 0) {\n          this.flushPendingOps();\n        }\n      }, time);\n      this.transitions.add(timer);\n    }\n\n    pushPendingOp(op) {\n      this.pendingOps.push(op);\n    }\n\n    size() {\n      return this.transitions.size;\n    }\n\n    flushPendingOps() {\n      this.pendingOps.forEach(op => op());\n      this.pendingOps = [];\n    }\n\n  };\n  return phoenix_live_view_exports;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9wcml2L3N0YXRpYy9waG9lbml4X2xpdmVfdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L3ByaXYvc3RhdGljL3Bob2VuaXhfbGl2ZV92aWV3LmpzPzJjOTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExpdmVWaWV3ID0gKCgpID0+IHtcbiAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICB2YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbiAgdmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICB2YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgdmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gICAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvaW5kZXguanNcbiAgdmFyIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9saXZlX3ZpZXdfZXhwb3J0cywge1xuICAgIExpdmVTb2NrZXQ6ICgpID0+IExpdmVTb2NrZXRcbiAgfSk7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzXG4gIHZhciBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCI7XG4gIHZhciBNQVhfUkVMT0FEUyA9IDEwO1xuICB2YXIgUkVMT0FEX0pJVFRFUl9NSU4gPSA1ZTM7XG4gIHZhciBSRUxPQURfSklUVEVSX01BWCA9IDFlNDtcbiAgdmFyIEZBSUxTQUZFX0pJVFRFUiA9IDNlNDtcbiAgdmFyIFBIWF9FVkVOVF9DTEFTU0VTID0gW1xuICAgIFwicGh4LWNsaWNrLWxvYWRpbmdcIixcbiAgICBcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLFxuICAgIFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIsXG4gICAgXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsXG4gICAgXCJwaHgta2V5dXAtbG9hZGluZ1wiLFxuICAgIFwicGh4LWJsdXItbG9hZGluZ1wiLFxuICAgIFwicGh4LWZvY3VzLWxvYWRpbmdcIlxuICBdO1xuICB2YXIgUEhYX0NPTVBPTkVOVCA9IFwiZGF0YS1waHgtY29tcG9uZW50XCI7XG4gIHZhciBQSFhfTElWRV9MSU5LID0gXCJkYXRhLXBoeC1saW5rXCI7XG4gIHZhciBQSFhfVFJBQ0tfU1RBVElDID0gXCJ0cmFjay1zdGF0aWNcIjtcbiAgdmFyIFBIWF9MSU5LX1NUQVRFID0gXCJkYXRhLXBoeC1saW5rLXN0YXRlXCI7XG4gIHZhciBQSFhfUkVGID0gXCJkYXRhLXBoeC1yZWZcIjtcbiAgdmFyIFBIWF9SRUZfU1JDID0gXCJkYXRhLXBoeC1yZWYtc3JjXCI7XG4gIHZhciBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiO1xuICB2YXIgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIjtcbiAgdmFyIFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCI7XG4gIHZhciBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIjtcbiAgdmFyIFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIjtcbiAgdmFyIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIjtcbiAgdmFyIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCI7XG4gIHZhciBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiO1xuICB2YXIgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiO1xuICB2YXIgUEhYX1BBR0VfTE9BRElORyA9IFwicGFnZS1sb2FkaW5nXCI7XG4gIHZhciBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCI7XG4gIHZhciBQSFhfRElTQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtbG9hZGluZ1wiO1xuICB2YXIgUEhYX05PX0ZFRURCQUNLX0NMQVNTID0gXCJwaHgtbm8tZmVlZGJhY2tcIjtcbiAgdmFyIFBIWF9FUlJPUl9DTEFTUyA9IFwicGh4LWVycm9yXCI7XG4gIHZhciBQSFhfUEFSRU5UX0lEID0gXCJkYXRhLXBoeC1wYXJlbnQtaWRcIjtcbiAgdmFyIFBIWF9NQUlOID0gXCJkYXRhLXBoeC1tYWluXCI7XG4gIHZhciBQSFhfUk9PVF9JRCA9IFwiZGF0YS1waHgtcm9vdC1pZFwiO1xuICB2YXIgUEhYX1RSSUdHRVJfQUNUSU9OID0gXCJ0cmlnZ2VyLWFjdGlvblwiO1xuICB2YXIgUEhYX0ZFRURCQUNLX0ZPUiA9IFwiZmVlZGJhY2stZm9yXCI7XG4gIHZhciBQSFhfSEFTX0ZPQ1VTRUQgPSBcInBoeC1oYXMtZm9jdXNlZFwiO1xuICB2YXIgRk9DVVNBQkxFX0lOUFVUUyA9IFtcInRleHRcIiwgXCJ0ZXh0YXJlYVwiLCBcIm51bWJlclwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwiY29sb3JcIiwgXCJyYW5nZVwiXTtcbiAgdmFyIENIRUNLQUJMRV9JTlBVVFMgPSBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdO1xuICB2YXIgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCI7XG4gIHZhciBQSFhfU0VTU0lPTiA9IFwiZGF0YS1waHgtc2Vzc2lvblwiO1xuICB2YXIgUEhYX1ZJRVdfU0VMRUNUT1IgPSBgWyR7UEhYX1NFU1NJT059XWA7XG4gIHZhciBQSFhfU1RJQ0tZID0gXCJkYXRhLXBoeC1zdGlja3lcIjtcbiAgdmFyIFBIWF9TVEFUSUMgPSBcImRhdGEtcGh4LXN0YXRpY1wiO1xuICB2YXIgUEhYX1JFQURPTkxZID0gXCJkYXRhLXBoeC1yZWFkb25seVwiO1xuICB2YXIgUEhYX0RJU0FCTEVEID0gXCJkYXRhLXBoeC1kaXNhYmxlZFwiO1xuICB2YXIgUEhYX0RJU0FCTEVfV0lUSCA9IFwiZGlzYWJsZS13aXRoXCI7XG4gIHZhciBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUgPSBcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCI7XG4gIHZhciBQSFhfSE9PSyA9IFwiaG9va1wiO1xuICB2YXIgUEhYX0RFQk9VTkNFID0gXCJkZWJvdW5jZVwiO1xuICB2YXIgUEhYX1RIUk9UVExFID0gXCJ0aHJvdHRsZVwiO1xuICB2YXIgUEhYX1VQREFURSA9IFwidXBkYXRlXCI7XG4gIHZhciBQSFhfS0VZID0gXCJrZXlcIjtcbiAgdmFyIFBIWF9QUklWQVRFID0gXCJwaHhQcml2YXRlXCI7XG4gIHZhciBQSFhfQVVUT19SRUNPVkVSID0gXCJhdXRvLXJlY292ZXJcIjtcbiAgdmFyIFBIWF9MVl9ERUJVRyA9IFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCI7XG4gIHZhciBQSFhfTFZfUFJPRklMRSA9IFwicGh4OmxpdmUtc29ja2V0OnByb2ZpbGluZ1wiO1xuICB2YXIgUEhYX0xWX0xBVEVOQ1lfU0lNID0gXCJwaHg6bGl2ZS1zb2NrZXQ6bGF0ZW5jeS1zaW1cIjtcbiAgdmFyIFBIWF9QUk9HUkVTUyA9IFwicHJvZ3Jlc3NcIjtcbiAgdmFyIExPQURFUl9USU1FT1VUID0gMTtcbiAgdmFyIEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQgPSAyMDA7XG4gIHZhciBCSU5ESU5HX1BSRUZJWCA9IFwicGh4LVwiO1xuICB2YXIgUFVTSF9USU1FT1VUID0gM2U0O1xuICB2YXIgREVCT1VOQ0VfVFJJR0dFUiA9IFwiZGVib3VuY2UtdHJpZ2dlclwiO1xuICB2YXIgVEhST1RUTEVEID0gXCJ0aHJvdHRsZWRcIjtcbiAgdmFyIERFQk9VTkNFX1BSRVZfS0VZID0gXCJkZWJvdW5jZS1wcmV2LWtleVwiO1xuICB2YXIgREVGQVVMVFMgPSB7XG4gICAgZGVib3VuY2U6IDMwMCxcbiAgICB0aHJvdHRsZTogMzAwXG4gIH07XG4gIHZhciBEWU5BTUlDUyA9IFwiZFwiO1xuICB2YXIgU1RBVElDID0gXCJzXCI7XG4gIHZhciBDT01QT05FTlRTID0gXCJjXCI7XG4gIHZhciBFVkVOVFMgPSBcImVcIjtcbiAgdmFyIFJFUExZID0gXCJyXCI7XG4gIHZhciBUSVRMRSA9IFwidFwiO1xuICB2YXIgVEVNUExBVEVTID0gXCJwXCI7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZW50cnlfdXBsb2FkZXIuanNcbiAgdmFyIEVudHJ5VXBsb2FkZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZW50cnksIGNodW5rU2l6ZSwgbGl2ZVNvY2tldCkge1xuICAgICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldDtcbiAgICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgdGhpcy5jaHVua1RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHsgdG9rZW46IGVudHJ5Lm1ldGFkYXRhKCkgfSk7XG4gICAgfVxuICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2h1bmtUaW1lcik7XG4gICAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKTtcbiAgICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKTtcbiAgICB9XG4gICAgdXBsb2FkKCkge1xuICAgICAgdGhpcy51cGxvYWRDaGFubmVsLm9uRXJyb3IoKHJlYXNvbikgPT4gdGhpcy5lcnJvcihyZWFzb24pKTtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKCkucmVjZWl2ZShcIm9rXCIsIChfZGF0YSkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpLnJlY2VpdmUoXCJlcnJvclwiLCAocmVhc29uKSA9PiB0aGlzLmVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICBpc0RvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgPj0gdGhpcy5lbnRyeS5maWxlLnNpemU7XG4gICAgfVxuICAgIHJlYWROZXh0Q2h1bmsoKSB7XG4gICAgICBsZXQgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG4gICAgICBsZXQgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gZS50YXJnZXQucmVzdWx0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgdGhpcy5wdXNoQ2h1bmsoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbG9nRXJyb3IoXCJSZWFkIGVycm9yOiBcIiArIGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9XG4gICAgcHVzaENodW5rKGNodW5rKSB7XG4gICAgICBpZiAoIXRoaXMudXBsb2FkQ2hhbm5lbC5pc0pvaW5lZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmspLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3ModGhpcy5vZmZzZXQgLyB0aGlzLmVudHJ5LmZpbGUuc2l6ZSAqIDEwMCk7XG4gICAgICAgIGlmICghdGhpcy5pc0RvbmUoKSkge1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy91dGlscy5qc1xuICB2YXIgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iaik7XG4gIHZhciBpc0NpZCA9IChjaWQpID0+IHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBjaWQ7XG4gICAgcmV0dXJuIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCk7XG4gIH07XG4gIGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpIHtcbiAgICBsZXQgaWRzID0gbmV3IFNldCgpO1xuICAgIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpZHMuaGFzKGVsZW1zW2ldLmlkKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6ICR7ZWxlbXNbaV0uaWR9LiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICAgIGlmICh2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKTtcbiAgICB9XG4gIH07XG4gIHZhciBjbG9zdXJlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgdmFyIGNsb25lID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9O1xuICB2YXIgY2xvc2VzdFBoeEJpbmRpbmcgPSAoZWwsIGJpbmRpbmcsIGJvcmRlckVsKSA9PiB7XG4gICAgZG8ge1xuICAgICAgaWYgKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApKSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoYm9yZGVyRWwgJiYgYm9yZGVyRWwuaXNTYW1lTm9kZShlbCkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgdmFyIGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KTtcbiAgfTtcbiAgdmFyIGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpO1xuICB2YXIgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgICBmb3IgKGxldCB4IGluIG9iaikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpO1xuICB2YXIgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24oZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCkge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLmNodW5rX3NpemUsIGxpdmVTb2NrZXQpO1xuICAgICAgZW50cnlVcGxvYWRlci51cGxvYWQoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9icm93c2VyLmpzXG4gIHZhciBCcm93c2VyID0ge1xuICAgIGNhblB1c2hTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaGlzdG9yeS5wdXNoU3RhdGUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfSxcbiAgICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKTtcbiAgICB9LFxuICAgIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpIHtcbiAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KTtcbiAgICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KTtcbiAgICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpO1xuICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9LFxuICAgIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH0sXG4gICAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKSB7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICBpZiAodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgaWYgKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLnNjcm9sbCA9IG1ldGEuc2Nyb2xsO1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbDtcbiAgICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpO1xuICAgICAgICAgIGxldCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaCk7XG4gICAgICAgICAgaWYgKGhhc2hFbCkge1xuICAgICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIikge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVkaXJlY3QodG8pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0Q29va2llKG5hbWUsIHZhbHVlKSB7XG4gICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWA7XG4gICAgfSxcbiAgICBnZXRDb29raWUobmFtZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7cyopJHtuYW1lfXMqPXMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpO1xuICAgIH0sXG4gICAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKSB7XG4gICAgICBpZiAoZmxhc2gpIHtcbiAgICAgICAgQnJvd3Nlci5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLCBmbGFzaCArIFwiOyBtYXgtYWdlPTYwMDAwOyBwYXRoPS9cIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cubG9jYXRpb24gPSB0b1VSTDtcbiAgICB9LFxuICAgIGxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSB7XG4gICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gO1xuICAgIH0sXG4gICAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCkge1xuICAgICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoaGFzaCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApO1xuICAgIH1cbiAgfTtcbiAgdmFyIGJyb3dzZXJfZGVmYXVsdCA9IEJyb3dzZXI7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzXG4gIHZhciBET00gPSB7XG4gICAgYnlJZChpZCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBsb2dFcnJvcihgbm8gaWQgZm91bmQgZm9yICR7aWR9YCk7XG4gICAgfSxcbiAgICByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICBpZiAoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFsbChub2RlLCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBsZXQgYXJyYXkgPSBBcnJheS5mcm9tKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrID8gYXJyYXkuZm9yRWFjaChjYWxsYmFjaykgOiBhcnJheTtcbiAgICB9LFxuICAgIGNoaWxkTm9kZUxlbmd0aChodG1sKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnQ7XG4gICAgfSxcbiAgICBpc1VwbG9hZElucHV0KGVsKSB7XG4gICAgICByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbDtcbiAgICB9LFxuICAgIGZpbmRVcGxvYWRJbnB1dHMobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKTtcbiAgICB9LFxuICAgIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSk7XG4gICAgfSxcbiAgICBpc1BoeERlc3Ryb3llZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCkge1xuICAgICAgaWYgKHRoaXMuaXNQaHhDaGlsZChlbCkpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSk7XG4gICAgfSxcbiAgICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKTtcbiAgICB9LFxuICAgIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKSB7XG4gICAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCI7XG4gICAgfSxcbiAgICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcykge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwO1xuICAgIH0sXG4gICAgZmluZFBoeFN0aWNreShlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgWyR7UEhYX1NUSUNLWX1dYCk7XG4gICAgfSxcbiAgICBmaW5kUGh4Q2hpbGRyZW4oZWwsIHBhcmVudElkKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbGwoZWwsIGAke1BIWF9WSUVXX1NFTEVDVE9SfVske1BIWF9QQVJFTlRfSUR9PVwiJHtwYXJlbnRJZH1cIl1gKTtcbiAgICB9LFxuICAgIGZpbmRQYXJlbnRDSURzKG5vZGUsIGNpZHMpIHtcbiAgICAgIGxldCBpbml0aWFsID0gbmV3IFNldChjaWRzKTtcbiAgICAgIHJldHVybiBjaWRzLnJlZHVjZSgoYWNjLCBjaWQpID0+IHtcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdIFske1BIWF9DT01QT05FTlR9XWA7XG4gICAgICAgIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIHNlbGVjdG9yKSwgbm9kZSkubWFwKChlbCkgPT4gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSkuZm9yRWFjaCgoY2hpbGRDSUQpID0+IGFjYy5kZWxldGUoY2hpbGRDSUQpKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIGluaXRpYWwpO1xuICAgIH0sXG4gICAgZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KG5vZGVzLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQucXVlcnlTZWxlY3RvcihQSFhfVklFV19TRUxFQ1RPUikpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcigoZWwpID0+IHRoaXMud2l0aGluU2FtZUxpdmVWaWV3KGVsLCBwYXJlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpdGhpblNhbWVMaXZlVmlldyhub2RlLCBwYXJlbnQpIHtcbiAgICAgIHdoaWxlIChub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzU2FtZU5vZGUocGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHByaXZhdGUoZWwsIGtleSkge1xuICAgICAgcmV0dXJuIGVsW1BIWF9QUklWQVRFXSAmJiBlbFtQSFhfUFJJVkFURV1ba2V5XTtcbiAgICB9LFxuICAgIGRlbGV0ZVByaXZhdGUoZWwsIGtleSkge1xuICAgICAgZWxbUEhYX1BSSVZBVEVdICYmIGRlbGV0ZSBlbFtQSFhfUFJJVkFURV1ba2V5XTtcbiAgICB9LFxuICAgIHB1dFByaXZhdGUoZWwsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICghZWxbUEhYX1BSSVZBVEVdKSB7XG4gICAgICAgIGVsW1BIWF9QUklWQVRFXSA9IHt9O1xuICAgICAgfVxuICAgICAgZWxbUEhYX1BSSVZBVEVdW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIHVwZGF0ZVByaXZhdGUoZWwsIGtleSwgZGVmYXVsdFZhbCwgdXBkYXRlRnVuYykge1xuICAgICAgbGV0IGV4aXN0aW5nID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZGVmYXVsdFZhbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZXhpc3RpbmcpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvcHlQcml2YXRlcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZVtQSFhfUFJJVkFURV0pIHtcbiAgICAgICAgdGFyZ2V0W1BIWF9QUklWQVRFXSA9IHNvdXJjZVtQSFhfUFJJVkFURV07XG4gICAgICB9XG4gICAgfSxcbiAgICBwdXRUaXRsZShzdHIpIHtcbiAgICAgIGxldCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpO1xuICAgICAgbGV0IHsgcHJlZml4LCBzdWZmaXggfSA9IHRpdGxlRWwuZGF0YXNldDtcbiAgICAgIGRvY3VtZW50LnRpdGxlID0gYCR7cHJlZml4IHx8IFwiXCJ9JHtzdHJ9JHtzdWZmaXggfHwgXCJcIn1gO1xuICAgIH0sXG4gICAgZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBkZWJvdW5jZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhEZWJvdW5jZSk7XG4gICAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpO1xuICAgICAgaWYgKGRlYm91bmNlID09PSBcIlwiKSB7XG4gICAgICAgIGRlYm91bmNlID0gZGVmYXVsdERlYm91bmNlO1xuICAgICAgfVxuICAgICAgaWYgKHRocm90dGxlID09PSBcIlwiKSB7XG4gICAgICAgIHRocm90dGxlID0gZGVmYXVsdFRocm90dGxlO1xuICAgICAgfVxuICAgICAgbGV0IHZhbHVlID0gZGVib3VuY2UgfHwgdGhyb3R0bGU7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgICBpZiAodGhpcy5vbmNlKGVsLCBcImRlYm91bmNlLWJsdXJcIikpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKCk7XG4gICAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpO1xuICAgICAgICAgIGlmIChpc05hTih0aW1lb3V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhyb3R0bGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIpIHtcbiAgICAgICAgICAgICAgbGV0IHByZXZLZXkgPSB0aGlzLnByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZKTtcbiAgICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSwgZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgbmV3S2V5RG93biA9IHByZXZLZXkgIT09IGV2ZW50LmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV3S2V5RG93biAmJiB0aGlzLnByaXZhdGUoZWwsIFRIUk9UVExFRCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHRydWUpO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmNGaWx0ZXIoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYXN5bmNGaWx0ZXIoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtO1xuICAgICAgICAgIGlmIChmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmV3IEZvcm1EYXRhKGZvcm0pLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSkge1xuICAgICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSk7XG4gICAgICBpZiAoIWN1cnJlbnRDeWNsZSkge1xuICAgICAgICBjdXJyZW50Q3ljbGUgPSBjeWNsZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Q3ljbGUgPT09IGN5Y2xlKSB7XG4gICAgICAgIHRoaXMuaW5jQ3ljbGUoZWwsIGtleSk7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uY2UoZWwsIGtleSkge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZShlbCwga2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdO1xuICAgICAgY3VycmVudEN5Y2xlKys7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pO1xuICAgICAgcmV0dXJuIGN1cnJlbnRDeWNsZTtcbiAgICB9LFxuICAgIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0Zvcik7XG4gICAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKTtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShpbnB1dC5mb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCkpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoUEhYX05PX0ZFRURCQUNLX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFcnJvcihpbnB1dEVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgaWYgKGlucHV0RWwuaWQgfHwgaW5wdXRFbC5uYW1lKSB7XG4gICAgICAgIHRoaXMuYWxsKGlucHV0RWwuZm9ybSwgYFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5pZH1cIl0sIFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5uYW1lfVwiXWAsIChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoZWwsIFBIWF9OT19GRUVEQkFDS19DTEFTUyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNQaHhDaGlsZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCk7XG4gICAgfSxcbiAgICBpc1BoeFN0aWNreShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NUSUNLWSkgIT09IG51bGw7XG4gICAgfSxcbiAgICBmaXJzdFBoeENoaWxkKGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1BoeENoaWxkKGVsKSA/IGVsIDogdGhpcy5hbGwoZWwsIGBbJHtQSFhfUEFSRU5UX0lEfV1gKVswXTtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB2b2lkIDAgPyB0cnVlIDogISFvcHRzLmJ1YmJsZXM7XG4gICAgICBsZXQgZXZlbnRPcHRzID0geyBidWJibGVzLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IG9wdHMuZGV0YWlsIHx8IHt9IH07XG4gICAgICBsZXQgZXZlbnQgPSBuYW1lID09PSBcImNsaWNrXCIgPyBuZXcgTW91c2VFdmVudChcImNsaWNrXCIsIGV2ZW50T3B0cykgOiBuZXcgQ3VzdG9tRXZlbnQobmFtZSwgZXZlbnRPcHRzKTtcbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuICAgIGNsb25lTm9kZShub2RlLCBodG1sKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBleGNsdWRlID0gb3B0cy5leGNsdWRlIHx8IFtdO1xuICAgICAgbGV0IGlzSWdub3JlZCA9IG9wdHMuaXNJZ25vcmVkO1xuICAgICAgbGV0IHNvdXJjZUF0dHJzID0gc291cmNlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gc291cmNlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5hbWUgPSBzb3VyY2VBdHRyc1tpXS5uYW1lO1xuICAgICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB0YXJnZXRBdHRycyA9IHRhcmdldC5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IHRhcmdldEF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGFyZ2V0QXR0cnNbaV0ubmFtZTtcbiAgICAgICAgaWYgKGlzSWdub3JlZCkge1xuICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWVyZ2VGb2N1c2VkSW5wdXQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSkge1xuICAgICAgICBET00ubWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwgeyBleGNsdWRlOiBbXCJ2YWx1ZVwiXSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UucmVhZE9ubHkpIHtcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpIHtcbiAgICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKTtcbiAgICB9LFxuICAgIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSB7XG4gICAgICBpZiAoIURPTS5pc1RleHR1YWxJbnB1dChmb2N1c2VkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgd2FzRm9jdXNlZCA9IGZvY3VzZWQubWF0Y2hlcyhcIjpmb2N1c1wiKTtcbiAgICAgIGlmIChmb2N1c2VkLnJlYWRPbmx5KSB7XG4gICAgICAgIGZvY3VzZWQuYmx1cigpO1xuICAgICAgfVxuICAgICAgaWYgKCF3YXNGb2N1c2VkKSB7XG4gICAgICAgIGZvY3VzZWQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpKSB7XG4gICAgICAgIGZvY3VzZWQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0Zvcm1JbnB1dChlbCkge1xuICAgICAgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCI7XG4gICAgfSxcbiAgICBzeW5jQXR0cnNUb1Byb3BzKGVsKSB7XG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGVsLmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikgIT09IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1RleHR1YWxJbnB1dChlbCkge1xuICAgICAgcmV0dXJuIEZPQ1VTQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwO1xuICAgIH0sXG4gICAgaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFRyaWdnZXJFeHRlcm5hbCkgIT09IG51bGw7XG4gICAgfSxcbiAgICBzeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKSB7XG4gICAgICBsZXQgcmVmID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfUkVGKTtcbiAgICAgIGlmIChyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVmU3JjID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfUkVGX1NSQyk7XG4gICAgICBpZiAoRE9NLmlzRm9ybUlucHV0KGZyb21FbCkgfHwgZnJvbUVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aCkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpIHtcbiAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHsgaXNJZ25vcmVkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIERPTS5wdXRQcml2YXRlKGZyb21FbCwgUEhYX1JFRiwgdG9FbCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgIGZyb21FbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSAmJiB0b0VsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIHJlZik7XG4gICAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCByZWZTcmMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFuQ2hpbGROb2Rlcyhjb250YWluZXIsIHBoeFVwZGF0ZSkge1xuICAgICAgaWYgKERPTS5pc1BoeFVwZGF0ZShjb250YWluZXIsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpIHtcbiAgICAgICAgbGV0IHRvUmVtb3ZlID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGlmICghY2hpbGROb2RlLmlkKSB7XG4gICAgICAgICAgICBsZXQgaXNFbXB0eVRleHROb2RlID0gY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gXCJcIjtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eVRleHROb2RlKSB7XG4gICAgICAgICAgICAgIGxvZ0Vycm9yKGBvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxuXG5yZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJHsoY2hpbGROb2RlLm91dGVySFRNTCB8fCBjaGlsZE5vZGUubm9kZVZhbHVlKS50cmltKCl9XCJcblxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdG9SZW1vdmUuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiBjaGlsZE5vZGUucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZVJvb3RDb250YWluZXIoY29udGFpbmVyLCB0YWdOYW1lLCBhdHRycykge1xuICAgICAgbGV0IHJldGFpbmVkQXR0cnMgPSBuZXcgU2V0KFtcImlkXCIsIFBIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfTUFJTiwgUEhYX1JPT1RfSURdKTtcbiAgICAgIGlmIChjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuYXR0cmlidXRlcykuZmlsdGVyKChhdHRyKSA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKS5mb3JFYWNoKChhdHRyKSA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZmlsdGVyKChuYW1lKSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkuZm9yRWFjaCgoYXR0cikgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChhdHRyKSA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSk7XG4gICAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaCgoYXR0cikgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSk7XG4gICAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFN0aWNreShlbCwgbmFtZSwgZGVmYXVsdFZhbCkge1xuICAgICAgbGV0IG9wID0gKERPTS5wcml2YXRlKGVsLCBcInN0aWNreVwiKSB8fCBbXSkuZmluZCgoW2V4aXN0aW5nTmFtZV0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSk7XG4gICAgICBpZiAob3ApIHtcbiAgICAgICAgbGV0IFtfbmFtZSwgX29wLCBzdGFzaGVkUmVzdWx0XSA9IG9wO1xuICAgICAgICByZXR1cm4gc3Rhc2hlZFJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbCA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbCgpIDogZGVmYXVsdFZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZVN0aWNreShlbCwgbmFtZSkge1xuICAgICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgKG9wcykgPT4ge1xuICAgICAgICByZXR1cm4gb3BzLmZpbHRlcigoW2V4aXN0aW5nTmFtZSwgX10pID0+IGV4aXN0aW5nTmFtZSAhPT0gbmFtZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHB1dFN0aWNreShlbCwgbmFtZSwgb3ApIHtcbiAgICAgIGxldCBzdGFzaGVkUmVzdWx0ID0gb3AoZWwpO1xuICAgICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgKG9wcykgPT4ge1xuICAgICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWVdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgb3BzW2V4aXN0aW5nSW5kZXhdID0gW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHMucHVzaChbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BzO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhcHBseVN0aWNreU9wZXJhdGlvbnMoZWwpIHtcbiAgICAgIGxldCBvcHMgPSBET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIik7XG4gICAgICBpZiAoIW9wcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcHMuZm9yRWFjaCgoW25hbWUsIG9wLCBfc3Rhc2hlZF0pID0+IHRoaXMucHV0U3RpY2t5KGVsLCBuYW1lLCBvcCkpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRvbV9kZWZhdWx0ID0gRE9NO1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qc1xuICB2YXIgVXBsb2FkRW50cnkgPSBjbGFzcyB7XG4gICAgc3RhdGljIGlzQWN0aXZlKGZpbGVFbCwgZmlsZSkge1xuICAgICAgbGV0IGlzTmV3ID0gZmlsZS5fcGh4UmVmID09PSB2b2lkIDA7XG4gICAgICBsZXQgYWN0aXZlUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIik7XG4gICAgICBsZXQgaXNBY3RpdmUgPSBhY3RpdmVSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDA7XG4gICAgICByZXR1cm4gZmlsZS5zaXplID4gMCAmJiAoaXNOZXcgfHwgaXNBY3RpdmUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQcmVmbGlnaHRlZChmaWxlRWwsIGZpbGUpIHtcbiAgICAgIGxldCBwcmVmbGlnaHRlZFJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKS5zcGxpdChcIixcIik7XG4gICAgICBsZXQgaXNQcmVmbGlnaHRlZCA9IHByZWZsaWdodGVkUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwO1xuICAgICAgcmV0dXJuIGlzUHJlZmxpZ2h0ZWQgJiYgdGhpcy5pc0FjdGl2ZShmaWxlRWwsIGZpbGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcpIHtcbiAgICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSk7XG4gICAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbDtcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5tZXRhID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMTtcbiAgICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMuX29uRWxVcGRhdGVkID0gdGhpcy5vbkVsVXBkYXRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5maWxlRWwuYWRkRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKTtcbiAgICB9XG4gICAgbWV0YWRhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRhO1xuICAgIH1cbiAgICBwcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKTtcbiAgICAgIGlmICh0aGlzLl9wcm9ncmVzcyA+IHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzID49IDEwMCkge1xuICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMTAwO1xuICAgICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAxMDA7XG4gICAgICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIDEwMCwgKCkgPT4ge1xuICAgICAgICAgICAgTGl2ZVVwbG9hZGVyLnVudHJhY2tGaWxlKHRoaXMuZmlsZUVsLCB0aGlzLmZpbGUpO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9vbkRvbmUoKTtcbiAgICB9XG4gICAgaXNEb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzRG9uZTtcbiAgICB9XG4gICAgZXJyb3IocmVhc29uID0gXCJmYWlsZWRcIikge1xuICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB7IGVycm9yOiByZWFzb24gfSk7XG4gICAgICBMaXZlVXBsb2FkZXIuY2xlYXJGaWxlcyh0aGlzLmZpbGVFbCk7XG4gICAgfVxuICAgIG9uRG9uZShjYWxsYmFjaykge1xuICAgICAgdGhpcy5fb25Eb25lID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgb25FbFVwZGF0ZWQoKSB7XG4gICAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGlmIChhY3RpdmVSZWZzLmluZGV4T2YodGhpcy5yZWYpID09PSAtMSkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1ByZWZsaWdodFBheWxvYWQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgICBuYW1lOiB0aGlzLmZpbGUubmFtZSxcbiAgICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICAgIHR5cGU6IHRoaXMuZmlsZS50eXBlLFxuICAgICAgICByZWY6IHRoaXMucmVmXG4gICAgICB9O1xuICAgIH1cbiAgICB1cGxvYWRlcih1cGxvYWRlcnMpIHtcbiAgICAgIGlmICh0aGlzLm1ldGEudXBsb2FkZXIpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gdXBsb2FkZXJzW3RoaXMubWV0YS51cGxvYWRlcl0gfHwgbG9nRXJyb3IoYG5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yICR7dGhpcy5tZXRhLnVwbG9hZGVyfWApO1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm1ldGEudXBsb2FkZXIsIGNhbGxiYWNrIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBuYW1lOiBcImNoYW5uZWxcIiwgY2FsbGJhY2s6IGNoYW5uZWxVcGxvYWRlciB9O1xuICAgICAgfVxuICAgIH1cbiAgICB6aXBQb3N0RmxpZ2h0KHJlc3ApIHtcbiAgICAgIHRoaXMubWV0YSA9IHJlc3AuZW50cmllc1t0aGlzLnJlZl07XG4gICAgICBpZiAoIXRoaXMubWV0YSkge1xuICAgICAgICBsb2dFcnJvcihgbm8gcHJlZmxpZ2h0IHVwbG9hZCByZXNwb25zZSByZXR1cm5lZCB3aXRoIHJlZiAke3RoaXMucmVmfWAsIHsgaW5wdXQ6IHRoaXMuZmlsZUVsLCByZXNwb25zZTogcmVzcCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvbGl2ZV91cGxvYWRlci5qc1xuICB2YXIgbGl2ZVVwbG9hZGVyRmlsZVJlZiA9IDA7XG4gIHZhciBMaXZlVXBsb2FkZXIgPSBjbGFzcyB7XG4gICAgc3RhdGljIGdlbkZpbGVSZWYoZmlsZSkge1xuICAgICAgbGV0IHJlZiA9IGZpbGUuX3BoeFJlZjtcbiAgICAgIGlmIChyZWYgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZS5fcGh4UmVmID0gKGxpdmVVcGxvYWRlckZpbGVSZWYrKykudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGZpbGUuX3BoeFJlZjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldEVudHJ5RGF0YVVSTChpbnB1dEVsLCByZWYsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgZmlsZSA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZCgoZmlsZTIpID0+IHRoaXMuZ2VuRmlsZVJlZihmaWxlMikgPT09IHJlZik7XG4gICAgICBjYWxsYmFjayhVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpKTtcbiAgICB9XG4gICAgc3RhdGljIGhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkge1xuICAgICAgbGV0IGFjdGl2ZSA9IDA7XG4gICAgICBkb21fZGVmYXVsdC5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCkuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgaWYgKGlucHV0LmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgIT09IGlucHV0LmdldEF0dHJpYnV0ZShQSFhfRE9ORV9SRUZTKSkge1xuICAgICAgICAgIGFjdGl2ZSsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RpdmUgPiAwO1xuICAgIH1cbiAgICBzdGF0aWMgc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKSB7XG4gICAgICBsZXQgZmlsZXMgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpO1xuICAgICAgbGV0IGZpbGVEYXRhID0ge307XG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIGxldCBlbnRyeSA9IHsgcGF0aDogaW5wdXRFbC5uYW1lIH07XG4gICAgICAgIGxldCB1cGxvYWRSZWYgPSBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRik7XG4gICAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0gPSBmaWxlRGF0YVt1cGxvYWRSZWZdIHx8IFtdO1xuICAgICAgICBlbnRyeS5yZWYgPSB0aGlzLmdlbkZpbGVSZWYoZmlsZSk7XG4gICAgICAgIGVudHJ5Lm5hbWUgPSBmaWxlLm5hbWUgfHwgZW50cnkucmVmO1xuICAgICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlO1xuICAgICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplO1xuICAgICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdLnB1c2goZW50cnkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsZURhdGE7XG4gICAgfVxuICAgIHN0YXRpYyBjbGVhckZpbGVzKGlucHV0RWwpIHtcbiAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsO1xuICAgICAgaW5wdXRFbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpO1xuICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdKTtcbiAgICB9XG4gICAgc3RhdGljIHVudHJhY2tGaWxlKGlucHV0RWwsIGZpbGUpIHtcbiAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBkb21fZGVmYXVsdC5wcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIikuZmlsdGVyKChmKSA9PiAhT2JqZWN0LmlzKGYsIGZpbGUpKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0cmFja0ZpbGVzKGlucHV0RWwsIGZpbGVzKSB7XG4gICAgICBpZiAoaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgbmV3RmlsZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+ICF0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoKGYpID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpO1xuICAgICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5jb25jYXQobmV3RmlsZXMpKTtcbiAgICAgICAgaW5wdXRFbC52YWx1ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpIHtcbiAgICAgIGxldCBmaWxlSW5wdXRzID0gZG9tX2RlZmF1bHQuZmluZFVwbG9hZElucHV0cyhmb3JtRWwpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKChlbCkgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCkge1xuICAgICAgcmV0dXJuIChkb21fZGVmYXVsdC5wcml2YXRlKGlucHV0LCBcImZpbGVzXCIpIHx8IFtdKS5maWx0ZXIoKGYpID0+IFVwbG9hZEVudHJ5LmlzQWN0aXZlKGlucHV0LCBmKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpIHtcbiAgICAgIGxldCBmaWxlSW5wdXRzID0gZG9tX2RlZmF1bHQuZmluZFVwbG9hZElucHV0cyhmb3JtRWwpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKChpbnB1dCkgPT4gdGhpcy5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgc3RhdGljIGZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0KS5maWx0ZXIoKGYpID0+ICFVcGxvYWRFbnRyeS5pc1ByZWZsaWdodGVkKGlucHV0LCBmKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0RWwsIHZpZXcsIG9uQ29tcGxldGUpIHtcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlO1xuICAgICAgdGhpcy5fZW50cmllcyA9IEFycmF5LmZyb20oTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkgfHwgW10pLm1hcCgoZmlsZSkgPT4gbmV3IFVwbG9hZEVudHJ5KGlucHV0RWwsIGZpbGUsIHZpZXcpKTtcbiAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPSB0aGlzLl9lbnRyaWVzLmxlbmd0aDtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbnRyaWVzO1xuICAgIH1cbiAgICBpbml0QWRhcHRlclVwbG9hZChyZXNwLCBvbkVycm9yLCBsaXZlU29ja2V0KSB7XG4gICAgICB0aGlzLl9lbnRyaWVzID0gdGhpcy5fZW50cmllcy5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgIGVudHJ5LnppcFBvc3RGbGlnaHQocmVzcCk7XG4gICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcy0tO1xuICAgICAgICAgIGlmICh0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9KTtcbiAgICAgIGxldCBncm91cGVkRW50cmllcyA9IHRoaXMuX2VudHJpZXMucmVkdWNlKChhY2MsIGVudHJ5KSA9PiB7XG4gICAgICAgIGxldCB7IG5hbWUsIGNhbGxiYWNrIH0gPSBlbnRyeS51cGxvYWRlcihsaXZlU29ja2V0LnVwbG9hZGVycyk7XG4gICAgICAgIGFjY1tuYW1lXSA9IGFjY1tuYW1lXSB8fCB7IGNhbGxiYWNrLCBlbnRyaWVzOiBbXSB9O1xuICAgICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gZ3JvdXBlZEVudHJpZXMpIHtcbiAgICAgICAgbGV0IHsgY2FsbGJhY2ssIGVudHJpZXMgfSA9IGdyb3VwZWRFbnRyaWVzW25hbWVdO1xuICAgICAgICBjYWxsYmFjayhlbnRyaWVzLCBvbkVycm9yLCByZXNwLCBsaXZlU29ja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanNcbiAgdmFyIEhvb2tzID0ge1xuICAgIExpdmVGaWxlVXBsb2FkOiB7XG4gICAgICBhY3RpdmVSZWZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKTtcbiAgICAgIH0sXG4gICAgICBwcmVmbGlnaHRlZFJlZnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUyk7XG4gICAgICB9LFxuICAgICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKCk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlZCgpIHtcbiAgICAgICAgbGV0IG5ld1ByZWZsaWdodHMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpO1xuICAgICAgICBpZiAodGhpcy5wcmVmbGlnaHRlZFdhcyAhPT0gbmV3UHJlZmxpZ2h0cykge1xuICAgICAgICAgIHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSBuZXdQcmVmbGlnaHRzO1xuICAgICAgICAgIGlmIChuZXdQcmVmbGlnaHRzID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9fdmlldy5jYW5jZWxTdWJtaXQodGhpcy5lbC5mb3JtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmVmcygpID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhpcy5lbC52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChQSFhfTElWRV9GSUxFX1VQREFURUQpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLnJlZiA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZW50cnktcmVmXCIpO1xuICAgICAgICB0aGlzLmlucHV0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikpO1xuICAgICAgICBMaXZlVXBsb2FkZXIuZ2V0RW50cnlEYXRhVVJMKHRoaXMuaW5wdXRFbCwgdGhpcy5yZWYsICh1cmwpID0+IHtcbiAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICB0aGlzLmVsLnNyYyA9IHVybDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveWVkKCkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMudXJsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBob29rc19kZWZhdWx0ID0gSG9va3M7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanNcbiAgdmFyIERPTVBvc3RNb3JwaFJlc3RvcmVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lckJlZm9yZSwgY29udGFpbmVyQWZ0ZXIsIHVwZGF0ZVR5cGUpIHtcbiAgICAgIGxldCBpZHNCZWZvcmUgPSBuZXcgU2V0KCk7XG4gICAgICBsZXQgaWRzQWZ0ZXIgPSBuZXcgU2V0KFsuLi5jb250YWluZXJBZnRlci5jaGlsZHJlbl0ubWFwKChjaGlsZCkgPT4gY2hpbGQuaWQpKTtcbiAgICAgIGxldCBlbGVtZW50c1RvTW9kaWZ5ID0gW107XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lckJlZm9yZS5jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLmlkKSB7XG4gICAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZCk7XG4gICAgICAgICAgaWYgKGlkc0FmdGVyLmhhcyhjaGlsZC5pZCkpIHtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c0VsZW1lbnRJZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZy5pZDtcbiAgICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7IGVsZW1lbnRJZDogY2hpbGQuaWQsIHByZXZpb3VzRWxlbWVudElkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWQ7XG4gICAgICB0aGlzLnVwZGF0ZVR5cGUgPSB1cGRhdGVUeXBlO1xuICAgICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5ID0gZWxlbWVudHNUb01vZGlmeTtcbiAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoKGlkKSA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpO1xuICAgIH1cbiAgICBwZXJmb3JtKCkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IGRvbV9kZWZhdWx0LmJ5SWQodGhpcy5jb250YWluZXJJZCk7XG4gICAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkuZm9yRWFjaCgoZWxlbWVudFRvTW9kaWZ5KSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpIHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLCAocHJldmlvdXNFbGVtKSA9PiB7XG4gICAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZy5pZCA9PSBwcmV2aW91c0VsZW0uaWQ7XG4gICAgICAgICAgICAgIGlmICghaXNJblJpZ2h0UGxhY2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0VsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCAoZWxlbSkgPT4ge1xuICAgICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09IG51bGw7XG4gICAgICAgICAgICBpZiAoIWlzSW5SaWdodFBsYWNlKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnVwZGF0ZVR5cGUgPT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50SWRzVG9BZGQucmV2ZXJzZSgpLmZvckVhY2goKGVsZW1JZCkgPT4ge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIChlbGVtKSA9PiBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanNcbiAgdmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbiAgZnVuY3Rpb24gbW9ycGhBdHRycyhmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgdmFyIHRvTm9kZUF0dHJzID0gdG9Ob2RlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGF0dHI7XG4gICAgdmFyIGF0dHJOYW1lO1xuICAgIHZhciBhdHRyTmFtZXNwYWNlVVJJO1xuICAgIHZhciBhdHRyVmFsdWU7XG4gICAgdmFyIGZyb21WYWx1ZTtcbiAgICBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IGZyb21Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSB0b05vZGVBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYXR0ciA9IHRvTm9kZUF0dHJzW2ldO1xuICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG4gICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09IFwieG1sbnNcIikge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZyb21Ob2RlQXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICBhdHRyID0gZnJvbU5vZGVBdHRyc1tkXTtcbiAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmFuZ2U7XG4gIHZhciBOU19YSFRNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogZG9jdW1lbnQ7XG4gIHZhciBIQVNfVEVNUExBVEVfU1VQUE9SVCA9ICEhZG9jICYmIFwiY29udGVudFwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gIHZhciBIQVNfUkFOR0VfU1VQUE9SVCA9ICEhZG9jICYmIGRvYy5jcmVhdGVSYW5nZSAmJiBcImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFwiIGluIGRvYy5jcmVhdGVSYW5nZSgpO1xuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cikge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlKGRvYy5ib2R5KTtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcImJvZHlcIik7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xuICB9XG4gIGZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGlmIChIQVNfVEVNUExBVEVfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cik7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG4gICAgaWYgKGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5Nykge1xuICAgICAgcmV0dXJuIGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodG9Db2RlU3RhcnQgPD0gOTAgJiYgZnJvbUNvZGVTdGFydCA+PSA5Nykge1xuICAgICAgcmV0dXJuIHRvTm9kZU5hbWUgPT09IGZyb21Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID8gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgdmFyIG5leHRDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG4gIH1cbiAgZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgaWYgKGZyb21FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHNwZWNpYWxFbEhhbmRsZXJzID0ge1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChwYXJlbnROYW1lID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gXCJTRUxFQ1RcIiAmJiAhcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkge1xuICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKFwic2VsZWN0ZWRcIikgJiYgIXRvRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCBcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIFwic2VsZWN0ZWRcIik7XG4gICAgfSxcbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgXCJjaGVja2VkXCIpO1xuICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIFwiZGlzYWJsZWRcIik7XG4gICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSB0b0VsLnZhbHVlKSB7XG4gICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKFwidmFsdWVcIikpIHtcbiAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuICAgICAgICBpZiAob2xkVmFsdWUgPT0gbmV3VmFsdWUgfHwgIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICB2YXIgb3B0Z3JvdXA7XG4gICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5maXJzdENoaWxkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwiT1BUSU9OXCIpIHtcbiAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgb3B0Z3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmcm9tRWwuc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgRUxFTUVOVF9OT0RFID0gMTtcbiAgdmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xuICB2YXIgVEVYVF9OT0RFID0gMztcbiAgdmFyIENPTU1FTlRfTk9ERSA9IDg7XG4gIGZ1bmN0aW9uIG5vb3AoKSB7XG4gIH1cbiAgZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSB8fCBub2RlLmlkO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRyczIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbW9ycGhkb20yKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZnJvbU5vZGUubm9kZU5hbWUgPT09IFwiI2RvY3VtZW50XCIgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09IFwiSFRNTFwiIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaHRtbFwiKTtcbiAgICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b05vZGUgPSB0b0VsZW1lbnQodG9Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25FbFVwZGF0ZWQgPSBvcHRpb25zLm9uRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcbiAgICAgIHZhciBmcm9tTm9kZXNMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGFkZEtleWVkUmVtb3ZhbChrZXkpIHtcbiAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4VHJlZShjdXJDaGlsZCk7XG4gICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5kZXhUcmVlKGZyb21Ob2RlKTtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU5vZGVBZGRlZChlbCkge1xuICAgICAgICBvbk5vZGVBZGRlZChlbCk7XG4gICAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdW5tYXRjaGVkRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2tleV07XG4gICAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgIG1vcnBoRWwodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJDaGlsZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vcnBoRWwoZnJvbUVsLCB0b0VsLCBjaGlsZHJlbk9ubHkyKSB7XG4gICAgICAgIHZhciB0b0VsS2V5ID0gZ2V0Tm9kZUtleSh0b0VsKTtcbiAgICAgICAgaWYgKHRvRWxLZXkpIHtcbiAgICAgICAgICBkZWxldGUgZnJvbU5vZGVzTG9va3VwW3RvRWxLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5Mikge1xuICAgICAgICAgIGlmIChvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3JwaEF0dHJzMihmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgIG9uRWxVcGRhdGVkKGZyb21FbCk7XG4gICAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXJzLlRFWFRBUkVBKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIGN1clRvTm9kZUtleTtcbiAgICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgICAgdmFyIG1hdGNoaW5nRnJvbUVsO1xuICAgICAgICBvdXRlcjpcbiAgICAgICAgICB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgIHRvTmV4dFNpYmxpbmcgPSBjdXJUb05vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG4gICAgICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IGN1clRvTm9kZUNoaWxkLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tTmV4dFNpYmxpbmcgPT09IG1hdGNoaW5nRnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmluc2VydEJlZm9yZShtYXRjaGluZ0Zyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gaXNDb21wYXRpYmxlICE9PSBmYWxzZSAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlICE9PSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgPSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAmJiAobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkgJiYgY29tcGFyZU5vZGVOYW1lcyhtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChtYXRjaGluZ0Zyb21FbCk7XG4gICAgICAgICAgICAgIG1vcnBoRWwobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUoZnJvbUVsLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgdmFyIHNwZWNpYWxFbEhhbmRsZXIgPSBzcGVjaWFsRWxIYW5kbGVyc1tmcm9tRWwubm9kZU5hbWVdO1xuICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgICB2YXIgdG9Ob2RlVHlwZSA9IHRvTm9kZS5ub2RlVHlwZTtcbiAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vdmVDaGlsZHJlbihmcm9tTm9kZSwgY3JlYXRlRWxlbWVudE5TKHRvTm9kZS5ub2RlTmFtZSwgdG9Ob2RlLm5hbWVzcGFjZVVSSSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUubm9kZVZhbHVlICE9PSB0b05vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShtb3JwaGVkTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9ycGhFbChtb3JwaGVkTm9kZSwgdG9Ob2RlLCBjaGlsZHJlbk9ubHkpO1xuICAgICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxUb1JlbW92ZSA9IGZyb21Ob2Rlc0xvb2t1cFtrZXllZFJlbW92YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAobW9ycGhlZE5vZGUuYWN0dWFsaXplKSB7XG4gICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3JwaGVkTm9kZS5hY3R1YWxpemUoZnJvbU5vZGUub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICB9XG4gICAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgfTtcbiAgfVxuICB2YXIgbW9ycGhkb20gPSBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycyk7XG4gIHZhciBtb3JwaGRvbV9lc21fZGVmYXVsdCA9IG1vcnBoZG9tO1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wYXRjaC5qc1xuICB2YXIgRE9NUGF0Y2ggPSBjbGFzcyB7XG4gICAgc3RhdGljIHBhdGNoRWwoZnJvbUVsLCB0b0VsLCBhY3RpdmVFbGVtZW50KSB7XG4gICAgICBtb3JwaGRvbV9lc21fZGVmYXVsdChmcm9tRWwsIHRvRWwsIHtcbiAgICAgICAgY2hpbGRyZW5Pbmx5OiBmYWxzZSxcbiAgICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IChmcm9tRWwyLCB0b0VsMikgPT4ge1xuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShmcm9tRWwyKSAmJiBkb21fZGVmYXVsdC5pc0Zvcm1JbnB1dChmcm9tRWwyKSkge1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsMiwgdG9FbDIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHRhcmdldENJRCkge1xuICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldDtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgdGhpcy5yb290SUQgPSB2aWV3LnJvb3QuaWQ7XG4gICAgICB0aGlzLmh0bWwgPSBodG1sO1xuICAgICAgdGhpcy50YXJnZXRDSUQgPSB0YXJnZXRDSUQ7XG4gICAgICB0aGlzLmNpZFBhdGNoID0gaXNDaWQodGhpcy50YXJnZXRDSUQpO1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICAgIGJlZm9yZWFkZGVkOiBbXSxcbiAgICAgICAgYmVmb3JldXBkYXRlZDogW10sXG4gICAgICAgIGJlZm9yZXBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgICBhZnRlcmFkZGVkOiBbXSxcbiAgICAgICAgYWZ0ZXJ1cGRhdGVkOiBbXSxcbiAgICAgICAgYWZ0ZXJkaXNjYXJkZWQ6IFtdLFxuICAgICAgICBhZnRlcnBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBhZnRlcihraW5kLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIHRyYWNrQWZ0ZXIoa2luZCwgLi4uYXJncykge1xuICAgICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIG1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCkge1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKHRoaXMuY29udGFpbmVyLCBcIltwaHgtdXBkYXRlPWFwcGVuZF0gPiAqLCBbcGh4LXVwZGF0ZT1wcmVwZW5kXSA+ICpcIiwgKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUFJVTkUsIFwiXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm0oKSB7XG4gICAgICBsZXQgeyB2aWV3LCBsaXZlU29ja2V0LCBjb250YWluZXIsIGh0bWwgfSA9IHRoaXM7XG4gICAgICBsZXQgdGFyZ2V0Q29udGFpbmVyID0gdGhpcy5pc0NJRFBhdGNoKCkgPyB0aGlzLnRhcmdldENJRENvbnRhaW5lcihodG1sKSA6IGNvbnRhaW5lcjtcbiAgICAgIGlmICh0aGlzLmlzQ0lEUGF0Y2goKSAmJiAhdGFyZ2V0Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBmb2N1c2VkID0gbGl2ZVNvY2tldC5nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICBsZXQgeyBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kIH0gPSBmb2N1c2VkICYmIGRvbV9kZWZhdWx0Lmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpID8gZm9jdXNlZCA6IHt9O1xuICAgICAgbGV0IHBoeFVwZGF0ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKTtcbiAgICAgIGxldCBwaHhGZWVkYmFja0ZvciA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKTtcbiAgICAgIGxldCBkaXNhYmxlV2l0aCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKTtcbiAgICAgIGxldCBwaHhUcmlnZ2VyRXh0ZXJuYWwgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1RSSUdHRVJfQUNUSU9OKTtcbiAgICAgIGxldCBwaHhSZW1vdmUgPSBsaXZlU29ja2V0LmJpbmRpbmcoXCJyZW1vdmVcIik7XG4gICAgICBsZXQgYWRkZWQgPSBbXTtcbiAgICAgIGxldCB1cGRhdGVzID0gW107XG4gICAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXTtcbiAgICAgIGxldCBwZW5kaW5nUmVtb3ZlcyA9IFtdO1xuICAgICAgbGV0IGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IG51bGw7XG4gICAgICBsZXQgZGlmZkhUTUwgPSBsaXZlU29ja2V0LnRpbWUoXCJwcmVtb3JwaCBjb250YWluZXIgcHJlcFwiLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRGlmZkhUTUwoY29udGFpbmVyLCBodG1sLCBwaHhVcGRhdGUsIHRhcmdldENvbnRhaW5lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpO1xuICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgY29udGFpbmVyLCBjb250YWluZXIpO1xuICAgICAgbGl2ZVNvY2tldC50aW1lKFwibW9ycGhkb21cIiwgKCkgPT4ge1xuICAgICAgICBtb3JwaGRvbV9lc21fZGVmYXVsdCh0YXJnZXRDb250YWluZXIsIGRpZmZIVE1MLCB7XG4gICAgICAgICAgY2hpbGRyZW5Pbmx5OiB0YXJnZXRDb250YWluZXIuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpID09PSBudWxsLFxuICAgICAgICAgIGdldE5vZGVLZXk6IChub2RlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tX2RlZmF1bHQuaXNQaHhEZXN0cm95ZWQobm9kZSkgPyBudWxsIDogbm9kZS5pZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQmVmb3JlTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBlbCk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbk5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIGVsLnNyY3NldCkge1xuICAgICAgICAgICAgICBlbC5zcmNzZXQgPSBlbC5zcmNzZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBlbC5hdXRvcGxheSkge1xuICAgICAgICAgICAgICBlbC5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKSB7XG4gICAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tX2RlZmF1bHQuZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgZWwsIHBoeEZlZWRiYWNrRm9yKTtcbiAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSB8fCBkb21fZGVmYXVsdC5pc1BoeFN0aWNreShlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbC5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZGVkLnB1c2goZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Ob2RlRGlzY2FyZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc1BoeENoaWxkKGVsKSB8fCBkb21fZGVmYXVsdC5pc1BoeFN0aWNreShlbCkpIHtcbiAgICAgICAgICAgICAgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUgIT09IG51bGwgJiYgZG9tX2RlZmF1bHQuaXNQaHhVcGRhdGUoZWwucGFyZW50Tm9kZSwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSAmJiBlbC5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhSZW1vdmUpKSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZW1vdmVzLnB1c2goZWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwQ0lEU2libGluZyhlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVsVXBkYXRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKSB7XG4gICAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5jbGVhbkNoaWxkTm9kZXModG9FbCwgcGh4VXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBDSURTaWJsaW5nKHRvRWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc1BoeFN0aWNreShmcm9tRWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0Lm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7IGlzSWdub3JlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZG9tX2RlZmF1bHQuc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzVXBsb2FkSW5wdXQoZnJvbUVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQuYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbCk7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc1BoeENoaWxkKHRvRWwpKSB7XG4gICAgICAgICAgICAgIGxldCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwgeyBleGNsdWRlOiBbUEhYX1NUQVRJQ10gfSk7XG4gICAgICAgICAgICAgIGlmIChwcmV2U2Vzc2lvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIHByZXZTZXNzaW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3RJRCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5jb3B5UHJpdmF0ZXModG9FbCwgZnJvbUVsKTtcbiAgICAgICAgICAgIGRvbV9kZWZhdWx0LmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIHRvRWwsIHBoeEZlZWRiYWNrRm9yKTtcbiAgICAgICAgICAgIGxldCBpc0ZvY3VzZWRGb3JtRWwgPSBmb2N1c2VkICYmIGZyb21FbC5pc1NhbWVOb2RlKGZvY3VzZWQpICYmIGRvbV9kZWZhdWx0LmlzRm9ybUlucHV0KGZyb21FbCk7XG4gICAgICAgICAgICBpZiAoaXNGb2N1c2VkRm9ybUVsKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0Lm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKTtcbiAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNQaHhVcGRhdGUodG9FbCwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLnB1c2gobmV3IERPTVBvc3RNb3JwaFJlc3RvcmVyKGZyb21FbCwgdG9FbCwgdG9FbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LnN5bmNBdHRyc1RvUHJvcHModG9FbCk7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKTtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICBkZXRlY3REdXBsaWNhdGVJZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcHBlbmRQcmVwZW5kVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxpdmVTb2NrZXQudGltZShcInBvc3QtbW9ycGggYXBwZW5kL3ByZXBlbmQgcmVzdG9yYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLmZvckVhY2goKHVwZGF0ZSkgPT4gdXBkYXRlLnBlcmZvcm0oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGl2ZVNvY2tldC5zaWxlbmNlRXZlbnRzKCgpID0+IGRvbV9kZWZhdWx0LnJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSk7XG4gICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LCBcInBoeDp1cGRhdGVcIik7XG4gICAgICBhZGRlZC5mb3JFYWNoKChlbCkgPT4gdGhpcy50cmFja0FmdGVyKFwiYWRkZWRcIiwgZWwpKTtcbiAgICAgIHVwZGF0ZXMuZm9yRWFjaCgoZWwpID0+IHRoaXMudHJhY2tBZnRlcihcInVwZGF0ZWRcIiwgZWwpKTtcbiAgICAgIGlmIChwZW5kaW5nUmVtb3Zlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxpdmVTb2NrZXQudHJhbnNpdGlvblJlbW92ZXMocGVuZGluZ1JlbW92ZXMpO1xuICAgICAgICBsaXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIHBlbmRpbmdSZW1vdmVzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBkb21fZGVmYXVsdC5maXJzdFBoeENoaWxkKGVsKTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICBsaXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCBwZW5kaW5nUmVtb3Zlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkge1xuICAgICAgICBsaXZlU29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLnN1Ym1pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzQ0lEUGF0Y2goKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaWRQYXRjaDtcbiAgICB9XG4gICAgc2tpcENJRFNpYmxpbmcoZWwpIHtcbiAgICAgIHJldHVybiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TS0lQKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgdGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIHtcbiAgICAgIGlmICghdGhpcy5pc0NJRFBhdGNoKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5jb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKTtcbiAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCAmJiBkb21fZGVmYXVsdC5jaGlsZE5vZGVMZW5ndGgoaHRtbCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGlmZkhUTUwoY29udGFpbmVyLCBodG1sLCBwaHhVcGRhdGUsIHRhcmdldENvbnRhaW5lcikge1xuICAgICAgbGV0IGlzQ0lEUGF0Y2ggPSB0aGlzLmlzQ0lEUGF0Y2goKTtcbiAgICAgIGxldCBpc0NJRFdpdGhTaW5nbGVSb290ID0gaXNDSURQYXRjaCAmJiB0YXJnZXRDb250YWluZXIuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpID09PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpO1xuICAgICAgaWYgKCFpc0NJRFBhdGNoIHx8IGlzQ0lEV2l0aFNpbmdsZVJvb3QpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGlmZkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgICAgZGlmZkNvbnRhaW5lciA9IGRvbV9kZWZhdWx0LmNsb25lTm9kZSh0YXJnZXRDb250YWluZXIpO1xuICAgICAgICBsZXQgW2ZpcnN0Q29tcG9uZW50LCAuLi5yZXN0XSA9IGRvbV9kZWZhdWx0LmZpbmRDb21wb25lbnROb2RlTGlzdChkaWZmQ29udGFpbmVyLCB0aGlzLnRhcmdldENJRCk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJlc3QuZm9yRWFjaCgoZWwpID0+IGVsLnJlbW92ZSgpKTtcbiAgICAgICAgQXJyYXkuZnJvbShkaWZmQ29udGFpbmVyLmNoaWxkTm9kZXMpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLmlkICYmIGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgIT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIik7XG4gICAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEFycmF5LmZyb20odGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzKS5mb3JFYWNoKChlbCkgPT4gZGlmZkNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWwsIGZpcnN0Q29tcG9uZW50KSk7XG4gICAgICAgIGZpcnN0Q29tcG9uZW50LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gZGlmZkNvbnRhaW5lci5vdXRlckhUTUw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L3JlbmRlcmVkLmpzXG4gIHZhciBSZW5kZXJlZCA9IGNsYXNzIHtcbiAgICBzdGF0aWMgZXh0cmFjdChkaWZmKSB7XG4gICAgICBsZXQgeyBbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGUgfSA9IGRpZmY7XG4gICAgICBkZWxldGUgZGlmZltSRVBMWV07XG4gICAgICBkZWxldGUgZGlmZltFVkVOVFNdO1xuICAgICAgZGVsZXRlIGRpZmZbVElUTEVdO1xuICAgICAgcmV0dXJuIHsgZGlmZiwgdGl0bGUsIHJlcGx5OiByZXBseSB8fCBudWxsLCBldmVudHM6IGV2ZW50cyB8fCBbXSB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3SWQsIHJlbmRlcmVkKSB7XG4gICAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZDtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB7fTtcbiAgICAgIHRoaXMubWVyZ2VEaWZmKHJlbmRlcmVkKTtcbiAgICB9XG4gICAgcGFyZW50Vmlld0lkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld0lkO1xuICAgIH1cbiAgICB0b1N0cmluZyhvbmx5Q2lkcykge1xuICAgICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlVG9TdHJpbmcodGhpcy5yZW5kZXJlZCwgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpO1xuICAgIH1cbiAgICByZWN1cnNpdmVUb1N0cmluZyhyZW5kZXJlZCwgY29tcG9uZW50cyA9IHJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcykge1xuICAgICAgb25seUNpZHMgPSBvbmx5Q2lkcyA/IG5ldyBTZXQob25seUNpZHMpIDogbnVsbDtcbiAgICAgIGxldCBvdXRwdXQgPSB7IGJ1ZmZlcjogXCJcIiwgY29tcG9uZW50cywgb25seUNpZHMgfTtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG51bGwsIG91dHB1dCk7XG4gICAgICByZXR1cm4gb3V0cHV0LmJ1ZmZlcjtcbiAgICB9XG4gICAgY29tcG9uZW50Q0lEcyhkaWZmKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZltDT01QT05FTlRTXSB8fCB7fSkubWFwKChpKSA9PiBwYXJzZUludChpKSk7XG4gICAgfVxuICAgIGlzQ29tcG9uZW50T25seURpZmYoZGlmZikge1xuICAgICAgaWYgKCFkaWZmW0NPTVBPTkVOVFNdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPT09IDE7XG4gICAgfVxuICAgIGdldENvbXBvbmVudChkaWZmLCBjaWQpIHtcbiAgICAgIHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF07XG4gICAgfVxuICAgIG1lcmdlRGlmZihkaWZmKSB7XG4gICAgICBsZXQgbmV3YyA9IGRpZmZbQ09NUE9ORU5UU107XG4gICAgICBsZXQgY2FjaGUgPSB7fTtcbiAgICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdO1xuICAgICAgdGhpcy5yZW5kZXJlZCA9IHRoaXMubXV0YWJsZU1lcmdlKHRoaXMucmVuZGVyZWQsIGRpZmYpO1xuICAgICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gfHwge307XG4gICAgICBpZiAobmV3Yykge1xuICAgICAgICBsZXQgb2xkYyA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU107XG4gICAgICAgIGZvciAobGV0IGNpZCBpbiBuZXdjKSB7XG4gICAgICAgICAgbmV3Y1tjaWRdID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgbmV3Y1tjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2lkIGluIG5ld2MpIHtcbiAgICAgICAgICBvbGRjW2NpZF0gPSBuZXdjW2NpZF07XG4gICAgICAgIH1cbiAgICAgICAgZGlmZltDT01QT05FTlRTXSA9IG5ld2M7XG4gICAgICB9XG4gICAgfVxuICAgIGNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBjZGlmZiwgb2xkYywgbmV3YywgY2FjaGUpIHtcbiAgICAgIGlmIChjYWNoZVtjaWRdKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtjaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5kaWZmLCBzdGF0LCBzY2lkID0gY2RpZmZbU1RBVElDXTtcbiAgICAgICAgaWYgKGlzQ2lkKHNjaWQpKSB7XG4gICAgICAgICAgbGV0IHRkaWZmO1xuICAgICAgICAgIGlmIChzY2lkID4gMCkge1xuICAgICAgICAgICAgdGRpZmYgPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoc2NpZCwgbmV3Y1tzY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZGlmZiA9IG9sZGNbLXNjaWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ID0gdGRpZmZbU1RBVElDXTtcbiAgICAgICAgICBuZGlmZiA9IHRoaXMuY2xvbmVNZXJnZSh0ZGlmZiwgY2RpZmYpO1xuICAgICAgICAgIG5kaWZmW1NUQVRJQ10gPSBzdGF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5kaWZmID0gY2RpZmZbU1RBVElDXSAhPT0gdm9pZCAwID8gY2RpZmYgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdIHx8IHt9LCBjZGlmZik7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVbY2lkXSA9IG5kaWZmO1xuICAgICAgICByZXR1cm4gbmRpZmY7XG4gICAgICB9XG4gICAgfVxuICAgIG11dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZVtTVEFUSUNdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBkb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBsZXQgdmFsID0gc291cmNlW2tleV07XG4gICAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHZvaWQgMCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKSB7XG4gICAgICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXRWYWwsIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2xvbmVNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgbGV0IG1lcmdlZCA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0YXJnZXQpLCBzb3VyY2UpO1xuICAgICAgZm9yIChsZXQga2V5IGluIG1lcmdlZCkge1xuICAgICAgICBsZXQgdmFsID0gc291cmNlW2tleV07XG4gICAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHZvaWQgMCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICBjb21wb25lbnRUb1N0cmluZyhjaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIGNpZCk7XG4gICAgfVxuICAgIHBydW5lQ0lEcyhjaWRzKSB7XG4gICAgICBjaWRzLmZvckVhY2goKGNpZCkgPT4gZGVsZXRlIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXSk7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkO1xuICAgIH1cbiAgICBpc05ld0ZpbmdlcnByaW50KGRpZmYgPSB7fSkge1xuICAgICAgcmV0dXJuICEhZGlmZltTVEFUSUNdO1xuICAgIH1cbiAgICB0ZW1wbGF0ZVN0YXRpYyhwYXJ0LCB0ZW1wbGF0ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCkge1xuICAgICAgaWYgKHJlbmRlcmVkW0RZTkFNSUNTXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIGxldCB7IFtTVEFUSUNdOiBzdGF0aWNzIH0gPSByZW5kZXJlZDtcbiAgICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcyk7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCB0ZW1wbGF0ZXMsIG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCkge1xuICAgICAgbGV0IHsgW0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzIH0gPSByZW5kZXJlZDtcbiAgICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcyk7XG4gICAgICBsZXQgY29tcFRlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCByZW5kZXJlZFtURU1QTEFURVNdO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKykge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQpO1xuICAgICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KSB7XG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlbmRlcmVkKSkge1xuICAgICAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHJlbmRlcmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKSB7XG4gICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMucmVjdXJzaXZlVG9TdHJpbmcoY29tcG9uZW50LCBjb21wb25lbnRzLCBvbmx5Q2lkcyk7XG4gICAgICBsZXQgY29udGFpbmVyID0gdGVtcGxhdGUuY29udGVudDtcbiAgICAgIGxldCBza2lwID0gb25seUNpZHMgJiYgIW9ubHlDaWRzLmhhcyhjaWQpO1xuICAgICAgbGV0IFtoYXNDaGlsZE5vZGVzLCBoYXNDaGlsZENvbXBvbmVudHNdID0gQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGROb2RlcykucmVkdWNlKChbaGFzTm9kZXMsIGhhc0NvbXBvbmVudHNdLCBjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgdHJ1ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpO1xuICAgICAgICAgIGlmICghY2hpbGQuaWQpIHtcbiAgICAgICAgICAgIGNoaWxkLmlkID0gYCR7dGhpcy5wYXJlbnRWaWV3SWQoKX0tJHtjaWR9LSR7aX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9TS0lQLCBcIlwiKTtcbiAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLm5vZGVWYWx1ZS50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKGBvbmx5IEhUTUwgZWxlbWVudCB0YWdzIGFyZSBhbGxvd2VkIGF0IHRoZSByb290IG9mIGNvbXBvbmVudHMuXG5cbmdvdDogXCIke2NoaWxkLm5vZGVWYWx1ZS50cmltKCl9XCJcblxud2l0aGluOlxuYCwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSk7XG4gICAgICAgICAgICBjaGlsZC5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZVNwYW4oY2hpbGQubm9kZVZhbHVlLCBjaWQpKTtcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBbZmFsc2UsIGZhbHNlXSk7XG4gICAgICBpZiAoIWhhc0NoaWxkTm9kZXMgJiYgIWhhc0NoaWxkQ29tcG9uZW50cykge1xuICAgICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IHRoZSBjb21wb25lbnQgaXMgZW1wdHk6XFxuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTcGFuKFwiXCIsIGNpZCkub3V0ZXJIVE1MO1xuICAgICAgfSBlbHNlIGlmICghaGFzQ2hpbGROb2RlcyAmJiBoYXNDaGlsZENvbXBvbmVudHMpIHtcbiAgICAgICAgbG9nRXJyb3IoXCJleHBlY3RlZCBhdCBsZWFzdCBvbmUgSFRNTCBlbGVtZW50IHRhZyBkaXJlY3RseSBpbnNpZGUgYSBjb21wb25lbnQsIGJ1dCBvbmx5IHN1YmNvbXBvbmVudHMgd2VyZSBmb3VuZC4gQSBjb21wb25lbnQgbXVzdCByZW5kZXIgYXQgbGVhc3Qgb25lIEhUTUwgdGFnIGRpcmVjdGx5IGluc2lkZSBpdHNlbGYuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU3Bhbih0ZXh0LCBjaWQpIHtcbiAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLmlubmVyVGV4dCA9IHRleHQ7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpO1xuICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay5qc1xuICB2YXIgdmlld0hvb2tJRCA9IDE7XG4gIHZhciBWaWV3SG9vayA9IGNsYXNzIHtcbiAgICBzdGF0aWMgbWFrZUlEKCkge1xuICAgICAgcmV0dXJuIHZpZXdIb29rSUQrKztcbiAgICB9XG4gICAgc3RhdGljIGVsZW1lbnRJRChlbCkge1xuICAgICAgcmV0dXJuIGVsLnBoeEhvb2tJZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmlldywgZWwsIGNhbGxiYWNrcykge1xuICAgICAgdGhpcy5fX3ZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0O1xuICAgICAgdGhpcy5fX2NhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgIHRoaXMuZWwucGh4SG9va0lkID0gdGhpcy5jb25zdHJ1Y3Rvci5tYWtlSUQoKTtcbiAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9fY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IHRoaXMuX19jYWxsYmFja3Nba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19tb3VudGVkKCkge1xuICAgICAgdGhpcy5tb3VudGVkICYmIHRoaXMubW91bnRlZCgpO1xuICAgIH1cbiAgICBfX3VwZGF0ZWQoKSB7XG4gICAgICB0aGlzLnVwZGF0ZWQgJiYgdGhpcy51cGRhdGVkKCk7XG4gICAgfVxuICAgIF9fYmVmb3JlVXBkYXRlKCkge1xuICAgICAgdGhpcy5iZWZvcmVVcGRhdGUgJiYgdGhpcy5iZWZvcmVVcGRhdGUoKTtcbiAgICB9XG4gICAgX19kZXN0cm95ZWQoKSB7XG4gICAgICB0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLmRlc3Ryb3llZCgpO1xuICAgIH1cbiAgICBfX3JlY29ubmVjdGVkKCkge1xuICAgICAgaWYgKHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RlZCAmJiB0aGlzLnJlY29ubmVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fZGlzY29ubmVjdGVkKCkge1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkICYmIHRoaXMuZGlzY29ubmVjdGVkKCk7XG4gICAgfVxuICAgIHB1c2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgcmV0dXJuIHRoaXMuX192aWV3LnB1c2hIb29rRXZlbnQobnVsbCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpO1xuICAgIH1cbiAgICBwdXNoRXZlbnRUbyhwaHhUYXJnZXQsIGV2ZW50LCBwYXlsb2FkID0ge30sIG9uUmVwbHkgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZpZXcucHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBjYWxsYmFja1JlZiA9IChjdXN0b21FdmVudCwgYnlwYXNzKSA9PiBieXBhc3MgPyBldmVudCA6IGNhbGxiYWNrKGN1c3RvbUV2ZW50LmRldGFpbCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpO1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrUmVmO1xuICAgIH1cbiAgICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikge1xuICAgICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpO1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUoY2FsbGJhY2tSZWYpO1xuICAgIH1cbiAgICB1cGxvYWQobmFtZSwgZmlsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpO1xuICAgIH1cbiAgICB1cGxvYWRUbyhwaHhUYXJnZXQsIG5hbWUsIGZpbGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3KSA9PiB2aWV3LmRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlcykpO1xuICAgIH1cbiAgICBfX2NsZWFudXBfXygpIHtcbiAgICAgIHRoaXMuX19saXN0ZW5lcnMuZm9yRWFjaCgoY2FsbGJhY2tSZWYpID0+IHRoaXMucmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvanMuanNcbiAgdmFyIEpTID0ge1xuICAgIGV4ZWMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGRlZmF1bHRzKSB7XG4gICAgICBsZXQgW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc10gPSBkZWZhdWx0cyB8fCBbbnVsbCwge31dO1xuICAgICAgbGV0IGNvbW1hbmRzID0gcGh4RXZlbnQuY2hhckF0KDApID09PSBcIltcIiA/IEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXTtcbiAgICAgIGNvbW1hbmRzLmZvckVhY2goKFtraW5kLCBhcmdzXSkgPT4ge1xuICAgICAgICBpZiAoa2luZCA9PT0gZGVmYXVsdEtpbmQgJiYgZGVmYXVsdEFyZ3MuZGF0YSkge1xuICAgICAgICAgIGFyZ3MuZGF0YSA9IE9iamVjdC5hc3NpZ24oYXJncy5kYXRhIHx8IHt9LCBkZWZhdWx0QXJncy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlclRvRWxzKHNvdXJjZUVsLCBhcmdzKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBpc1Zpc2libGUoZWwpIHtcbiAgICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKTtcbiAgICB9LFxuICAgIGV4ZWNfZGlzcGF0Y2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7IHRvLCBldmVudCwgZGV0YWlsLCBidWJibGVzIH0pIHtcbiAgICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fTtcbiAgICAgIGRldGFpbC5kaXNwYXRjaGVyID0gc291cmNlRWw7XG4gICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KGVsLCBldmVudCwgeyBkZXRhaWwsIGJ1YmJsZXMgfSk7XG4gICAgfSxcbiAgICBleGVjX3B1c2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKSB7XG4gICAgICBpZiAoIXZpZXcuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgeyBldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyIH0gPSBhcmdzO1xuICAgICAgbGV0IHB1c2hPcHRzID0geyBsb2FkaW5nLCB2YWx1ZSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmc6ICEhcGFnZV9sb2FkaW5nIH07XG4gICAgICBsZXQgdGFyZ2V0U3JjID0gZXZlbnRUeXBlID09PSBcImNoYW5nZVwiICYmIGRpc3BhdGNoZXIgPyBkaXNwYXRjaGVyIDogc291cmNlRWw7XG4gICAgICBsZXQgcGh4VGFyZ2V0ID0gdGFyZ2V0IHx8IHRhcmdldFNyYy5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFwidGFyZ2V0XCIpKSB8fCB0YXJnZXRTcmM7XG4gICAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09IFwiY2hhbmdlXCIpIHtcbiAgICAgICAgICBsZXQgeyBuZXdDaWQsIF90YXJnZXQsIGNhbGxiYWNrIH0gPSBhcmdzO1xuICAgICAgICAgIF90YXJnZXQgPSBfdGFyZ2V0IHx8IChzb3VyY2VFbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgPyBzb3VyY2VFbC5uYW1lIDogdm9pZCAwKTtcbiAgICAgICAgICBpZiAoX3RhcmdldCkge1xuICAgICAgICAgICAgcHVzaE9wdHMuX3RhcmdldCA9IF90YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN1Ym1pdFwiKSB7XG4gICAgICAgICAgdGFyZ2V0Vmlldy5zdWJtaXRGb3JtKHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBwdXNoT3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Vmlldy5wdXNoRXZlbnQoZXZlbnRUeXBlLCBzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgZGF0YSwgcHVzaE9wdHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGV4ZWNfYWRkX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgeyBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSB9KSB7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgbmFtZXMsIFtdLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KTtcbiAgICB9LFxuICAgIGV4ZWNfcmVtb3ZlX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgeyBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSB9KSB7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KTtcbiAgICB9LFxuICAgIGV4ZWNfdHJhbnNpdGlvbihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHsgdGltZSwgdHJhbnNpdGlvbiB9KSB7XG4gICAgICBsZXQgW3RyYW5zaXRpb25fc3RhcnQsIHJ1bm5pbmcsIHRyYW5zaXRpb25fZW5kXSA9IHRyYW5zaXRpb247XG4gICAgICBsZXQgb25TdGFydCA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX3N0YXJ0LmNvbmNhdChydW5uaW5nKSwgW10pO1xuICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX2VuZCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZykpO1xuICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSk7XG4gICAgfSxcbiAgICBleGVjX3RvZ2dsZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHsgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lIH0pIHtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSk7XG4gICAgfSxcbiAgICBleGVjX3Nob3coZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7IGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUgfSkge1xuICAgICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpO1xuICAgIH0sXG4gICAgZXhlY19oaWRlKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgeyBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lIH0pIHtcbiAgICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKTtcbiAgICB9LFxuICAgIGV4ZWNfc2V0X2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7IGF0dHI6IFthdHRyLCB2YWxdIH0pIHtcbiAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWxdXSwgW10pO1xuICAgIH0sXG4gICAgZXhlY19yZW1vdmVfYXR0cihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHsgYXR0ciB9KSB7XG4gICAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pO1xuICAgIH0sXG4gICAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKSB7XG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCBudWxsLCB0aW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBudWxsLCB0cmFuc2l0aW9uLCB0aW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpIHtcbiAgICAgIGxldCBbaW5DbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcywgaW5FbmRDbGFzc2VzXSA9IGlucyB8fCBbW10sIFtdLCBbXV07XG4gICAgICBsZXQgW291dENsYXNzZXMsIG91dFN0YXJ0Q2xhc3Nlcywgb3V0RW5kQ2xhc3Nlc10gPSBvdXRzIHx8IFtbXSwgW10sIFtdXTtcbiAgICAgIGlmIChpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpO1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRDbGFzc2VzLCBbXSk7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dEVuZENsYXNzZXMsIG91dFN0YXJ0Q2xhc3NlcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKTtcbiAgICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRFbmRDbGFzc2VzKSk7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIChjdXJyZW50RWwpID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5TdGFydENsYXNzZXMsIG91dENsYXNzZXMuY29uY2F0KG91dFN0YXJ0Q2xhc3NlcykuY29uY2F0KG91dEVuZENsYXNzZXMpKTtcbiAgICAgICAgICAgIGRvbV9kZWZhdWx0LnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgKGN1cnJlbnRFbCkgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IHx8IFwiYmxvY2tcIik7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pO1xuICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpO1xuICAgICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSk7XG4gICAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpO1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCAoY3VycmVudEVsKSA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKTtcbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpO1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCAoY3VycmVudEVsKSA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgfHwgXCJibG9ja1wiKTtcbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctZW5kXCIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLCByZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KSB7XG4gICAgICBsZXQgW3RyYW5zaXRpb25fcnVuLCB0cmFuc2l0aW9uX3N0YXJ0LCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uIHx8IFtbXSwgW10sIFtdXTtcbiAgICAgIGlmICh0cmFuc2l0aW9uX3J1bi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHRyYW5zaXRpb25fcnVuKSwgW10pO1xuICAgICAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMuY29uY2F0KHRyYW5zaXRpb25fZW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvbl9ydW4pLmNvbmNhdCh0cmFuc2l0aW9uX3N0YXJ0KSk7XG4gICAgICAgIHJldHVybiB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBsZXQgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBkb21fZGVmYXVsdC5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSk7XG4gICAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKChuYW1lKSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKTtcbiAgICAgICAgbGV0IGtlZXBSZW1vdmVzID0gcmVtb3Zlcy5maWx0ZXIoKG5hbWUpID0+IHByZXZSZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSk7XG4gICAgICAgIGxldCBuZXdBZGRzID0gcHJldkFkZHMuZmlsdGVyKChuYW1lKSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpO1xuICAgICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcigobmFtZSkgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBSZW1vdmVzKTtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgKGN1cnJlbnRFbCkgPT4ge1xuICAgICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpO1xuICAgICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpO1xuICAgICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc107XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRPclJlbW92ZUF0dHJzKGVsLCBzZXRzLCByZW1vdmVzKSB7XG4gICAgICBsZXQgW3ByZXZTZXRzLCBwcmV2UmVtb3Zlc10gPSBkb21fZGVmYXVsdC5nZXRTdGlja3koZWwsIFwiYXR0cnNcIiwgW1tdLCBbXV0pO1xuICAgICAgbGV0IGFsdGVyZWRBdHRycyA9IHNldHMubWFwKChbYXR0ciwgX3ZhbF0pID0+IGF0dHIpLmNvbmNhdChyZW1vdmVzKTtcbiAgICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChzZXRzKTtcbiAgICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKChhdHRyKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKS5jb25jYXQocmVtb3Zlcyk7XG4gICAgICBkb21fZGVmYXVsdC5wdXRTdGlja3koZWwsIFwiYXR0cnNcIiwgKGN1cnJlbnRFbCkgPT4ge1xuICAgICAgICBuZXdSZW1vdmVzLmZvckVhY2goKGF0dHIpID0+IGN1cnJlbnRFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgICBuZXdTZXRzLmZvckVhY2goKFthdHRyLCB2YWxdKSA9PiBjdXJyZW50RWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCkpO1xuICAgICAgICByZXR1cm4gW25ld1NldHMsIG5ld1JlbW92ZXNdO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKSB7XG4gICAgICByZXR1cm4gY2xhc3Nlcy5ldmVyeSgobmFtZSkgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKTtcbiAgICB9LFxuICAgIGlzVG9nZ2xlZE91dChlbCwgb3V0Q2xhc3Nlcykge1xuICAgICAgcmV0dXJuICF0aGlzLmlzVmlzaWJsZShlbCkgfHwgdGhpcy5oYXNBbGxDbGFzc2VzKGVsLCBvdXRDbGFzc2VzKTtcbiAgICB9LFxuICAgIGZpbHRlclRvRWxzKHNvdXJjZUVsLCB7IHRvIH0pIHtcbiAgICAgIHJldHVybiB0byA/IGRvbV9kZWZhdWx0LmFsbChkb2N1bWVudCwgdG8pIDogW3NvdXJjZUVsXTtcbiAgICB9XG4gIH07XG4gIHZhciBqc19kZWZhdWx0ID0gSlM7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvdmlldy5qc1xuICB2YXIgc2VyaWFsaXplRm9ybSA9IChmb3JtLCBtZXRhLCBvbmx5TmFtZXMgPSBbXSkgPT4ge1xuICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTtcbiAgICBsZXQgdG9SZW1vdmUgPSBbXTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWwsIGtleSwgX2luZGV4KSA9PiB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICB0b1JlbW92ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9SZW1vdmUuZm9yRWFjaCgoa2V5KSA9PiBmb3JtRGF0YS5kZWxldGUoa2V5KSk7XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgICAgaWYgKG9ubHlOYW1lcy5sZW5ndGggPT09IDAgfHwgb25seU5hbWVzLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBtZXRhS2V5IGluIG1ldGEpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQobWV0YUtleSwgbWV0YVttZXRhS2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgdmFyIFZpZXcgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZWwsIGxpdmVTb2NrZXQsIHBhcmVudFZpZXcsIGZsYXNoKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0O1xuICAgICAgdGhpcy5mbGFzaCA9IGZsYXNoO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRWaWV3O1xuICAgICAgdGhpcy5yb290ID0gcGFyZW50VmlldyA/IHBhcmVudFZpZXcucm9vdCA6IHRoaXM7XG4gICAgICB0aGlzLmVsID0gZWw7XG4gICAgICB0aGlzLmlkID0gdGhpcy5lbC5pZDtcbiAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgIHRoaXMuY2hpbGRKb2lucyA9IDA7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICB0aGlzLnBydW5pbmdDSURzID0gW107XG4gICAgICB0aGlzLnJlZGlyZWN0ID0gZmFsc2U7XG4gICAgICB0aGlzLmhyZWYgPSBudWxsO1xuICAgICAgdGhpcy5qb2luQ291bnQgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmpvaW5Db3VudCAtIDEgOiAwO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWU7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgdGhpcy5qb2luQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkRvbmUpIHtcbiAgICAgICAgb25Eb25lICYmIG9uRG9uZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdO1xuICAgICAgdGhpcy52aWV3SG9va3MgPSB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0ge307XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge307XG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fTtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0ID8gdGhpcy5ocmVmIDogdm9pZCAwLFxuICAgICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHZvaWQgMCA6IHRoaXMuaHJlZiB8fCB2b2lkIDAsXG4gICAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KTtcbiAgICAgIHRoaXMuYmluZENoYW5uZWwoKTtcbiAgICB9XG4gICAgc2V0SHJlZihocmVmKSB7XG4gICAgICB0aGlzLmhyZWYgPSBocmVmO1xuICAgIH1cbiAgICBzZXRSZWRpcmVjdChocmVmKSB7XG4gICAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIGlzTWFpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikgIT09IG51bGw7XG4gICAgfVxuICAgIGNvbm5lY3RQYXJhbXMoKSB7XG4gICAgICBsZXQgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKTtcbiAgICAgIGxldCBtYW5pZmVzdCA9IGRvbV9kZWZhdWx0LmFsbChkb2N1bWVudCwgYFske3RoaXMuYmluZGluZyhQSFhfVFJBQ0tfU1RBVElDKX1dYCkubWFwKChub2RlKSA9PiBub2RlLnNyYyB8fCBub2RlLmhyZWYpLmZpbHRlcigodXJsKSA9PiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKTtcbiAgICAgIGlmIChtYW5pZmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhcmFtc1tcIl90cmFja19zdGF0aWNcIl0gPSBtYW5pZmVzdDtcbiAgICAgIH1cbiAgICAgIHBhcmFtc1tcIl9tb3VudHNcIl0gPSB0aGlzLmpvaW5Db3VudDtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYW5QdXNoKCk7XG4gICAgfVxuICAgIGdldFNlc3Npb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pO1xuICAgIH1cbiAgICBnZXRTdGF0aWMoKSB7XG4gICAgICBsZXQgdmFsID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQyk7XG4gICAgICByZXR1cm4gdmFsID09PSBcIlwiID8gbnVsbCA6IHZhbDtcbiAgICB9XG4gICAgZGVzdHJveShjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKCk7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdO1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpO1xuICAgICAgbGV0IG9uRmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95SG9vayh0aGlzLnZpZXdIb29rc1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZG9tX2RlZmF1bHQubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpO1xuICAgICAgdGhpcy5sb2coXCJkZXN0cm95ZWRcIiwgKCkgPT4gW1widGhlIGNoaWxkIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50XCJdKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLCBvbkZpbmlzaGVkKS5yZWNlaXZlKFwiZXJyb3JcIiwgb25GaW5pc2hlZCkucmVjZWl2ZShcInRpbWVvdXRcIiwgb25GaW5pc2hlZCk7XG4gICAgfVxuICAgIHNldENvbnRhaW5lckNsYXNzZXMoLi4uY2xhc3Nlcykge1xuICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFBIWF9DT05ORUNURURfQ0xBU1MsIFBIWF9ESVNDT05ORUNURURfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUyk7XG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG4gICAgfVxuICAgIHNob3dMb2FkZXIodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpO1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zaG93TG9hZGVyKCksIHRpbWVvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpIHtcbiAgICAgICAgICB0aGlzLnZpZXdIb29rc1tpZF0uX19kaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyk7XG4gICAgICB9XG4gICAgfVxuICAgIGhpZGVMb2FkZXIoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUyk7XG4gICAgfVxuICAgIHRyaWdnZXJSZWNvbm5lY3RlZCgpIHtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKSB7XG4gICAgICAgIHRoaXMudmlld0hvb2tzW2lkXS5fX3JlY29ubmVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZyhraW5kLCBtc2dDYWxsYmFjaykge1xuICAgICAgdGhpcy5saXZlU29ja2V0LmxvZyh0aGlzLCBraW5kLCBtc2dDYWxsYmFjayk7XG4gICAgfVxuICAgIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKTtcbiAgICB9XG4gICAgd2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAocGh4VGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgcGh4VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgKHZpZXcpID0+IGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2lkKHBoeFRhcmdldCkpIHtcbiAgICAgICAgbGV0IHRhcmdldHMgPSBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgcGh4VGFyZ2V0KTtcbiAgICAgICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3VuZCBtYXRjaGluZyBwaHgtdGFyZ2V0IG9mICR7cGh4VGFyZ2V0fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKHRoaXMsIHBhcnNlSW50KHBoeFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGFyZ2V0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwaHhUYXJnZXQpKTtcbiAgICAgICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbG9nRXJyb3IoYG5vdGhpbmcgZm91bmQgbWF0Y2hpbmcgdGhlIHBoeC10YXJnZXQgc2VsZWN0b3IgXCIke3BoeFRhcmdldH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB0aGlzLmxpdmVTb2NrZXQub3duZXIodGFyZ2V0LCAodmlldykgPT4gY2FsbGJhY2sodmlldywgdGFyZ2V0KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhcHBseURpZmYodHlwZSwgcmF3RGlmZiwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubG9nKHR5cGUsICgpID0+IFtcIlwiLCBjbG9uZShyYXdEaWZmKV0pO1xuICAgICAgbGV0IHsgZGlmZiwgcmVwbHksIGV2ZW50cywgdGl0bGUgfSA9IFJlbmRlcmVkLmV4dHJhY3QocmF3RGlmZik7XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0VGl0bGUodGl0bGUpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soeyBkaWZmLCByZXBseSwgZXZlbnRzIH0pO1xuICAgICAgcmV0dXJuIHJlcGx5O1xuICAgIH1cbiAgICBvbkpvaW4ocmVzcCkge1xuICAgICAgbGV0IHsgcmVuZGVyZWQsIGNvbnRhaW5lciB9ID0gcmVzcDtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgbGV0IFt0YWcsIGF0dHJzXSA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5lbCA9IGRvbV9kZWZhdWx0LnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZEpvaW5zID0gMDtcbiAgICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5mbGFzaCA9IG51bGw7XG4gICAgICBicm93c2VyX2RlZmF1bHQuZHJvcExvY2FsKHRoaXMubGl2ZVNvY2tldC5sb2NhbFN0b3JhZ2UsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgQ09OU0VDVVRJVkVfUkVMT0FEUyk7XG4gICAgICB0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsIHJlbmRlcmVkLCAoeyBkaWZmLCBldmVudHMgfSkgPT4ge1xuICAgICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpO1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKG51bGwsIFwiam9pblwiKTtcbiAgICAgICAgdGhpcy5kcm9wUGVuZGluZ1JlZnMoKTtcbiAgICAgICAgbGV0IGZvcm1zID0gdGhpcy5mb3Jtc0ZvclJlY292ZXJ5KGh0bWwpO1xuICAgICAgICB0aGlzLmpvaW5Db3VudCsrO1xuICAgICAgICBpZiAoZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvcm1zLmZvckVhY2goKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdLCBpKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCAocmVzcDIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGZvcm1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AyLCBodG1sLCBldmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBkcm9wUGVuZGluZ1JlZnMoKSB7XG4gICAgICBkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMuaWR9XCJdWyR7UEhYX1JFRn1dYCwgKGVsKSA9PiB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGKTtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBvbkpvaW5Db21wbGV0ZSh7IGxpdmVfcGF0Y2ggfSwgaHRtbCwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxIHx8IHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGRvbV9kZWZhdWx0LmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKCh0b0VsKSA9PiB7XG4gICAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApO1xuICAgICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQyk7XG4gICAgICAgIGlmIChwaHhTdGF0aWMpIHtcbiAgICAgICAgICB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5DaGlsZCh0b0VsKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRydWVEb2NFbCgpIHtcbiAgICAgIHRoaXMuZWwgPSBkb21fZGVmYXVsdC5ieUlkKHRoaXMuaWQpO1xuICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZCk7XG4gICAgfVxuICAgIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cykge1xuICAgICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKTtcbiAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKTtcbiAgICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCk7XG4gICAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UpO1xuICAgICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKTtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dLCBbZGF0YS1waHgtJHtQSFhfSE9PS31dYCwgKGhvb2tFbCkgPT4ge1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMuYWRkSG9vayhob29rRWwpO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgIGhvb2suX19tb3VudGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cyk7XG4gICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKTtcbiAgICAgIGlmIChsaXZlX3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGtpbmQsIHRvIH0gPSBsaXZlX3BhdGNoO1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZUxvYWRlcigpO1xuICAgICAgaWYgKHRoaXMuam9pbkNvdW50ID4gMSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJSZWNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgdHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uQmVmb3JlRWxVcGRhdGVkXCIsIFtmcm9tRWwsIHRvRWxdKTtcbiAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGZyb21FbCk7XG4gICAgICBsZXQgaXNJZ25vcmVkID0gaG9vayAmJiBkb21fZGVmYXVsdC5pc0lnbm9yZWQoZnJvbUVsLCB0aGlzLmJpbmRpbmcoUEhYX1VQREFURSkpO1xuICAgICAgaWYgKGhvb2sgJiYgIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKSAmJiAhKGlzSWdub3JlZCAmJiBpc0VxdWFsT2JqKGZyb21FbC5kYXRhc2V0LCB0b0VsLmRhdGFzZXQpKSkge1xuICAgICAgICBob29rLl9fYmVmb3JlVXBkYXRlKCk7XG4gICAgICAgIHJldHVybiBob29rO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXJmb3JtUGF0Y2gocGF0Y2gsIHBydW5lQ2lkcykge1xuICAgICAgbGV0IHJlbW92ZWRFbHMgPSBbXTtcbiAgICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2U7XG4gICAgICBsZXQgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KCk7XG4gICAgICBwYXRjaC5hZnRlcihcImFkZGVkXCIsIChlbCkgPT4ge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pO1xuICAgICAgICBsZXQgbmV3SG9vayA9IHRoaXMuYWRkSG9vayhlbCk7XG4gICAgICAgIGlmIChuZXdIb29rKSB7XG4gICAgICAgICAgbmV3SG9vay5fX21vdW50ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgKGVsKSA9PiB7XG4gICAgICAgIGlmIChkb21fZGVmYXVsdC5pc1BoeFN0aWNreShlbCkpIHtcbiAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQuam9pblJvb3RWaWV3cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwYXRjaC5hZnRlcihcInVwZGF0ZWRcIiwgKGVsKSA9PiB7XG4gICAgICAgIGlmICh1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKSB7XG4gICAgICAgICAgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwYXRjaC5hZnRlcihcImRpc2NhcmRlZFwiLCAoZWwpID0+IHtcbiAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJlbW92ZWRFbHMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGF0Y2guYWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCAoZWxzKSA9PiB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKGVscywgcHJ1bmVDaWRzKSk7XG4gICAgICBwYXRjaC5wZXJmb3JtKCk7XG4gICAgICB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKHJlbW92ZWRFbHMsIHBydW5lQ2lkcyk7XG4gICAgICByZXR1cm4gcGh4Q2hpbGRyZW5BZGRlZDtcbiAgICB9XG4gICAgYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxlbWVudHMsIHBydW5lQ2lkcykge1xuICAgICAgbGV0IGRlc3Ryb3llZENJRHMgPSBbXTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKHBhcmVudCkgPT4ge1xuICAgICAgICBsZXQgY29tcG9uZW50cyA9IGRvbV9kZWZhdWx0LmFsbChwYXJlbnQsIGBbJHtQSFhfQ09NUE9ORU5UfV1gKTtcbiAgICAgICAgbGV0IGhvb2tzID0gZG9tX2RlZmF1bHQuYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XWApO1xuICAgICAgICBjb21wb25lbnRzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgbGV0IGNpZCA9IHRoaXMuY29tcG9uZW50SUQoZWwpO1xuICAgICAgICAgIGlmIChpc0NpZChjaWQpICYmIGRlc3Ryb3llZENJRHMuaW5kZXhPZihjaWQpID09PSAtMSkge1xuICAgICAgICAgICAgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaG9va3MuY29uY2F0KHBhcmVudCkuZm9yRWFjaCgoaG9va0VsKSA9PiB7XG4gICAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soaG9va0VsKTtcbiAgICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAocHJ1bmVDaWRzKSB7XG4gICAgICAgIHRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgam9pbk5ld0NoaWxkcmVuKCkge1xuICAgICAgZG9tX2RlZmF1bHQuZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goKGVsKSA9PiB0aGlzLmpvaW5DaGlsZChlbCkpO1xuICAgIH1cbiAgICBnZXRDaGlsZEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1baWRdO1xuICAgIH1cbiAgICBnZXREZXNjZW5kZW50QnlFbChlbCkge1xuICAgICAgaWYgKGVsLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXVtlbC5pZF07XG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lEZXNjZW5kZW50KGlkKSB7XG4gICAgICBmb3IgKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdKSB7XG4gICAgICAgICAgaWYgKGNoaWxkSWQgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXVtjaGlsZElkXS5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGpvaW5DaGlsZChlbCkge1xuICAgICAgbGV0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEJ5SWQoZWwuaWQpO1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLmxpdmVTb2NrZXQsIHRoaXMpO1xuICAgICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bdmlldy5pZF0gPSB2aWV3O1xuICAgICAgICB2aWV3LmpvaW4oKTtcbiAgICAgICAgdGhpcy5jaGlsZEpvaW5zKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpc0pvaW5QZW5kaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pblBlbmRpbmc7XG4gICAgfVxuICAgIGFja0pvaW4oX2NoaWxkKSB7XG4gICAgICB0aGlzLmNoaWxkSm9pbnMtLTtcbiAgICAgIGlmICh0aGlzLmNoaWxkSm9pbnMgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSB7XG4gICAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICAgIGlmICghdmlldy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgICBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoZGlmZiwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgfHwgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgIWRvbV9kZWZhdWx0LmlzUGh4U3RpY2t5KHRoaXMuZWwpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKHsgZGlmZiwgZXZlbnRzIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlZC5tZXJnZURpZmYoZGlmZik7XG4gICAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWQuaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKSkge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImNvbXBvbmVudCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgbGV0IHBhcmVudENpZHMgPSBkb21fZGVmYXVsdC5maW5kUGFyZW50Q0lEcyh0aGlzLmVsLCB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikpO1xuICAgICAgICAgIHBhcmVudENpZHMuZm9yRWFjaCgocGFyZW50Q0lEKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRQYXRjaCh0aGlzLnJlbmRlcmVkLmdldENvbXBvbmVudChkaWZmLCBwYXJlbnRDSUQpLCBwYXJlbnRDSUQpKSB7XG4gICAgICAgICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1wdHkoZGlmZikpIHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnRpbWUoXCJmdWxsIHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKGRpZmYsIFwidXBkYXRlXCIpO1xuICAgICAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKTtcbiAgICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpO1xuICAgICAgaWYgKHBoeENoaWxkcmVuQWRkZWQpIHtcbiAgICAgICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQudGltZShgdG9TdHJpbmcgZGlmZiAoJHtraW5kfSlgLCAoKSA9PiB7XG4gICAgICAgIGxldCB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgICAgIGxldCBjaWRzID0gZGlmZiA/IHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKS5jb25jYXQodGhpcy5wcnVuaW5nQ0lEcykgOiBudWxsO1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcyk7XG4gICAgICAgIHJldHVybiBgPCR7dGFnfT4ke2h0bWx9PC8ke3RhZ30+YDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnRQYXRjaChkaWZmLCBjaWQpIHtcbiAgICAgIGlmIChpc0VtcHR5KGRpZmYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKTtcbiAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBjaWQpO1xuICAgICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gY2hpbGRyZW5BZGRlZDtcbiAgICB9XG4gICAgZ2V0SG9vayhlbCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChlbCldO1xuICAgIH1cbiAgICBhZGRIb29rKGVsKSB7XG4gICAgICBpZiAoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBob29rTmFtZSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS1waHgtJHtQSFhfSE9PS31gKSB8fCBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9IT09LKSk7XG4gICAgICBpZiAoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0SG9va0NhbGxiYWNrcyhob29rTmFtZSk7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghZWwuaWQpIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm8gRE9NIElEIGZvciBob29rIFwiJHtob29rTmFtZX1cIi4gSG9va3MgcmVxdWlyZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIGVsZW1lbnQuYCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBob29rID0gbmV3IFZpZXdIb29rKHRoaXMsIGVsLCBjYWxsYmFja3MpO1xuICAgICAgICB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldID0gaG9vaztcbiAgICAgICAgcmV0dXJuIGhvb2s7XG4gICAgICB9IGVsc2UgaWYgKGhvb2tOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveUhvb2soaG9vaykge1xuICAgICAgaG9vay5fX2Rlc3Ryb3llZCgpO1xuICAgICAgaG9vay5fX2NsZWFudXBfXygpO1xuICAgICAgZGVsZXRlIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV07XG4gICAgfVxuICAgIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKCh7IGRpZmYsIGV2ZW50cyB9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKTtcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgfVxuICAgIG9uQ2hhbm5lbChldmVudCwgY2IpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBldmVudCwgKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNKb2luUGVuZGluZygpKSB7XG4gICAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gY2IocmVzcCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgYmluZENoYW5uZWwoKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCwgXCJkaWZmXCIsIChyYXdEaWZmKSA9PiB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoeyBkaWZmLCBldmVudHMgfSkgPT4gdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2hhbm5lbChcInJlZGlyZWN0XCIsICh7IHRvLCBmbGFzaCB9KSA9PiB0aGlzLm9uUmVkaXJlY3QoeyB0bywgZmxhc2ggfSkpO1xuICAgICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpO1xuICAgICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKHJlYXNvbikgPT4gdGhpcy5vbkVycm9yKHJlYXNvbikpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uQ2xvc2UoKHJlYXNvbikgPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpO1xuICAgIH1cbiAgICBkZXN0cm95QWxsQ2hpbGRyZW4oKSB7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0pIHtcbiAgICAgICAgdGhpcy5nZXRDaGlsZEJ5SWQoaWQpLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25MaXZlUmVkaXJlY3QocmVkaXIpIHtcbiAgICAgIGxldCB7IHRvLCBraW5kLCBmbGFzaCB9ID0gcmVkaXI7XG4gICAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pO1xuICAgICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKTtcbiAgICB9XG4gICAgb25MaXZlUGF0Y2gocmVkaXIpIHtcbiAgICAgIGxldCB7IHRvLCBraW5kIH0gPSByZWRpcjtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMuZXhwYW5kVVJMKHRvKTtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpO1xuICAgIH1cbiAgICBleHBhbmRVUkwodG8pIHtcbiAgICAgIHJldHVybiB0by5zdGFydHNXaXRoKFwiL1wiKSA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gIDogdG87XG4gICAgfVxuICAgIG9uUmVkaXJlY3QoeyB0bywgZmxhc2ggfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCk7XG4gICAgfVxuICAgIGlzRGVzdHJveWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveWVkO1xuICAgIH1cbiAgICBqb2luKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5pc01haW4oKSkge1xuICAgICAgICB0aGlzLnN0b3BDYWxsYmFjayA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoeyB0bzogdGhpcy5ocmVmLCBraW5kOiBcImluaXRpYWxcIiB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuam9pbkNhbGxiYWNrID0gKG9uRG9uZSkgPT4ge1xuICAgICAgICBvbkRvbmUgPSBvbkRvbmUgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrID8gY2FsbGJhY2sodGhpcy5qb2luQ291bnQsIG9uRG9uZSkgOiBvbkRvbmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywgeyB0aW1lb3V0OiBmYWxzZSB9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpLnJlY2VpdmUoXCJva1wiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihkYXRhKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5yZWNlaXZlKFwiZXJyb3JcIiwgKHJlc3ApID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgdGhpcy5vbkpvaW5FcnJvcihyZXNwKSkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHsgcmVhc29uOiBcInRpbWVvdXRcIiB9KSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgb25Kb2luRXJyb3IocmVzcCkge1xuICAgICAgaWYgKHJlc3AucmVhc29uID09PSBcInVuYXV0aG9yaXplZFwiIHx8IHJlc3AucmVhc29uID09PSBcInN0YWxlXCIpIHtcbiAgICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLCByZXNwXSk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uUmVkaXJlY3QoeyB0bzogdGhpcy5ocmVmIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3AucmVkaXJlY3QgfHwgcmVzcC5saXZlX3JlZGlyZWN0KSB7XG4gICAgICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcC5yZWRpcmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmFibGUgdG8gam9pblwiLCByZXNwXSk7XG4gICAgICBpZiAodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UocmVhc29uKSB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiByZWFzb24gIT09IFwibGVhdmVcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc3Ryb3lBbGxDaGlsZHJlbigpO1xuICAgICAgdGhpcy5saXZlU29ja2V0LmRyb3BBY3RpdmVFbGVtZW50KHRoaXMpO1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXZlU29ja2V0LmlzVW5sb2FkZWQoKSkge1xuICAgICAgICB0aGlzLnNob3dMb2FkZXIoQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uRXJyb3IocmVhc29uKSB7XG4gICAgICB0aGlzLm9uQ2xvc2UocmVhc29uKTtcbiAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInZpZXcgY3Jhc2hlZFwiLCByZWFzb25dKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5saXZlU29ja2V0LmlzVW5sb2FkZWQoKSkge1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBkaXNwbGF5RXJyb3IoKSB7XG4gICAgICBpZiAodGhpcy5pc01haW4oKSkge1xuICAgICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIHsgZGV0YWlsOiB7IHRvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIiB9IH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zaG93TG9hZGVyKCk7XG4gICAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKTtcbiAgICB9XG4gICAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XTtcbiAgICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgaWYgKG9wdHMucGFnZV9sb2FkaW5nIHx8IGVsICYmIGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORykpICE9PSBudWxsKSB7XG4gICAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHsga2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWwgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQuY2lkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGRlbGV0ZSBwYXlsb2FkLmNpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywgeyB0aW1lb3V0OiB0cnVlIH0sICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5wdXNoKGV2ZW50LCBwYXlsb2FkLCBQVVNIX1RJTUVPVVQpLnJlY2VpdmUoXCJva1wiLCAocmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZpbmlzaCA9IChob29rUmVwbHkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwLmxpdmVfcGF0Y2gpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkxpdmVQYXRjaChyZXNwLmxpdmVfcGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICAgICAgICB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkxvYWRpbmdEb25lKCk7XG4gICAgICAgICAgICBvblJlcGx5KHJlc3AsIGhvb2tSZXBseSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocmVzcC5kaWZmKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBob29rUmVwbHkgPSB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByZXNwLmRpZmYsICh7IGRpZmYsIGV2ZW50cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGZpbmlzaChob29rUmVwbHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbmlzaChudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHVuZG9SZWZzKHJlZikge1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLmlkfVwiXVske1BIWF9SRUZ9PVwiJHtyZWZ9XCJdYCwgKGVsKSA9PiB7XG4gICAgICAgIGxldCBkaXNhYmxlZFZhbCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpO1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRik7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQyk7XG4gICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUFET05MWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVkVmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgZWwuZGlzYWJsZWQgPSBkaXNhYmxlZFZhbCA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFRCk7XG4gICAgICAgIH1cbiAgICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiBkb21fZGVmYXVsdC5yZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSk7XG4gICAgICAgIGxldCBkaXNhYmxlUmVzdG9yZSA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpO1xuICAgICAgICBpZiAoZGlzYWJsZVJlc3RvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICBlbC5pbm5lclRleHQgPSBkaXNhYmxlUmVzdG9yZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9FbCA9IGRvbV9kZWZhdWx0LnByaXZhdGUoZWwsIFBIWF9SRUYpO1xuICAgICAgICBpZiAodG9FbCkge1xuICAgICAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhlbCwgdG9FbCk7XG4gICAgICAgICAgRE9NUGF0Y2gucGF0Y2hFbChlbCwgdG9FbCwgdGhpcy5saXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKSk7XG4gICAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICAgIGhvb2suX191cGRhdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbV9kZWZhdWx0LmRlbGV0ZVByaXZhdGUoZWwsIFBIWF9SRUYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHV0UmVmKGVsZW1lbnRzLCBldmVudCwgb3B0cyA9IHt9KSB7XG4gICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYrKztcbiAgICAgIGxldCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKTtcbiAgICAgIGlmIChvcHRzLmxvYWRpbmcpIHtcbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQoZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBvcHRzLmxvYWRpbmcpKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYCk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMuZWwuaWQpO1xuICAgICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpO1xuICAgICAgICBpZiAoZGlzYWJsZVRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC5pbm5lclRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlzYWJsZVRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVUZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW25ld1JlZiwgZWxlbWVudHMsIG9wdHNdO1xuICAgIH1cbiAgICBjb21wb25lbnRJRChlbCkge1xuICAgICAgbGV0IGNpZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCk7XG4gICAgICByZXR1cm4gY2lkID8gcGFyc2VJbnQoY2lkKSA6IG51bGw7XG4gICAgfVxuICAgIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4LCBvcHRzID0ge30pIHtcbiAgICAgIGlmIChpc0NpZCh0YXJnZXRDdHgpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRDdHg7XG4gICAgICB9XG4gICAgICBsZXQgY2lkT3JTZWxlY3RvciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKTtcbiAgICAgIGlmIChpc0NpZChjaWRPclNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2lkT3JTZWxlY3Rvcik7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldEN0eCAmJiAoY2lkT3JTZWxlY3RvciAhPT0gbnVsbCB8fCBvcHRzLnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCkge1xuICAgICAgaWYgKGlzQ2lkKHRhcmdldEN0eCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEN0eDtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Q3R4KSB7XG4gICAgICAgIHJldHVybiBtYXliZSh0YXJnZXRDdHguY2xvc2VzdChgWyR7UEhYX0NPTVBPTkVOVH1dYCksIChlbCkgPT4gdGhpcy5vd25zRWxlbWVudChlbCkgJiYgdGhpcy5jb21wb25lbnRJRChlbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSkge1xuICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5sb2coXCJob29rXCIsICgpID0+IFtcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIiwgZXZlbnQsIHBheWxvYWRdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IFtyZWYsIGVscywgb3B0c10gPSB0aGlzLnB1dFJlZihbXSwgXCJob29rXCIpO1xuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IFtyZWYsIGVscywgb3B0c10sIFwiZXZlbnRcIiwge1xuICAgICAgICB0eXBlOiBcImhvb2tcIixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHZhbHVlOiBwYXlsb2FkLFxuICAgICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICAgIH0sIChyZXNwLCByZXBseSkgPT4gb25SZXBseShyZXBseSwgcmVmKSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBleHRyYWN0TWV0YShlbCwgbWV0YSwgdmFsdWUpIHtcbiAgICAgIGxldCBwcmVmaXggPSB0aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgbWV0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsLnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgbWV0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG1ldGEudmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCAmJiAhZWwuY2hlY2tlZCkge1xuICAgICAgICAgIGRlbGV0ZSBtZXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgbWV0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIG1ldGFba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSkge1xuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFtlbF0sIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChlbCwgdGFyZ2V0Q3R4LCBvcHRzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHB1c2hGaWxlUHJvZ3Jlc3MoZmlsZUVsLCBlbnRyeVJlZiwgcHJvZ3Jlc3MsIG9uUmVwbHkgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZpbGVFbC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgIHZpZXcucHVzaFdpdGhSZXBseShudWxsLCBcInByb2dyZXNzXCIsIHtcbiAgICAgICAgICBldmVudDogZmlsZUVsLmdldEF0dHJpYnV0ZSh2aWV3LmJpbmRpbmcoUEhYX1BST0dSRVNTKSksXG4gICAgICAgICAgcmVmOiBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgICBlbnRyeV9yZWY6IGVudHJ5UmVmLFxuICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgIGNpZDogdmlldy50YXJnZXRDb21wb25lbnRJRChmaWxlRWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgICB9LCBvblJlcGx5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoSW5wdXQoaW5wdXRFbCwgdGFyZ2V0Q3R4LCBmb3JjZUNpZCwgcGh4RXZlbnQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgdXBsb2FkcztcbiAgICAgIGxldCBjaWQgPSBpc0NpZChmb3JjZUNpZCkgPyBmb3JjZUNpZCA6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpO1xuICAgICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHRoaXMucHV0UmVmKFtpbnB1dEVsLCBpbnB1dEVsLmZvcm1dLCBcImNoYW5nZVwiLCBvcHRzKTtcbiAgICAgIGxldCBmb3JtRGF0YTtcbiAgICAgIGlmIChpbnB1dEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpKSB7XG4gICAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHsgX3RhcmdldDogb3B0cy5fdGFyZ2V0IH0sIFtpbnB1dEVsLm5hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHsgX3RhcmdldDogb3B0cy5fdGFyZ2V0IH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzVXBsb2FkSW5wdXQoaW5wdXRFbCkgJiYgaW5wdXRFbC5maWxlcyAmJiBpbnB1dEVsLmZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoaW5wdXRFbCwgQXJyYXkuZnJvbShpbnB1dEVsLmZpbGVzKSk7XG4gICAgICB9XG4gICAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCk7XG4gICAgICBsZXQgZXZlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgdXBsb2FkcyxcbiAgICAgICAgY2lkXG4gICAgICB9O1xuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCBldmVudCwgKHJlc3ApID0+IHtcbiAgICAgICAgZG9tX2RlZmF1bHQuc2hvd0Vycm9yKGlucHV0RWwsIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19GT1IpKTtcbiAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzVXBsb2FkSW5wdXQoaW5wdXRFbCkgJiYgaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1hdXRvLXVwbG9hZFwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCAoX3VwbG9hZHMpID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcCk7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckF3YWl0aW5nU3VibWl0KGlucHV0RWwuZm9ybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cmlnZ2VyQXdhaXRpbmdTdWJtaXQoZm9ybUVsKSB7XG4gICAgICBsZXQgYXdhaXRpbmdTdWJtaXQgPSB0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpO1xuICAgICAgaWYgKGF3YWl0aW5nU3VibWl0KSB7XG4gICAgICAgIGxldCBbX2VsLCBfcmVmLCBfb3B0cywgY2FsbGJhY2tdID0gYXdhaXRpbmdTdWJtaXQ7XG4gICAgICAgIHRoaXMuY2FuY2VsU3VibWl0KGZvcm1FbCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1TdWJtaXRzLmZpbmQoKFtlbCwgX3JlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IGVsLmlzU2FtZU5vZGUoZm9ybUVsKSk7XG4gICAgfVxuICAgIHNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2Zvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFja10pO1xuICAgIH1cbiAgICBjYW5jZWxTdWJtaXQoZm9ybUVsKSB7XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gdGhpcy5mb3JtU3VibWl0cy5maWx0ZXIoKFtlbCwgcmVmLCBfY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIGlmIChlbC5pc1NhbWVOb2RlKGZvcm1FbCkpIHtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KSB7XG4gICAgICBsZXQgZmlsdGVySWdub3JlZCA9IChlbCkgPT4ge1xuICAgICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKTtcbiAgICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSk7XG4gICAgICB9O1xuICAgICAgbGV0IGZpbHRlckRpc2FibGVzID0gKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKTtcbiAgICAgIH07XG4gICAgICBsZXQgZmlsdGVyQnV0dG9uID0gKGVsKSA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCI7XG4gICAgICBsZXQgZmlsdGVySW5wdXQgPSAoZWwpID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSk7XG4gICAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4ge1xuICAgICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpO1xuICAgICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKTtcbiAgICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuICAgICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuICAgICAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xuICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpO1xuICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSk7XG4gICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgIGlmIChpbnB1dC5maWxlcykge1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgaW5wdXQuZGlzYWJsZWQpO1xuICAgICAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiLCBvcHRzKTtcbiAgICAgIH07XG4gICAgICBsZXQgY2lkID0gdGhpcy50YXJnZXRDb21wb25lbnRJRChmb3JtRWwsIHRhcmdldEN0eCk7XG4gICAgICBpZiAoTGl2ZVVwbG9hZGVyLmhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkpIHtcbiAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKCk7XG4gICAgICAgIGxldCBwdXNoID0gKCkgPT4gdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsIG9uUmVwbHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaCk7XG4gICAgICB9IGVsc2UgaWYgKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IFtyZWYsIGVsc10gPSByZWZHZW5lcmF0b3IoKTtcbiAgICAgICAgbGV0IHByb3h5UmVmR2VuID0gKCkgPT4gW3JlZiwgZWxzLCBvcHRzXTtcbiAgICAgICAgdGhpcy51cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7fSk7XG4gICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHByb3h5UmVmR2VuLCBcImV2ZW50XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICAgICAgY2lkXG4gICAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHt9KTtcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWRcbiAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgb25Db21wbGV0ZSkge1xuICAgICAgbGV0IGpvaW5Db3VudEF0VXBsb2FkID0gdGhpcy5qb2luQ291bnQ7XG4gICAgICBsZXQgaW5wdXRFbHMgPSBMaXZlVXBsb2FkZXIuYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpO1xuICAgICAgbGV0IG51bUZpbGVJbnB1dHNJblByb2dyZXNzID0gaW5wdXRFbHMubGVuZ3RoO1xuICAgICAgaW5wdXRFbHMuZm9yRWFjaCgoaW5wdXRFbCkgPT4ge1xuICAgICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgTGl2ZVVwbG9hZGVyKGlucHV0RWwsIHRoaXMsICgpID0+IHtcbiAgICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tO1xuICAgICAgICAgIGlmIChudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBsb2FkZXJzW2lucHV0RWxdID0gdXBsb2FkZXI7XG4gICAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcCgoZW50cnkpID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pO1xuICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZCwgKHJlc3ApID0+IHtcbiAgICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKTtcbiAgICAgICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpO1xuICAgICAgICAgICAgbGV0IFtlbnRyeV9yZWYsIHJlYXNvbl0gPSByZXNwLmVycm9yO1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHtlbnRyeV9yZWZ9YCwgcmVhc29uXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IGpvaW5Db3VudEF0VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlc09yQmxvYnMpIHtcbiAgICAgIGxldCBpbnB1dHMgPSBkb21fZGVmYXVsdC5maW5kVXBsb2FkSW5wdXRzKHRoaXMuZWwpLmZpbHRlcigoZWwpID0+IGVsLm5hbWUgPT09IG5hbWUpO1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHsgZGV0YWlsOiB7IGZpbGVzOiBmaWxlc09yQmxvYnMgfSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXTtcbiAgICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpO1xuICAgICAgICBqc19kZWZhdWx0LmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHsgX3RhcmdldDogaW5wdXQubmFtZSwgbmV3Q2lkLCBjYWxsYmFjayB9XSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBsaW5rUmVmID0gdGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGhyZWYpO1xuICAgICAgbGV0IHJlZkdlbiA9IHRhcmdldEVsID8gKCkgPT4gdGhpcy5wdXRSZWYoW3RhcmdldEVsXSwgXCJjbGlja1wiKSA6IG51bGw7XG4gICAgICBsZXQgZmFsbGJhY2sgPSAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgbGV0IHB1c2ggPSB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuLCBcImxpdmVfcGF0Y2hcIiwgeyB1cmw6IGhyZWYgfSwgKHJlc3ApID0+IHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwLmxpbmtfcmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihocmVmLCBudWxsLCBjYWxsYmFjaywgbGlua1JlZik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHB1c2gpIHtcbiAgICAgICAgcHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCBmYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3Jtc0ZvclJlY292ZXJ5KGh0bWwpIHtcbiAgICAgIGlmICh0aGlzLmpvaW5Db3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBkb21fZGVmYXVsdC5hbGwodGhpcy5lbCwgYGZvcm1bJHtwaHhDaGFuZ2V9XWApLmZpbHRlcigoZm9ybSkgPT4gZm9ybS5pZCAmJiB0aGlzLm93bnNFbGVtZW50KGZvcm0pKS5maWx0ZXIoKGZvcm0pID0+IGZvcm0uZWxlbWVudHMubGVuZ3RoID4gMCkuZmlsdGVyKChmb3JtKSA9PiBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpICE9PSBcImlnbm9yZVwiKS5tYXAoKGZvcm0pID0+IHtcbiAgICAgICAgbGV0IG5ld0Zvcm0gPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoYGZvcm1baWQ9XCIke2Zvcm0uaWR9XCJdWyR7cGh4Q2hhbmdlfT1cIiR7Zm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKX1cIl1gKTtcbiAgICAgICAgaWYgKG5ld0Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gW2Zvcm0sIG5ld0Zvcm0sIHRoaXMudGFyZ2V0Q29tcG9uZW50SUQobmV3Rm9ybSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbZm9ybSwgbnVsbCwgbnVsbF07XG4gICAgICAgIH1cbiAgICAgIH0pLmZpbHRlcigoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0pID0+IG5ld0Zvcm0pO1xuICAgIH1cbiAgICBtYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpIHtcbiAgICAgIGxldCB3aWxsRGVzdHJveUNJRHMgPSBkZXN0cm95ZWRDSURzLmZpbHRlcigoY2lkKSA9PiB7XG4gICAgICAgIHJldHVybiBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDA7XG4gICAgICB9KTtcbiAgICAgIGlmICh3aWxsRGVzdHJveUNJRHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnBydW5pbmdDSURzLnB1c2goLi4ud2lsbERlc3Ryb3lDSURzKTtcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc193aWxsX2Rlc3Ryb3lcIiwgeyBjaWRzOiB3aWxsRGVzdHJveUNJRHMgfSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSB0aGlzLnBydW5pbmdDSURzLmZpbHRlcigoY2lkKSA9PiB3aWxsRGVzdHJveUNJRHMuaW5kZXhPZihjaWQpICE9PSAtMSk7XG4gICAgICAgICAgbGV0IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyA9IHdpbGxEZXN0cm95Q0lEcy5maWx0ZXIoKGNpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbV9kZWZhdWx0LmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY29tcGxldGVseURlc3Ryb3lDSURzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfZGVzdHJveWVkXCIsIHsgY2lkczogY29tcGxldGVseURlc3Ryb3lDSURzIH0sIChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyZWQucHJ1bmVDSURzKHJlc3AuY2lkcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBvd25zRWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fCBtYXliZShlbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKSwgKG5vZGUpID0+IG5vZGUuaWQpID09PSB0aGlzLmlkO1xuICAgIH1cbiAgICBzdWJtaXRGb3JtKGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMgPSB7fSkge1xuICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSk7XG4gICAgICBsZXQgcGh4RmVlZGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKTtcbiAgICAgIGxldCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpO1xuICAgICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpO1xuICAgICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCAoKSA9PiB7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZG9tX2RlZmF1bHQuc2hvd0Vycm9yKGlucHV0LCBwaHhGZWVkYmFjaykpO1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRpbmcoa2luZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qc1xuICB2YXIgTGl2ZVNvY2tldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHBoeFNvY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICB0aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICBpZiAoIXBoeFNvY2tldCB8fCBwaHhTb2NrZXQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICAgICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gICAgICBgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0ID0gbmV3IHBoeFNvY2tldCh1cmwsIG9wdHMpO1xuICAgICAgdGhpcy5iaW5kaW5nUHJlZml4ID0gb3B0cy5iaW5kaW5nUHJlZml4IHx8IEJJTkRJTkdfUFJFRklYO1xuICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSk7XG4gICAgICB0aGlzLnZpZXdMb2dnZXIgPSBvcHRzLnZpZXdMb2dnZXI7XG4gICAgICB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzID0gb3B0cy5tZXRhZGF0YSB8fCB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKGNsb25lKERFRkFVTFRTKSwgb3B0cy5kZWZhdWx0cyB8fCB7fSk7XG4gICAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbDtcbiAgICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubWFpbiA9IG51bGw7XG4gICAgICB0aGlzLm91dGdvaW5nTWFpbkVsID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5saW5rUmVmID0gMTtcbiAgICAgIHRoaXMucm9vdHMgPSB7fTtcbiAgICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKHdpbmRvdy5sb2NhdGlvbik7XG4gICAgICB0aGlzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0gb3B0cy51cGxvYWRlcnMgfHwge307XG4gICAgICB0aGlzLmxvYWRlclRpbWVvdXQgPSBvcHRzLmxvYWRlclRpbWVvdXQgfHwgTE9BREVSX1RJTUVPVVQ7XG4gICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLm1heFJlbG9hZHMgPSBvcHRzLm1heFJlbG9hZHMgfHwgTUFYX1JFTE9BRFM7XG4gICAgICB0aGlzLnJlbG9hZEppdHRlck1pbiA9IG9wdHMucmVsb2FkSml0dGVyTWluIHx8IFJFTE9BRF9KSVRURVJfTUlOO1xuICAgICAgdGhpcy5yZWxvYWRKaXR0ZXJNYXggPSBvcHRzLnJlbG9hZEppdHRlck1heCB8fCBSRUxPQURfSklUVEVSX01BWDtcbiAgICAgIHRoaXMuZmFpbHNhZmVKaXR0ZXIgPSBvcHRzLmZhaWxzYWZlSml0dGVyIHx8IEZBSUxTQUZFX0pJVFRFUjtcbiAgICAgIHRoaXMubG9jYWxTdG9yYWdlID0gb3B0cy5sb2NhbFN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IGZhbHNlO1xuICAgICAgdGhpcy5kb21DYWxsYmFja3MgPSBPYmplY3QuYXNzaWduKHsgb25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSwgb25CZWZvcmVFbFVwZGF0ZWQ6IGNsb3N1cmUoKSB9LCBvcHRzLmRvbSB8fCB7fSk7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgIHRoaXMudW5sb2FkZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1VubG9hZGVkKCkpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpc1Byb2ZpbGVFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiO1xuICAgIH1cbiAgICBpc0RlYnVnRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuICAgIGlzRGVidWdEaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiO1xuICAgIH1cbiAgICBlbmFibGVEZWJ1ZygpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgZW5hYmxlUHJvZmlsaW5nKCkge1xuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9QUk9GSUxFLCBcInRydWVcIik7XG4gICAgfVxuICAgIGRpc2FibGVEZWJ1ZygpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIik7XG4gICAgfVxuICAgIGRpc2FibGVQcm9maWxpbmcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX1BST0ZJTEUpO1xuICAgIH1cbiAgICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcykge1xuICAgICAgdGhpcy5lbmFibGVEZWJ1ZygpO1xuICAgICAgY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpO1xuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKTtcbiAgICB9XG4gICAgZGlzYWJsZUxhdGVuY3lTaW0oKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKTtcbiAgICB9XG4gICAgZ2V0TGF0ZW5jeVNpbSgpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKTtcbiAgICAgIHJldHVybiBzdHIgPyBwYXJzZUludChzdHIpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0U29ja2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0O1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSkge1xuICAgICAgICB0aGlzLmVuYWJsZURlYnVnKCk7XG4gICAgICB9XG4gICAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5qb2luUm9vdFZpZXdzKCkpIHtcbiAgICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cygpO1xuICAgICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1haW4pIHtcbiAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApIHtcbiAgICAgICAgZG9Db25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiBkb0Nvbm5lY3QoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoY2FsbGJhY2spIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcik7XG4gICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcik7XG4gICAgICB0aGlzLnNvY2tldC5yZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgZXhlY0pTKGVsLCBlbmNvZGVkSlMsIGV2ZW50VHlwZSA9IG51bGwpIHtcbiAgICAgIHRoaXMub3duZXIoZWwsICh2aWV3KSA9PiBqc19kZWZhdWx0LmV4ZWMoZXZlbnRUeXBlLCBlbmNvZGVkSlMsIHZpZXcsIGVsKSk7XG4gICAgfVxuICAgIHRyaWdnZXJET00oa2luZCwgYXJncykge1xuICAgICAgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncyk7XG4gICAgfVxuICAgIHRpbWUobmFtZSwgZnVuYykge1xuICAgICAgaWYgKCF0aGlzLmlzUHJvZmlsZUVuYWJsZWQoKSB8fCAhY29uc29sZS50aW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLnRpbWUobmFtZSk7XG4gICAgICBsZXQgcmVzdWx0ID0gZnVuYygpO1xuICAgICAgY29uc29sZS50aW1lRW5kKG5hbWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy52aWV3TG9nZ2VyKSB7XG4gICAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy52aWV3TG9nZ2VyKHZpZXcsIGtpbmQsIG1zZywgb2JqKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgICAgZGVidWcodmlldywga2luZCwgbXNnLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0RE9NVXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmFmdGVyKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKTtcbiAgICB9XG4gICAgb25DaGFubmVsKGNoYW5uZWwsIGV2ZW50LCBjYikge1xuICAgICAgY2hhbm5lbC5vbihldmVudCwgKGRhdGEpID0+IHtcbiAgICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKTtcbiAgICAgICAgaWYgKCFsYXRlbmN5KSB7XG4gICAgICAgICAgY2IoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50YCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB3cmFwUHVzaCh2aWV3LCBvcHRzLCBwdXNoKSB7XG4gICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpO1xuICAgICAgbGV0IG9sZEpvaW5Db3VudCA9IHZpZXcuam9pbkNvdW50O1xuICAgICAgaWYgKCFsYXRlbmN5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgb3B0cy50aW1lb3V0KSB7XG4gICAgICAgICAgcmV0dXJuIHB1c2goKS5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5qb2luQ291bnQgPT09IG9sZEpvaW5Db3VudCAmJiAhdmlldy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVsb2FkV2l0aEppdHRlcih2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2codmlldywgXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJgKTtcbiAgICAgIGxldCBmYWtlUHVzaCA9IHtcbiAgICAgICAgcmVjZWl2ZXM6IFtdLFxuICAgICAgICByZWNlaXZlKGtpbmQsIGNiKSB7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlcy5wdXNoKFtraW5kLCBjYl0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmlzRGVzdHJveWVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmFrZVB1c2gucmVjZWl2ZXMucmVkdWNlKChhY2MsIFtraW5kLCBjYl0pID0+IGFjYy5yZWNlaXZlKGtpbmQsIGNiKSwgcHVzaCgpKTtcbiAgICAgIH0sIGxhdGVuY3kpO1xuICAgICAgcmV0dXJuIGZha2VQdXNoO1xuICAgIH1cbiAgICByZWxvYWRXaXRoSml0dGVyKHZpZXcsIGxvZykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgbGV0IG1pbk1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNaW47XG4gICAgICBsZXQgbWF4TXMgPSB0aGlzLnJlbG9hZEppdHRlck1heDtcbiAgICAgIGxldCBhZnRlck1zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heE1zIC0gbWluTXMgKyAxKSkgKyBtaW5NcztcbiAgICAgIGxldCB0cmllcyA9IGJyb3dzZXJfZGVmYXVsdC51cGRhdGVMb2NhbCh0aGlzLmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTLCAwLCAoY291bnQpID0+IGNvdW50ICsgMSk7XG4gICAgICBpZiAodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpIHtcbiAgICAgICAgYWZ0ZXJNcyA9IHRoaXMuZmFpbHNhZmVKaXR0ZXI7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5pc0Rlc3Ryb3llZCgpIHx8IHZpZXcuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgbG9nID8gbG9nKCkgOiB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BlbmNvdW50ZXJlZCAke3RyaWVzfSBjb25zZWN1dGl2ZSByZWxvYWRzYF0pO1xuICAgICAgICBpZiAodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpIHtcbiAgICAgICAgICB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BleGNlZWRlZCAke3RoaXMubWF4UmVsb2Fkc30gY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZWBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNQZW5kaW5nTGluaygpKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdGhpcy5wZW5kaW5nTGluaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGFmdGVyTXMpO1xuICAgIH1cbiAgICBnZXRIb29rQ2FsbGJhY2tzKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aChcIlBob2VuaXguXCIpID8gaG9va3NfZGVmYXVsdFtuYW1lLnNwbGl0KFwiLlwiKVsxXV0gOiB0aGlzLmhvb2tzW25hbWVdO1xuICAgIH1cbiAgICBpc1VubG9hZGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5sb2FkZWQ7XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCk7XG4gICAgfVxuICAgIGdldEJpbmRpbmdQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaW5kaW5nUHJlZml4O1xuICAgIH1cbiAgICBiaW5kaW5nKGtpbmQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmdldEJpbmRpbmdQcmVmaXgoKX0ke2tpbmR9YDtcbiAgICB9XG4gICAgY2hhbm5lbCh0b3BpYywgcGFyYW1zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb2NrZXQuY2hhbm5lbCh0b3BpYywgcGFyYW1zKTtcbiAgICB9XG4gICAgam9pblJvb3RWaWV3cygpIHtcbiAgICAgIGxldCByb290c0ZvdW5kID0gZmFsc2U7XG4gICAgICBkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIGAke1BIWF9WSUVXX1NFTEVDVE9SfTpub3QoWyR7UEhYX1BBUkVOVF9JRH1dKWAsIChyb290RWwpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFJvb3RCeUlkKHJvb3RFbC5pZCkpIHtcbiAgICAgICAgICBsZXQgdmlldyA9IHRoaXMubmV3Um9vdFZpZXcocm9vdEVsKTtcbiAgICAgICAgICB2aWV3LnNldEhyZWYodGhpcy5nZXRIcmVmKCkpO1xuICAgICAgICAgIHZpZXcuam9pbigpO1xuICAgICAgICAgIGlmIChyb290RWwuZ2V0QXR0cmlidXRlKFBIWF9NQUlOKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluID0gdmlldztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm9vdHNGb3VuZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByb290c0ZvdW5kO1xuICAgIH1cbiAgICByZWRpcmVjdCh0bywgZmxhc2gpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgYnJvd3Nlcl9kZWZhdWx0LnJlZGlyZWN0KHRvLCBmbGFzaCk7XG4gICAgfVxuICAgIHJlcGxhY2VNYWluKGhyZWYsIGZsYXNoLCBjYWxsYmFjayA9IG51bGwsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKSB7XG4gICAgICB0aGlzLm91dGdvaW5nTWFpbkVsID0gdGhpcy5vdXRnb2luZ01haW5FbCB8fCB0aGlzLm1haW4uZWw7XG4gICAgICBsZXQgbmV3TWFpbkVsID0gZG9tX2RlZmF1bHQuY2xvbmVOb2RlKHRoaXMub3V0Z29pbmdNYWluRWwsIFwiXCIpO1xuICAgICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KTtcbiAgICAgIHRoaXMubWFpbi5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1haW4gPSB0aGlzLm5ld1Jvb3RWaWV3KG5ld01haW5FbCwgZmxhc2gpO1xuICAgICAgdGhpcy5tYWluLnNldFJlZGlyZWN0KGhyZWYpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uUmVtb3ZlcygpO1xuICAgICAgdGhpcy5tYWluLmpvaW4oKGpvaW5Db3VudCwgb25Eb25lKSA9PiB7XG4gICAgICAgIGlmIChqb2luQ291bnQgPT09IDEgJiYgdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5maW5kUGh4U3RpY2t5KGRvY3VtZW50KS5mb3JFYWNoKChlbCkgPT4gbmV3TWFpbkVsLmFwcGVuZENoaWxkKGVsKSk7XG4gICAgICAgICAgICB0aGlzLm91dGdvaW5nTWFpbkVsLnJlcGxhY2VXaXRoKG5ld01haW5FbCk7XG4gICAgICAgICAgICB0aGlzLm91dGdvaW5nTWFpbkVsID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzKSB7XG4gICAgICBsZXQgcmVtb3ZlQXR0ciA9IHRoaXMuYmluZGluZyhcInJlbW92ZVwiKTtcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMgfHwgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7cmVtb3ZlQXR0cn1dYCk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICB0aGlzLmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKHJlbW92ZUF0dHIpLCBcInJlbW92ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzUGh4VmlldyhlbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsO1xuICAgIH1cbiAgICBuZXdSb290VmlldyhlbCwgZmxhc2gpIHtcbiAgICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoKTtcbiAgICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3O1xuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIChlbCkgPT4gdGhpcy5nZXRWaWV3QnlFbChlbCkpIHx8IHRoaXMubWFpbjtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIGNhbGxiYWNrKHZpZXcpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aXRoaW5Pd25lcnMoY2hpbGRFbCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub3duZXIoY2hpbGRFbCwgKHZpZXcpID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKTtcbiAgICB9XG4gICAgZ2V0Vmlld0J5RWwoZWwpIHtcbiAgICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpO1xuICAgICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgKHJvb3QpID0+IHJvb3QuZ2V0RGVzY2VuZGVudEJ5RWwoZWwpKTtcbiAgICB9XG4gICAgZ2V0Um9vdEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3RzW2lkXTtcbiAgICB9XG4gICAgZGVzdHJveUFsbFZpZXdzKCkge1xuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5yb290cykge1xuICAgICAgICB0aGlzLnJvb3RzW2lkXS5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW2lkXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFpbiA9IG51bGw7XG4gICAgfVxuICAgIGRlc3Ryb3lWaWV3QnlFbChlbCkge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpO1xuICAgICAgaWYgKHJvb3QgJiYgcm9vdC5pZCA9PT0gZWwuaWQpIHtcbiAgICAgICAgcm9vdC5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdO1xuICAgICAgfSBlbHNlIGlmIChyb290KSB7XG4gICAgICAgIHJvb3QuZGVzdHJveURlc2NlbmRlbnQoZWwuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRBY3RpdmVFbGVtZW50KHRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBjYW5jZWwpO1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBjYW5jZWwpO1xuICAgIH1cbiAgICBnZXRBY3RpdmVFbGVtZW50KCkge1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgIH1cbiAgICB9XG4gICAgZHJvcEFjdGl2ZUVsZW1lbnQodmlldykge1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZSAmJiB2aWV3Lm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkpIHtcbiAgICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpIHtcbiAgICAgIGlmICh0aGlzLnByZXZBY3RpdmUgJiYgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMucHJldkFjdGl2ZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgICBibHVyQWN0aXZlRWxlbWVudCgpIHtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aGlzLnByZXZBY3RpdmUuYmx1cigpO1xuICAgICAgfVxuICAgIH1cbiAgICBiaW5kVG9wTGV2ZWxFdmVudHMoKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnNvY2tldC5vbkNsb3NlKChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29kZSA9PT0gMWUzICYmIHRoaXMubWFpbikge1xuICAgICAgICAgIHRoaXMucmVsb2FkV2l0aEppdHRlcih0aGlzLm1haW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnBlcnNpc3RlZCkge1xuICAgICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCIgfSk7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHRoaXMuYmluZE5hdigpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2tzKCk7XG4gICAgICB0aGlzLmJpbmRGb3JtcygpO1xuICAgICAgdGhpcy5iaW5kKHsga2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgZXZlbnRUYXJnZXQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoS2V5ID0gdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfS0VZKSk7XG4gICAgICAgIGxldCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBfX3NwcmVhZFZhbHVlcyh7IGtleTogZS5rZXkgfSwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAganNfZGVmYXVsdC5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7IGRhdGEgfV0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJpbmQoeyBibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIiB9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBldmVudFRhcmdldCkgPT4ge1xuICAgICAgICBpZiAoIWV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBfX3NwcmVhZFZhbHVlcyh7IGtleTogZS5rZXkgfSwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAgICBqc19kZWZhdWx0LmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHsgZGF0YSB9XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaW5kKHsgYmx1cjogXCJibHVyXCIsIGZvY3VzOiBcImZvY3VzXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHBoeFRhcmdldCA9PT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpO1xuICAgICAgICAgIGpzX2RlZmF1bHQuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwgeyBkYXRhIH1dKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksICh0cnVlVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRydWVUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkcm9wVGFyZ2V0ID0gZHJvcFRhcmdldElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3BUYXJnZXRJZCk7XG4gICAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMgfHwgW10pO1xuICAgICAgICBpZiAoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzKTtcbiAgICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIChlKSA9PiB7XG4gICAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKCFkb21fZGVmYXVsdC5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKChmKSA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYik7XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpO1xuICAgICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlLCB0YXJnZXRFbCkgOiB7fTtcbiAgICB9XG4gICAgc2V0UGVuZGluZ0xpbmsoaHJlZikge1xuICAgICAgdGhpcy5saW5rUmVmKys7XG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gaHJlZjtcbiAgICAgIHJldHVybiB0aGlzLmxpbmtSZWY7XG4gICAgfVxuICAgIGNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpIHtcbiAgICAgIGlmICh0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGluaztcbiAgICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRIcmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgaGFzUGVuZGluZ0xpbmsoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnBlbmRpbmdMaW5rO1xuICAgIH1cbiAgICBiaW5kKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICAgIGZvciAobGV0IGV2ZW50IGluIGV2ZW50cykge1xuICAgICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF07XG4gICAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhldmVudCk7XG4gICAgICAgICAgbGV0IHdpbmRvd0JpbmRpbmcgPSB0aGlzLmJpbmRpbmcoYHdpbmRvdy0ke2V2ZW50fWApO1xuICAgICAgICAgIGxldCB0YXJnZXRQaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYmluZGluZyk7XG4gICAgICAgICAgaWYgKHRhcmdldFBoeEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIGBbJHt3aW5kb3dCaW5kaW5nfV1gLCAoZWwpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHdpbmRvd0JpbmRpbmcpO1xuICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlKGVsLCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsICh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZWwsIHBoeEV2ZW50LCBcIndpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBiaW5kQ2xpY2tzKCkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBlLnRhcmdldCk7XG4gICAgICB0aGlzLmJpbmRDbGljayhcImNsaWNrXCIsIFwiY2xpY2tcIiwgZmFsc2UpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2soXCJtb3VzZWRvd25cIiwgXCJjYXB0dXJlLWNsaWNrXCIsIHRydWUpO1xuICAgIH1cbiAgICBiaW5kQ2xpY2soZXZlbnROYW1lLCBiaW5kaW5nTmFtZSwgY2FwdHVyZSkge1xuICAgICAgbGV0IGNsaWNrID0gdGhpcy5iaW5kaW5nKGJpbmRpbmdOYW1lKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG4gICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQubWF0Y2hlcyhgWyR7Y2xpY2t9XWApID8gZS50YXJnZXQgOiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yKGBbJHtjbGlja31dYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCB8fCBlLnRhcmdldDtcbiAgICAgICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhjbGlja1N0YXJ0ZWRBdFRhcmdldCwgY2xpY2spO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXRUYXJnZXQpO1xuICAgICAgICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwaHhFdmVudCA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKGNsaWNrKTtcbiAgICAgICAgaWYgKCFwaHhFdmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVib3VuY2UodGFyZ2V0LCBlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyh0YXJnZXQsICh2aWV3KSA9PiB7XG4gICAgICAgICAgICBqc19kZWZhdWx0LmV4ZWMoXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0LCBbXCJwdXNoXCIsIHsgZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCB0YXJnZXQpIH1dKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBjYXB0dXJlKTtcbiAgICB9XG4gICAgZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXQpIHtcbiAgICAgIGxldCBwaHhDbGlja0F3YXkgPSB0aGlzLmJpbmRpbmcoXCJjbGljay1hd2F5XCIpO1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7cGh4Q2xpY2tBd2F5fV1gLCAoZWwpID0+IHtcbiAgICAgICAgaWYgKCEoZWwuaXNTYW1lTm9kZShjbGlja1N0YXJ0ZWRBdCkgfHwgZWwuY29udGFpbnMoY2xpY2tTdGFydGVkQXQpKSkge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHBoeENsaWNrQXdheSk7XG4gICAgICAgICAgICBpZiAoanNfZGVmYXVsdC5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgICAgIGpzX2RlZmF1bHQuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7IGRhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgZS50YXJnZXQpIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmROYXYoKSB7XG4gICAgICBpZiAoIWJyb3dzZXJfZGVmYXVsdC5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgIH1cbiAgICAgIGxldCBzY3JvbGxUaW1lciA9IG51bGw7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoX2UpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKTtcbiAgICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBicm93c2VyX2RlZmF1bHQudXBkYXRlQ3VycmVudFN0YXRlKChzdGF0ZSkgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBzY3JvbGw6IHdpbmRvdy5zY3JvbGxZIH0pKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB0eXBlLCBpZCwgcm9vdCwgc2Nyb2xsIH0gPSBldmVudC5zdGF0ZSB8fCB7fTtcbiAgICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5tYWluLmlzQ29ubmVjdGVkKCkgJiYgKHR5cGUgPT09IFwicGF0Y2hcIiAmJiBpZCA9PT0gdGhpcy5tYWluLmlkKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLnB1c2hMaW5rUGF0Y2goaHJlZiwgbnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY3JvbGwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGwpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspO1xuICAgICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspO1xuICAgICAgICBsZXQgd2FudHNOZXdUYWIgPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYnV0dG9uID09PSAxO1xuICAgICAgICBpZiAoIXR5cGUgfHwgIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluIHx8IHdhbnRzTmV3VGFiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBocmVmID0gdGFyZ2V0LmhyZWY7XG4gICAgICAgIGxldCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTGluayA9PT0gaHJlZikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlID09PSBcInBhdGNoXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInJlZGlyZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtQSFhfTElWRV9MSU5LfSB0byBiZSBcInBhdGNoXCIgb3IgXCJyZWRpcmVjdFwiLCBnb3Q6ICR7dHlwZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50LCBwYXlsb2FkID0ge30pIHtcbiAgICAgIGRvbV9kZWZhdWx0LmRpc3BhdGNoRXZlbnQod2luZG93LCBgcGh4OiR7ZXZlbnR9YCwgeyBkZXRhaWw6IHBheWxvYWQgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnRzKGV2ZW50cykge1xuICAgICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpO1xuICAgIH1cbiAgICB3aXRoUGFnZUxvYWRpbmcoaW5mbywgY2FsbGJhY2spIHtcbiAgICAgIGRvbV9kZWZhdWx0LmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgeyBkZXRhaWw6IGluZm8gfSk7XG4gICAgICBsZXQgZG9uZSA9ICgpID0+IGRvbV9kZWZhdWx0LmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCB7IGRldGFpbDogaW5mbyB9KTtcbiAgICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGRvbmUpIDogZG9uZTtcbiAgICB9XG4gICAgcHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldEVsKSB7XG4gICAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7IHRvOiBocmVmLCBraW5kOiBcInBhdGNoXCIgfSwgKGRvbmUpID0+IHtcbiAgICAgICAgdGhpcy5tYWluLnB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIChsaW5rUmVmKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKSB7XG4gICAgICBpZiAoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJvd3Nlcl9kZWZhdWx0LnB1c2hTdGF0ZShsaW5rU3RhdGUsIHsgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkIH0sIGhyZWYpO1xuICAgICAgdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbik7XG4gICAgfVxuICAgIGhpc3RvcnlSZWRpcmVjdChocmVmLCBsaW5rU3RhdGUsIGZsYXNoKSB7XG4gICAgICBsZXQgc2Nyb2xsID0gd2luZG93LnNjcm9sbFk7XG4gICAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7IHRvOiBocmVmLCBraW5kOiBcInJlZGlyZWN0XCIgfSwgKGRvbmUpID0+IHtcbiAgICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgKCkgPT4ge1xuICAgICAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUobGlua1N0YXRlLCB7IHR5cGU6IFwicmVkaXJlY3RcIiwgaWQ6IHRoaXMubWFpbi5pZCwgc2Nyb2xsIH0sIGhyZWYpO1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVwbGFjZVJvb3RIaXN0b3J5KCkge1xuICAgICAgYnJvd3Nlcl9kZWZhdWx0LnB1c2hTdGF0ZShcInJlcGxhY2VcIiwgeyByb290OiB0cnVlLCB0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWQgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2ggfSA9IHRoaXMuY3VycmVudExvY2F0aW9uO1xuICAgICAgaWYgKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKG5ld0xvY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRGb3JtcygpIHtcbiAgICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICAgIHRoaXMub24oXCJzdWJtaXRcIiwgKGUpID0+IHtcbiAgICAgICAgbGV0IHBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInN1Ym1pdFwiKSk7XG4gICAgICAgIGlmICghcGh4RXZlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgIGpzX2RlZmF1bHQuZXhlYyhcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwge31dKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgICBmb3IgKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKSB7XG4gICAgICAgIHRoaXMub24odHlwZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpO1xuICAgICAgICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0O1xuICAgICAgICAgIGxldCBpbnB1dEV2ZW50ID0gaW5wdXQuZ2V0QXR0cmlidXRlKHBoeENoYW5nZSk7XG4gICAgICAgICAgbGV0IGZvcm1FdmVudCA9IGlucHV0LmZvcm0gJiYgaW5wdXQuZm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKTtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dEV2ZW50IHx8IGZvcm1FdmVudDtcbiAgICAgICAgICBpZiAoIXBoeEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSBcIm51bWJlclwiICYmIGlucHV0LnZhbGlkaXR5ICYmIGlucHV0LnZhbGlkaXR5LmJhZElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBkaXNwYXRjaGVyID0gaW5wdXRFdmVudCA/IGlucHV0IDogaW5wdXQuZm9ybTtcbiAgICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICBsZXQgeyBhdCwgdHlwZTogbGFzdFR5cGUgfSA9IGRvbV9kZWZhdWx0LnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge307XG4gICAgICAgICAgaWYgKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7IGF0OiBjdXJyZW50SXRlcmF0aW9ucywgdHlwZSB9KTtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCB0eXBlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhkaXNwYXRjaGVyLCAodmlldykgPT4ge1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAoIWRvbV9kZWZhdWx0LmlzVGV4dHVhbElucHV0KGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRWxlbWVudChpbnB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAganNfZGVmYXVsdC5leGVjKFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB2aWV3LCBpbnB1dCwgW1wicHVzaFwiLCB7IF90YXJnZXQ6IGUudGFyZ2V0Lm5hbWUsIGRpc3BhdGNoZXIgfV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVib3VuY2UoZWwsIGV2ZW50LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSBcImJsdXJcIiB8fCBldmVudFR5cGUgPT09IFwiZm9jdXNvdXRcIikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpO1xuICAgICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSk7XG4gICAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpO1xuICAgICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCAodmlldykgPT4ge1xuICAgICAgICBsZXQgYXN5bmNGaWx0ZXIgPSAoKSA9PiAhdmlldy5pc0Rlc3Ryb3llZCgpICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpO1xuICAgICAgICBkb21fZGVmYXVsdC5kZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGFzeW5jRmlsdGVyLCAoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjaykge1xuICAgICAgdGhpcy5zaWxlbmNlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoZSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc2lsZW5jZWQpIHtcbiAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgVHJhbnNpdGlvblNldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLnBlbmRpbmdPcHMgPSBbXTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmZvckVhY2goKHRpbWVyKSA9PiB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25zLmRlbGV0ZSh0aW1lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmx1c2hQZW5kaW5nT3BzKCk7XG4gICAgfVxuICAgIGFmdGVyKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaFBlbmRpbmdPcChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKSB7XG4gICAgICBvblN0YXJ0KCk7XG4gICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpO1xuICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZSk7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmFkZCh0aW1lcik7XG4gICAgfVxuICAgIHB1c2hQZW5kaW5nT3Aob3ApIHtcbiAgICAgIHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNpemU7XG4gICAgfVxuICAgIGZsdXNoUGVuZGluZ09wcygpIHtcbiAgICAgIHRoaXMucGVuZGluZ09wcy5mb3JFYWNoKChvcCkgPT4gb3AoKSk7XG4gICAgICB0aGlzLnBlbmRpbmdPcHMgPSBbXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBwaG9lbml4X2xpdmVfdmlld19leHBvcnRzO1xufSkoKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQTtBQUNBO0FBK0NBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWxFQTtBQW1FQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXJEQTtBQXNEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTVZQTtBQTZZQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE5RkE7QUFDQTtBQWdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBHQTtBQUNBO0FBc0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUF2QkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBekJBO0FBdUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlDQTtBQUNBO0FBZ0RBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBeEVBO0FBMEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNHQTtBQTZHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlQQTtBQUNBO0FBZ1FBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5OQTtBQUNBO0FBcU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBdkVBO0FBQ0E7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTdLQTtBQThLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTE5QkE7QUFDQTtBQTQ5QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlyQkE7QUErckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekNBO0FBMENBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../deps/phoenix_live_view/priv/static/phoenix_live_view.js\n");

/***/ }),

/***/ "./css/app.scss":
/*!**********************!*\
  !*** ./css/app.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXBwLnNjc3M/MjQyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/app.scss\n");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.scss */ \"./css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nprogress */ \"./node_modules/nprogress/nprogress.js\");\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(nprogress__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! phoenix_live_view */ \"../deps/phoenix_live_view/priv/static/phoenix_live_view.js\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__);\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import deps with the dep name or local files with a relative path, for example:\n//\n//     import {Socket} from \"phoenix\"\n//     import socket from \"./socket\"\n//\n\n\n\n\n\nvar csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\");\nvar liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__[\"LiveSocket\"](\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"], {\n  params: {\n    _csrf_token: csrfToken\n  }\n}); // Show progress bar on live navigation and form submits\n\nwindow.addEventListener(\"phx:page-loading-start\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.start();\n});\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.done();\n}); // connect if there are any LiveViews on the page\n\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\n// >> liveSocket.disableLatencySim()\n\nwindow.liveSocket = liveSocket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/NzQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ1NTIHNvIHRoYXQgd2VicGFjayB3aWxsIGxvYWQgaXQuXG4vLyBUaGUgTWluaUNzc0V4dHJhY3RQbHVnaW4gaXMgdXNlZCB0byBzZXBhcmF0ZSBpdCBvdXQgaW50b1xuLy8gaXRzIG93biBDU1MgZmlsZS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuc2Nzc1wiXG5cbi8vIHdlYnBhY2sgYXV0b21hdGljYWxseSBidW5kbGVzIGFsbCBtb2R1bGVzIGluIHlvdXJcbi8vIGVudHJ5IHBvaW50cy4gVGhvc2UgZW50cnkgcG9pbnRzIGNhbiBiZSBjb25maWd1cmVkXG4vLyBpbiBcIndlYnBhY2suY29uZmlnLmpzXCIuXG4vL1xuLy8gSW1wb3J0IGRlcHMgd2l0aCB0aGUgZGVwIG5hbWUgb3IgbG9jYWwgZmlsZXMgd2l0aCBhIHJlbGF0aXZlIHBhdGgsIGZvciBleGFtcGxlOlxuLy9cbi8vICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuLy8gICAgIGltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0XCJcbi8vXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxuaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbmltcG9ydCBOUHJvZ3Jlc3MgZnJvbSBcIm5wcm9ncmVzc1wiXG5pbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG5cbmxldCBjc3JmVG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSdjc3JmLXRva2VuJ11cIikuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKVxubGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwge3BhcmFtczoge19jc3JmX3Rva2VuOiBjc3JmVG9rZW59fSlcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCBpbmZvID0+IE5Qcm9ncmVzcy5zdGFydCgpKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbyA9PiBOUHJvZ3Jlc3MuZG9uZSgpKVxuXG4vLyBjb25uZWN0IGlmIHRoZXJlIGFyZSBhbnkgTGl2ZVZpZXdzIG9uIHRoZSBwYWdlXG5saXZlU29ja2V0LmNvbm5lY3QoKVxuXG4vLyBleHBvc2UgbGl2ZVNvY2tldCBvbiB3aW5kb3cgZm9yIHdlYiBjb25zb2xlIGRlYnVnIGxvZ3MgYW5kIGxhdGVuY3kgc2ltdWxhdGlvbjpcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlRGVidWcoKVxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVMYXRlbmN5U2ltKDEwMDApICAvLyBlbmFibGVkIGZvciBkdXJhdGlvbiBvZiBicm93c2VyIHNlc3Npb25cbi8vID4+IGxpdmVTb2NrZXQuZGlzYWJsZUxhdGVuY3lTaW0oKVxud2luZG93LmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/app.js\n");

/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMi4wJztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtICRwcm9taXNlIGpRVWVyeSBQcm9taXNlXG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRpYWwgPSAwLCBjdXJyZW50ID0gMDtcblxuICAgIE5Qcm9ncmVzcy5wcm9taXNlID0gZnVuY3Rpb24oJHByb21pc2UpIHtcbiAgICAgIGlmICghJHByb21pc2UgfHwgJHByb21pc2Uuc3RhdGUoKSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSAwO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgICBwcm9ncmVzcyAmJiByZW1vdmVFbGVtZW50KHByb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmVzcyBiYXIgaXMgcmVuZGVyZWQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pc1JlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9zaXRpb25pbmcgQ1NTIHJ1bGUgdG8gdXNlLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTbmlmZiBvbiBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgdmFyIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAvLyBTbmlmZiBwcmVmaXhlc1xuICAgIHZhciB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdXZWJraXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdNb3pUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTW96JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnbXNUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnbXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdPVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ08nIDogJyc7XG5cbiAgICBpZiAodmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyB3aXRoIDNEIHN1cHBvcnQsIGUuZy4gV2Via2l0LCBJRTEwXG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkJztcbiAgICB9IGVsc2UgaWYgKHZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCAzRCBzdXBwb3J0LCBlLmcuIElFOVxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IHRyYW5zbGF0ZSgpIHN1cHBvcnQsIGUuZy4gSUU3LThcbiAgICAgIHJldHVybiAnbWFyZ2luJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICBpZiAobiA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICBpZiAobiA+IG1heCkgcmV0dXJuIG1heDtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIGNvbnZlcnRzIGEgcGVyY2VudGFnZSAoYDAuLjFgKSB0byBhIGJhciB0cmFuc2xhdGVYXG4gICAqIHBlcmNlbnRhZ2UgKGAtMTAwJS4uMCVgKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9CYXJQZXJjKG4pIHtcbiAgICByZXR1cm4gKC0xICsgbikgKiAxMDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJldHVybnMgdGhlIGNvcnJlY3QgQ1NTIGZvciBjaGFuZ2luZyB0aGUgYmFyJ3NcbiAgICogcG9zaXRpb24gZ2l2ZW4gYW4gbiBwZXJjZW50YWdlLCBhbmQgc3BlZWQgYW5kIGVhc2UgZnJvbSBTZXR0aW5nc1xuICAgKi9cblxuICBmdW5jdGlvbiBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkge1xuICAgIHZhciBiYXJDU1M7XG5cbiAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnK3RvQmFyUGVyYyhuKSsnJSwwLDApJyB9O1xuICAgIH0gZWxzZSBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcrdG9CYXJQZXJjKG4pKyclLDApJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJDU1MgPSB7ICdtYXJnaW4tbGVmdCc6IHRvQmFyUGVyYyhuKSsnJScgfTtcbiAgICB9XG5cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9ICdhbGwgJytzcGVlZCsnbXMgJytlYXNlO1xuXG4gICAgcmV0dXJuIGJhckNTUztcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cblxuICB2YXIgcXVldWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGZuID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PSAxKSBuZXh0KCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBBcHBsaWVzIGNzcyBwcm9wZXJ0aWVzIHRvIGFuIGVsZW1lbnQsIHNpbWlsYXIgdG8gdGhlIGpRdWVyeSBcbiAgICogY3NzIG1ldGhvZC5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBoZWxwZXIgZG9lcyBhc3Npc3Qgd2l0aCB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkgbmFtZXMsIGl0IFxuICAgKiBkb2VzIG5vdCBwZXJmb3JtIGFueSBtYW5pcHVsYXRpb24gb2YgdmFsdWVzIHByaW9yIHRvIHNldHRpbmcgc3R5bGVzLlxuICAgKi9cblxuICB2YXIgY3NzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdPJywgJ01veicsICdtcycgXSxcbiAgICAgICAgY3NzUHJvcHMgICAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXi1tcy0vLCAnbXMtJykucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHJldHVybiBuYW1lO1xuXG4gICAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgICBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgdmVuZG9yTmFtZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKHZlbmRvck5hbWUgaW4gc3R5bGUpIHJldHVybiB2ZW5kb3JOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHlsZVByb3AobmFtZSkge1xuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICAgIHJldHVybiBjc3NQcm9wc1tuYW1lXSB8fCAoY3NzUHJvcHNbbmFtZV0gPSBnZXRWZW5kb3JQcm9wKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJvcCA9IGdldFN0eWxlUHJvcChwcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvcCwgXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlDc3MoZWxlbWVudCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lcyBjb250YWlucyBhIGNsYXNzIG5hbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID8gZWxlbWVudCA6IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBBZGRzIGEgY2xhc3MgdG8gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0ID0gb2xkTGlzdCArIG5hbWU7XG5cbiAgICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjsgXG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3Q7XG5cbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBjbGFzcyBuYW1lLlxuICAgIG5ld0xpc3QgPSBvbGRMaXN0LnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSwgbmV3TGlzdC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEdldHMgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgY2xhc3MgbmFtZXMgb24gdGhlIGVsZW1lbnQuIFxuICAgKiBUaGUgbGlzdCBpcyB3cmFwcGVkIHdpdGggYSBzaW5nbGUgc3BhY2Ugb24gZWFjaCBlbmQgdG8gZmFjaWxpdGF0ZSBmaW5kaW5nIFxuICAgKiBtYXRjaGVzIHdpdGhpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKCcgJyArIChlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gTlByb2dyZXNzO1xufSk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nprogress/nprogress.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/app.js */"./js/app.js");


/***/ })

/******/ });